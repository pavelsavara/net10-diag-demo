<?xml version="1.0"?>
<doc>
    <assembly>
        <name>System.Private.DataContractSerialization</name>
    </assembly>
    <members>
        <member name="P:System.NotImplemented.ByDesign">
            <summary>
            Permanent NotImplementedException with no message shown to user.
            </summary>
        </member>
        <member name="M:System.NotImplemented.ByDesignWithMessage(System.String)">
            <summary>
            Permanent NotImplementedException with localized message shown to user.
            </summary>
        </member>
        <member name="P:System.HexConverter.CharToHexLookup">
            <summary>Map from an ASCII char to its hex value, e.g. arr['b'] == 11. 0xFF means it's not a hex digit.</summary>
        </member>
        <member name="M:System.Runtime.Serialization.DataContracts.ClassDataContract.IsNonAttributedTypeValidForSerialization(System.Type)">
            <SecurityNote>
            RequiresReview - callers may need to depend on isNonAttributedType for a security decision
                       isNonAttributedType must be calculated correctly
                       IsNonAttributedTypeValidForSerialization is used as part of the isNonAttributedType calculation and
                       is therefore marked SRR
            Safe - does not let caller influence isNonAttributedType calculation; no harm in leaking value
            </SecurityNote>
        </member>
        <member name="M:System.Runtime.Serialization.DataContracts.ClassDataContract.RequiresMemberAccessForRead(System.Security.SecurityException)">
            <SecurityNote>
            Review - calculates whether this class requires MemberAccessPermission for deserialization.
                     since this information is used to determine whether to give the generated code access
                     permissions to private members, any changes to the logic should be reviewed.
            </SecurityNote>
        </member>
        <member name="M:System.Runtime.Serialization.DataContracts.ClassDataContract.RequiresMemberAccessForWrite(System.Security.SecurityException)">
            <SecurityNote>
            Review - calculates whether this class requires MemberAccessPermission for serialization.
                     since this information is used to determine whether to give the generated code access
                     permissions to private members, any changes to the logic should be reviewed.
            </SecurityNote>
        </member>
        <member name="F:System.Runtime.Serialization.DataContracts.ClassDataContract.ClassDataContractCriticalHelper._isNonAttributedType">
            <SecurityNote>
            in serialization/deserialization we base the decision whether to Demand SerializationFormatter permission on this value and isNonAttributedType
            </SecurityNote>
        </member>
        <member name="F:System.Runtime.Serialization.DataContracts.ClassDataContract.ClassDataContractCriticalHelper._hasDataContract">
            <SecurityNote>
            in serialization/deserialization we base the decision whether to Demand SerializationFormatter permission on this value and hasDataContract
            </SecurityNote>
        </member>
        <member name="M:System.Runtime.Serialization.DataContracts.ClassDataContract.ClassDataContractCriticalHelper.SetIsNonAttributedType(System.Type)">
            <SecurityNote>
            RequiresReview - marked SRR because callers may need to depend on isNonAttributedType for a security decision
                       isNonAttributedType must be calculated correctly
                       SetIsNonAttributedType should not be called before GetXmlNameAndSetHasDataContract since it
                       is dependent on the correct calculation of hasDataContract
            Safe - does not let caller influence isNonAttributedType calculation; no harm in leaking value
            </SecurityNote>
        </member>
        <member name="P:System.Runtime.Serialization.DataContracts.ClassDataContract.ObjectType">
            <summary>
             Get object type for Xml/JsonFormatReaderGenerator
            </summary>
        </member>
        <member name="M:System.Runtime.Serialization.DataContracts.CollectionDataContract.RequiresMemberAccessForRead(System.Security.SecurityException)">
            <SecurityNote>
            Review - calculates whether this collection requires MemberAccessPermission for deserialization.
                     since this information is used to determine whether to give the generated code access
                     permissions to private members, any changes to the logic should be reviewed.
            </SecurityNote>
        </member>
        <member name="M:System.Runtime.Serialization.DataContracts.CollectionDataContract.RequiresMemberAccessForWrite(System.Security.SecurityException)">
            <SecurityNote>
            Review - calculates whether this collection requires MemberAccessPermission for serialization.
                     since this information is used to determine whether to give the generated code access
                     permissions to private members, any changes to the logic should be reviewed.
            </SecurityNote>
        </member>
        <member name="F:System.Runtime.Serialization.DataContracts.DataContract.DataContractCriticalHelper._typeForInitialization">
            <SecurityNote>
            Critical - in deserialization, we initialize an object instance passing this Type to GetUninitializedObject method
            </SecurityNote>
        </member>
        <member name="M:System.Runtime.Serialization.DataContracts.DataContract.IsTypeVisible(System.Type)">
            <SecurityNote>
            Review - checks type visibility to calculate if access to it requires MemberAccessPermission.
                     since this information is used to determine whether to give the generated code access
                     permissions to private members, any changes to the logic should be reviewed.
            </SecurityNote>
        </member>
        <member name="M:System.Runtime.Serialization.DataContracts.DataContract.ConstructorRequiresMemberAccess(System.Reflection.ConstructorInfo)">
            <SecurityNote>
            Review - checks constructor visibility to calculate if access to it requires MemberAccessPermission.
                     note: does local check for visibility, assuming that the declaring Type visibility has been checked.
                     since this information is used to determine whether to give the generated code access
                     permissions to private members, any changes to the logic should be reviewed.
            </SecurityNote>
        </member>
        <member name="M:System.Runtime.Serialization.DataContracts.DataContract.MethodRequiresMemberAccess(System.Reflection.MethodInfo)">
            <SecurityNote>
            Review - checks method visibility to calculate if access to it requires MemberAccessPermission.
                     note: does local check for visibility, assuming that the declaring Type visibility has been checked.
                     since this information is used to determine whether to give the generated code access
                     permissions to private members, any changes to the logic should be reviewed.
            </SecurityNote>
        </member>
        <member name="M:System.Runtime.Serialization.DataContracts.DataContract.FieldRequiresMemberAccess(System.Reflection.FieldInfo)">
            <SecurityNote>
            Review - checks field visibility to calculate if access to it requires MemberAccessPermission.
                     note: does local check for visibility, assuming that the declaring Type visibility has been checked.
                     since this information is used to determine whether to give the generated code access
                     permissions to private members, any changes to the logic should be reviewed.
            </SecurityNote>
        </member>
        <member name="M:System.Runtime.Serialization.DataContracts.DataContract.IsTypeVisibleInSerializationModule(System.Type)">
            <SecurityNote>
            Review - checks type visibility to calculate if access to it requires MemberAccessPermission.
                     since this information is used to determine whether to give the generated code access
                     permissions to private members, any changes to the logic should be reviewed.
            </SecurityNote>
        </member>
        <member name="M:System.Runtime.Serialization.DataContracts.DataContract.IsMemberVisibleInSerializationModule(System.Reflection.MemberInfo)">
            <SecurityNote>
            Review - checks member visibility to calculate if access to it requires MemberAccessPermission.
                     since this information is used to determine whether to give the generated code access
                     permissions to private members, any changes to the logic should be reviewed.
            </SecurityNote>
        </member>
        <member name="M:System.Runtime.Serialization.DataContracts.DataContract.IsAssemblyFriendOfSerialization(System.Reflection.Assembly)">
            <SecurityNote>
            Review - checks member visibility to calculate if access to it requires MemberAccessPermission.
                     since this information is used to determine whether to give the generated code access
                     permissions to private members, any changes to the logic should be reviewed.
            </SecurityNote>
        </member>
        <member name="M:System.Runtime.Serialization.DataContracts.DataMember.RequiresMemberAccessForGet">
            <SecurityNote>
            Review - checks member visibility to calculate if access to it requires MemberAccessPermission for serialization.
                     since this information is used to determine whether to give the generated code access
                     permissions to private members, any changes to the logic should be reviewed.
            </SecurityNote>
        </member>
        <member name="M:System.Runtime.Serialization.DataContracts.DataMember.RequiresMemberAccessForSet">
            <SecurityNote>
            Review - checks member visibility to calculate if access to it requires MemberAccessPermission for deserialization.
                     since this information is used to determine whether to give the generated code access
                     permissions to private members, any changes to the logic should be reviewed.
            </SecurityNote>
        </member>
        <member name="M:System.Runtime.Serialization.DataContracts.XmlDataContract.RequiresMemberAccessForCreate(System.Security.SecurityException)">
            <SecurityNote>
            Review - calculates whether this Xml type requires MemberAccessPermission for deserialization.
                     since this information is used to determine whether to give the generated code access
                     permissions to private members, any changes to the logic should be reviewed.
            </SecurityNote>
        </member>
        <member name="T:System.Runtime.Serialization.DataContractSerializerSettings">
            <summary>
            Dummy documentation
            </summary>
        </member>
        <member name="P:System.Runtime.Serialization.DataContractSerializerSettings.RootName">
            <summary>
            Gets or sets Dummy documentation
            </summary>
        </member>
        <member name="P:System.Runtime.Serialization.DataContractSerializerSettings.RootNamespace">
            <summary>
            Gets or sets Dummy documentation
            </summary>
        </member>
        <member name="P:System.Runtime.Serialization.DataContractSerializerSettings.KnownTypes">
            <summary>
            Gets or sets Dummy documentation
            </summary>
        </member>
        <member name="P:System.Runtime.Serialization.DataContractSerializerSettings.MaxItemsInObjectGraph">
            <summary>
            Gets or sets Dummy documentation
            </summary>
        </member>
        <member name="P:System.Runtime.Serialization.DataContractSerializerSettings.IgnoreExtensionDataObject">
            <summary>
            Gets or sets a value indicating whether Dummy documentation
            </summary>
        </member>
        <member name="P:System.Runtime.Serialization.DataContractSerializerSettings.PreserveObjectReferences">
            <summary>
            Gets or sets a value indicating whether Dummy documentation
            </summary>
        </member>
        <member name="P:System.Runtime.Serialization.DataContractSerializerSettings.DataContractResolver">
            <summary>
            Gets or sets Dummy documentation
            </summary>
        </member>
        <member name="P:System.Runtime.Serialization.DataContractSerializerSettings.SerializeReadOnlyTypes">
            <summary>
            Gets or sets a value indicating whether Dummy documentation
            </summary>
        </member>
        <member name="T:System.Runtime.Serialization.ExportOptions">
             <summary>
             Represents the options that can be set for an <see cref="T:System.Runtime.Serialization.XsdDataContractExporter"/>.
             </summary>
             <remarks>
             The <see cref="T:System.Runtime.Serialization.XsdDataContractExporter"/> is used to generate XSD schemas from a type or assembly. You can also use the XsdDataContractImporter to generate .NET Framework code from a schema document.
            
             The <see cref="P:System.Runtime.Serialization.ExportOptions.KnownTypes"/> property is used by the <see cref="T:System.Runtime.Serialization.DataContractSerializer"/> to include types that can be read in an object graph.
             </remarks>
        </member>
        <member name="P:System.Runtime.Serialization.ExportOptions.DataContractSurrogate">
            <summary>
            Gets or sets a serialization surrogate provider.
            </summary>
        </member>
        <member name="P:System.Runtime.Serialization.ExportOptions.KnownTypes">
            <summary>
            Gets the collection of types that may be encountered during serialization or deserialization.
            </summary>
        </member>
        <member name="F:System.Runtime.Serialization.Globals.ScanAllMembers">
            <SecurityNote>
            Review - changes to const could affect code generation logic; any changes should be reviewed.
            </SecurityNote>
        </member>
        <member name="P:System.Runtime.Serialization.Globals.FullSRSInternalsVisibleRegex">
            <remarks>
            Pattern:<br/>
            <code>^[\\s]*System\\.Runtime\\.Serialization[\\s]*,[\\s]*PublicKey[\\s]*=[\\s]*(?i:00240000048000009400000006020000002400005253413100040000010001008d56c76f9e8649383049f383c44be0ec204181822a6c31cf5eb7ef486944d032188ea1d3920763712ccb12d75fb77e9811149e6148e5d32fbaab37611c1878ddc19e20ef135d0cb2cff2bfec3d115810c3d9069638fe4be215dbf795861920e5ab6f7db2e2ceef136ac23d5dd2bf031700aec232f6c6b1c785b4305c123b37ab)[\\s]*$</code><br/>
            Explanation:<br/>
            <code>
            ○ Match if at the beginning of the string.<br/>
            ○ Match a whitespace character atomically any number of times.<br/>
            ○ Match the string "System.Runtime.Serialization".<br/>
            ○ Match a whitespace character atomically any number of times.<br/>
            ○ Match ','.<br/>
            ○ Match a whitespace character atomically any number of times.<br/>
            ○ Match the string "PublicKey".<br/>
            ○ Match a whitespace character atomically any number of times.<br/>
            ○ Match '='.<br/>
            ○ Match a whitespace character atomically any number of times.<br/>
            ○ Match the string "00240000048000009400000006020000002400005253413100040000010001008".<br/>
            ○ Match a character in the set [Dd].<br/>
            ○ Match the string "56".<br/>
            ○ Match a character in the set [Cc].<br/>
            ○ Match the string "76".<br/>
            ○ Match a character in the set [Ff].<br/>
            ○ Match '9'.<br/>
            ○ Match a character in the set [Ee].<br/>
            ○ Match the string "8649383049".<br/>
            ○ Match a character in the set [Ff].<br/>
            ○ Match the string "383".<br/>
            ○ Match a character in the set [Cc].<br/>
            ○ Match the string "44".<br/>
            ○ Match a character in the set [Bb].<br/>
            ○ Match a character in the set [Ee].<br/>
            ○ Match '0'.<br/>
            ○ Match a character in the set [Ee].<br/>
            ○ Match a character in the set [Cc].<br/>
            ○ Match the string "204181822".<br/>
            ○ Match a character in the set [Aa].<br/>
            ○ Match '6'.<br/>
            ○ Match a character in the set [Cc].<br/>
            ○ Match the string "31".<br/>
            ○ Match a character in the set [Cc].<br/>
            ○ Match a character in the set [Ff].<br/>
            ○ Match '5'.<br/>
            ○ Match a character in the set [Ee].<br/>
            ○ Match a character in the set [Bb].<br/>
            ○ Match '7'.<br/>
            ○ Match a character in the set [Ee].<br/>
            ○ Match a character in the set [Ff].<br/>
            ○ Match the string "486944".<br/>
            ○ Match a character in the set [Dd].<br/>
            ○ Match the string "032188".<br/>
            ○ Match a character in the set [Ee].<br/>
            ○ Match a character in the set [Aa].<br/>
            ○ Match '1'.<br/>
            ○ Match a character in the set [Dd].<br/>
            ○ Match the string "3920763712".<br/>
            ○ Match a character in the set [Cc] exactly 2 times.<br/>
            ○ Match a character in the set [Bb].<br/>
            ○ Match the string "12".<br/>
            ○ Match a character in the set [Dd].<br/>
            ○ Match the string "75".<br/>
            ○ Match a character in the set [Ff].<br/>
            ○ Match a character in the set [Bb].<br/>
            ○ Match the string "77".<br/>
            ○ Match a character in the set [Ee].<br/>
            ○ Match the string "9811149".<br/>
            ○ Match a character in the set [Ee].<br/>
            ○ Match the string "6148".<br/>
            ○ Match a character in the set [Ee].<br/>
            ○ Match '5'.<br/>
            ○ Match a character in the set [Dd].<br/>
            ○ Match the string "32".<br/>
            ○ Match a character in the set [Ff].<br/>
            ○ Match a character in the set [Bb].<br/>
            ○ Match a character in the set [Aa] exactly 2 times.<br/>
            ○ Match a character in the set [Bb].<br/>
            ○ Match the string "37611".<br/>
            ○ Match a character in the set [Cc].<br/>
            ○ Match the string "1878".<br/>
            ○ Match a character in the set [Dd] exactly 2 times.<br/>
            ○ Match a character in the set [Cc].<br/>
            ○ Match the string "19".<br/>
            ○ Match a character in the set [Ee].<br/>
            ○ Match the string "20".<br/>
            ○ Match a character in the set [Ee].<br/>
            ○ Match a character in the set [Ff].<br/>
            ○ Match the string "135".<br/>
            ○ Match a character in the set [Dd].<br/>
            ○ Match '0'.<br/>
            ○ Match a character in the set [Cc].<br/>
            ○ Match a character in the set [Bb].<br/>
            ○ Match '2'.<br/>
            ○ Match a character in the set [Cc].<br/>
            ○ Match a character in the set [Ff] exactly 2 times.<br/>
            ○ Match '2'.<br/>
            ○ Match a character in the set [Bb].<br/>
            ○ Match a character in the set [Ff].<br/>
            ○ Match a character in the set [Ee].<br/>
            ○ Match a character in the set [Cc].<br/>
            ○ Match '3'.<br/>
            ○ Match a character in the set [Dd].<br/>
            ○ Match the string "115810".<br/>
            ○ Match a character in the set [Cc].<br/>
            ○ Match '3'.<br/>
            ○ Match a character in the set [Dd].<br/>
            ○ Match the string "9069638".<br/>
            ○ Match a character in the set [Ff].<br/>
            ○ Match a character in the set [Ee].<br/>
            ○ Match '4'.<br/>
            ○ Match a character in the set [Bb].<br/>
            ○ Match a character in the set [Ee].<br/>
            ○ Match the string "215".<br/>
            ○ Match a character in the set [Dd].<br/>
            ○ Match a character in the set [Bb].<br/>
            ○ Match a character in the set [Ff].<br/>
            ○ Match the string "795861920".<br/>
            ○ Match a character in the set [Ee].<br/>
            ○ Match '5'.<br/>
            ○ Match a character in the set [Aa].<br/>
            ○ Match a character in the set [Bb].<br/>
            ○ Match '6'.<br/>
            ○ Match a character in the set [Ff].<br/>
            ○ Match '7'.<br/>
            ○ Match a character in the set [Dd].<br/>
            ○ Match a character in the set [Bb].<br/>
            ○ Match '2'.<br/>
            ○ Match a character in the set [Ee].<br/>
            ○ Match '2'.<br/>
            ○ Match a character in the set [Cc].<br/>
            ○ Match a character in the set [Ee] exactly 2 times.<br/>
            ○ Match a character in the set [Ff].<br/>
            ○ Match the string "136".<br/>
            ○ Match a character in the set [Aa].<br/>
            ○ Match a character in the set [Cc].<br/>
            ○ Match the string "23".<br/>
            ○ Match a character in the set [Dd].<br/>
            ○ Match '5'.<br/>
            ○ Match a character in the set [Dd] exactly 2 times.<br/>
            ○ Match '2'.<br/>
            ○ Match a character in the set [Bb].<br/>
            ○ Match a character in the set [Ff].<br/>
            ○ Match the string "031700".<br/>
            ○ Match a character in the set [Aa].<br/>
            ○ Match a character in the set [Ee].<br/>
            ○ Match a character in the set [Cc].<br/>
            ○ Match the string "232".<br/>
            ○ Match a character in the set [Ff].<br/>
            ○ Match '6'.<br/>
            ○ Match a character in the set [Cc].<br/>
            ○ Match '6'.<br/>
            ○ Match a character in the set [Bb].<br/>
            ○ Match '1'.<br/>
            ○ Match a character in the set [Cc].<br/>
            ○ Match the string "785".<br/>
            ○ Match a character in the set [Bb].<br/>
            ○ Match the string "4305".<br/>
            ○ Match a character in the set [Cc].<br/>
            ○ Match the string "123".<br/>
            ○ Match a character in the set [Bb].<br/>
            ○ Match the string "37".<br/>
            ○ Match a character in the set [Aa].<br/>
            ○ Match a character in the set [Bb].<br/>
            ○ Match a whitespace character greedily any number of times.<br/>
            ○ Match if at the end of the string or if before an ending newline.<br/>
            </code>
            </remarks>
        </member>
        <member name="T:System.Runtime.Serialization.MemoryStreamAdapter">
            <summary>
            Members on this type correspond to the fields in MemoryStream's hierarchy on NetFX.
            </summary>
        </member>
        <member name="T:System.Runtime.Serialization.XmlFormatReaderGenerator.CriticalHelper">
            <SecurityNote>
            Review - handles all aspects of IL generation including initializing the DynamicMethod.
                     changes to how IL generated could affect how data is deserialized and what gets access to data,
                     therefore we mark it for review so that changes to generation logic are reviewed.
            </SecurityNote>
        </member>
        <member name="M:System.Runtime.Serialization.XmlFormatReaderGenerator.UnsafeGetUninitializedObject(System.Int32)">
            <SecurityNote>
            Critical - Elevates by calling GetUninitializedObject which has a LinkDemand
            Safe - marked as such so that it's callable from transparent generated IL. Takes id as parameter which
                   is guaranteed to be in internal serialization cache.
            </SecurityNote>
        </member>
        <member name="T:System.Runtime.Serialization.XmlFormatWriterGenerator.CriticalHelper">
            <SecurityNote>
            Review - handles all aspects of IL generation including initializing the DynamicMethod.
                     changes to how IL generated could affect how data is serialized and what gets access to data,
                     therefore we mark it for review so that changes to generation logic are reviewed.
            </SecurityNote>
        </member>
        <member name="T:System.Runtime.Serialization.XsdDataContractExporter">
             <summary>
             Allows the transformation of a set of .NET types that are used in data contracts into an XML schema file (.xsd).
             </summary>
             <remarks>
             Use the <see cref="T:System.Runtime.Serialization.XsdDataContractExporter"/> class when you have created a Web service that incorporates data represented by
             runtime types and when you need to export XML schemas for each type to be consumed by other Web services.
             That is, <see cref="T:System.Runtime.Serialization.XsdDataContractExporter"/> transforms a set of runtime types into XML schemas. The schemas can then be exposed
             through a Web Services Description Language (WSDL) document for use by others who need to interoperate with your service.
            
             Conversely, if you are creating a Web service that must interoperate with an existing Web service, use the XsdDataContractImporter
             to transform XML schemas and create the runtime types that represent the data in a selected programming language.
            
             The <see cref="T:System.Runtime.Serialization.XsdDataContractExporter"/> generates an <see cref="T:System.Xml.Schema.XmlSchemaSet"/> object that contains the collection of schemas.
             Access the set of schemas through the <see cref="P:System.Runtime.Serialization.XsdDataContractExporter.Schemas"/> property.
             </remarks>
        </member>
        <member name="M:System.Runtime.Serialization.XsdDataContractExporter.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:System.Runtime.Serialization.XsdDataContractExporter"/> class.
            </summary>
        </member>
        <member name="M:System.Runtime.Serialization.XsdDataContractExporter.#ctor(System.Xml.Schema.XmlSchemaSet)">
            <summary>
            Initializes a new instance of the <see cref="T:System.Runtime.Serialization.XsdDataContractExporter"/> class with the specified set of schemas.
            </summary>
            <param name="schemas">An <see cref="T:System.Xml.Schema.XmlSchemaSet"/> that contains the schemas to be exported.</param>
        </member>
        <member name="P:System.Runtime.Serialization.XsdDataContractExporter.Options">
            <summary>
            Gets or sets an <see cref="T:System.Runtime.Serialization.ExportOptions"/> that contains options that can be set for the export operation.
            </summary>
        </member>
        <member name="P:System.Runtime.Serialization.XsdDataContractExporter.Schemas">
            <summary>
            Gets the collection of exported XML schemas.
            </summary>
        </member>
        <member name="M:System.Runtime.Serialization.XsdDataContractExporter.Export(System.Collections.Generic.ICollection{System.Reflection.Assembly})">
            <summary>
            Transforms the types contained in the specified collection of assemblies.
            </summary>
            <param name="assemblies">A <see cref="T:System.Collections.Generic.ICollection`1"/> (of <see cref="T:System.Reflection.Assembly"/>) that contains the types to export.</param>
        </member>
        <member name="M:System.Runtime.Serialization.XsdDataContractExporter.Export(System.Collections.Generic.ICollection{System.Type})">
            <summary>
            Transforms the types contained in the <see cref="T:System.Collections.Generic.ICollection`1"/> passed to this method.
            </summary>
            <param name="types">A <see cref="T:System.Collections.Generic.ICollection`1"/> (of <see cref="T:System.Type"/>) that contains the types to export.</param>
        </member>
        <member name="M:System.Runtime.Serialization.XsdDataContractExporter.Export(System.Type)">
            <summary>
            Transforms the specified .NET Framework type into an XML schema definition language (XSD) schema.
            </summary>
            <param name="type">The <see cref="T:System.Type"/> to transform into an XML schema.</param>
        </member>
        <member name="M:System.Runtime.Serialization.XsdDataContractExporter.GetSchemaTypeName(System.Type)">
            <summary>
            Returns the contract name and contract namespace for the <see cref="T:System.Type"/>.
            </summary>
            <param name="type">The <see cref="T:System.Type"/> that was exported.</param>
            <returns>An <see cref="T:System.Xml.XmlQualifiedName"/> that represents the contract name of the type and its namespace.</returns>
        </member>
        <member name="M:System.Runtime.Serialization.XsdDataContractExporter.GetSchemaType(System.Type)">
            <summary>
            Returns the XML schema type for the specified type.
            </summary>
            <param name="type">The type to return a schema for.</param>
            <returns>An <see cref="T:System.Xml.Schema.XmlSchemaType"/> that contains the XML schema.</returns>
        </member>
        <member name="M:System.Runtime.Serialization.XsdDataContractExporter.GetRootElementName(System.Type)">
            <summary>
            Returns the top-level name and namespace for the <see cref="T:System.Type"/>.
            </summary>
            <param name="type">The <see cref="T:System.Type"/> to query.</param>
            <returns>The <see cref="T:System.Xml.XmlQualifiedName"/> that represents the top-level name and namespace for this Type, which is written to the stream when writing this object.</returns>
        </member>
        <member name="M:System.Runtime.Serialization.XsdDataContractExporter.CanExport(System.Collections.Generic.ICollection{System.Reflection.Assembly})">
            <summary>
            Gets a value that indicates whether the set of runtime types contained in a set of assemblies can be exported.
            </summary>
            <param name="assemblies">A <see cref="T:System.Collections.Generic.ICollection`1"/> of <see cref="T:System.Reflection.Assembly"/> that contains the assemblies with the types to export.</param>
            <returns>true if the types can be exported; otherwise, false.</returns>
        </member>
        <member name="M:System.Runtime.Serialization.XsdDataContractExporter.CanExport(System.Collections.Generic.ICollection{System.Type})">
            <summary>
            Gets a value that indicates whether the set of runtime types contained in a <see cref="T:System.Collections.Generic.ICollection`1"/> can be exported.
            </summary>
            <param name="types">A <see cref="T:System.Collections.Generic.ICollection`1"/> that contains the specified types to export.</param>
            <returns>true if the types can be exported; otherwise, false.</returns>
        </member>
        <member name="M:System.Runtime.Serialization.XsdDataContractExporter.CanExport(System.Type)">
            <summary>
            Gets a value that indicates whether the specified runtime type can be exported.
            </summary>
            <param name="type">The <see cref="T:System.Type"/> to export.</param>
            <returns>true if the type can be exported; otherwise, false.</returns>
        </member>
        <member name="T:System.Runtime.Serialization.Json.DataContractJsonSerializerSettings">
            <summary>
            Dummy documentation
            </summary>
        </member>
        <member name="P:System.Runtime.Serialization.Json.DataContractJsonSerializerSettings.RootName">
            <summary>
            Gets or sets Dummy documentation
            </summary>
        </member>
        <member name="P:System.Runtime.Serialization.Json.DataContractJsonSerializerSettings.KnownTypes">
            <summary>
            Gets or sets Dummy documentation
            </summary>
        </member>
        <member name="P:System.Runtime.Serialization.Json.DataContractJsonSerializerSettings.MaxItemsInObjectGraph">
            <summary>
            Gets or sets Dummy documentation
            </summary>
        </member>
        <member name="P:System.Runtime.Serialization.Json.DataContractJsonSerializerSettings.IgnoreExtensionDataObject">
            <summary>
            Gets or sets a value indicating whether Dummy documentation
            </summary>
        </member>
        <member name="P:System.Runtime.Serialization.Json.DataContractJsonSerializerSettings.EmitTypeInformation">
            <summary>
            Gets or sets Dummy documentation
            </summary>
        </member>
        <member name="P:System.Runtime.Serialization.Json.DataContractJsonSerializerSettings.DateTimeFormat">
            <summary>
            Gets or sets Dummy documentation
            </summary>
        </member>
        <member name="P:System.Runtime.Serialization.Json.DataContractJsonSerializerSettings.SerializeReadOnlyTypes">
            <summary>
            Gets or sets a value indicating whether Dummy documentation
            </summary>
        </member>
        <member name="P:System.Runtime.Serialization.Json.DataContractJsonSerializerSettings.UseSimpleDictionaryFormat">
            <summary>
            Gets or sets a value indicating whether Dummy documentation
            </summary>
        </member>
        <member name="T:System.Runtime.Serialization.DateTimeFormat">
            <summary>
            This class is used to customize the way DateTime is
            serialized or deserialized by <see cref="T:System.Runtime.Serialization.Json.DataContractJsonSerializer"/>
            </summary>
        </member>
        <member name="M:System.Runtime.Serialization.DateTimeFormat.#ctor(System.String)">
            <summary>
            Initializes a new <see cref="T:System.Runtime.Serialization.DateTimeFormat"/> with the specified
            formatString and DateTimeFormatInfo.CurrentInfo as the
            formatProvider.
            </summary>
            <param name="formatString">Specifies the formatString to be used.</param>
        </member>
        <member name="M:System.Runtime.Serialization.DateTimeFormat.#ctor(System.String,System.IFormatProvider)">
            <summary>
            Initializes a new <see cref="T:System.Runtime.Serialization.DateTimeFormat"/> with the specified
            formatString and formatProvider.
            </summary>
            <param name="formatString">Specifies the formatString to be used.</param>
            <param name="formatProvider">Specifies the formatProvider to be used.</param>
        </member>
        <member name="P:System.Runtime.Serialization.DateTimeFormat.FormatString">
            <summary>
            Gets the FormatString set on this instance.
            </summary>
        </member>
        <member name="P:System.Runtime.Serialization.DateTimeFormat.FormatProvider">
            <summary>
            Gets the FormatProvider set on this instance.
            </summary>
        </member>
        <member name="P:System.Runtime.Serialization.DateTimeFormat.DateTimeStyles">
            <summary>
            Gets or sets the <see cref="P:System.Runtime.Serialization.DateTimeFormat.DateTimeStyles"/> on this instance.
            </summary>
        </member>
        <member name="T:System.Runtime.Serialization.EmitTypeInformation">
            <summary>
            Dummy documentation
            </summary>
        </member>
        <member name="F:System.Runtime.Serialization.EmitTypeInformation.AsNeeded">
            <summary>
            Dummy documentation
            </summary>
        </member>
        <member name="F:System.Runtime.Serialization.EmitTypeInformation.Always">
            <summary>
            Dummy documentation
            </summary>
        </member>
        <member name="F:System.Runtime.Serialization.EmitTypeInformation.Never">
            <summary>
            Dummy documentation
            </summary>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.FullSRSInternalsVisibleRegex_0">
            <summary>Custom <see cref="T:System.Text.RegularExpressions.Regex"/>-derived type for the FullSRSInternalsVisibleRegex method.</summary>
        </member>
        <member name="F:System.Text.RegularExpressions.Generated.FullSRSInternalsVisibleRegex_0.Instance">
            <summary>Cached, thread-safe singleton instance.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.FullSRSInternalsVisibleRegex_0.#ctor">
            <summary>Initializes the instance.</summary>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.FullSRSInternalsVisibleRegex_0.RunnerFactory">
            <summary>Provides a factory for creating <see cref="T:System.Text.RegularExpressions.RegexRunner"/> instances to be used by methods on <see cref="T:System.Text.RegularExpressions.Regex"/>.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.FullSRSInternalsVisibleRegex_0.RunnerFactory.CreateInstance">
            <summary>Creates an instance of a <see cref="T:System.Text.RegularExpressions.RegexRunner"/> used by methods on <see cref="T:System.Text.RegularExpressions.Regex"/>.</summary>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.FullSRSInternalsVisibleRegex_0.RunnerFactory.Runner">
            <summary>Provides the runner that contains the custom logic implementing the specified regular expression.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.FullSRSInternalsVisibleRegex_0.RunnerFactory.Runner.Scan(System.ReadOnlySpan{System.Char})">
            <summary>Scan the <paramref name="inputSpan"/> starting from base.runtextstart for the next match.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.FullSRSInternalsVisibleRegex_0.RunnerFactory.Runner.TryFindNextPossibleStartingPosition(System.ReadOnlySpan{System.Char})">
            <summary>Search <paramref name="inputSpan"/> starting from base.runtextpos for the next location a match could possibly start.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
            <returns>true if a possible match was found; false if no more matches are possible.</returns>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.FullSRSInternalsVisibleRegex_0.RunnerFactory.Runner.TryMatchAtCurrentPosition(System.ReadOnlySpan{System.Char})">
            <summary>Determine whether <paramref name="inputSpan"/> at base.runtextpos is a match for the regular expression.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
            <returns>true if the regular expression matches at the current position; otherwise, false.</returns>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.Utilities">
            <summary>Helper methods used by generated <see cref="T:System.Text.RegularExpressions.Regex"/>-derived implementations.</summary>
        </member>
        <member name="F:System.Text.RegularExpressions.Generated.Utilities.s_defaultTimeout">
            <summary>Default timeout value set in <see cref="T:System.AppContext"/>, or <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout"/> if none was set.</summary>
        </member>
        <member name="F:System.Text.RegularExpressions.Generated.Utilities.s_hasTimeout">
            <summary>Whether <see cref="F:System.Text.RegularExpressions.Generated.Utilities.s_defaultTimeout"/> is non-infinite.</summary>
        </member>
        <member name="P:System.SR.ArrayExceededSize">
            <summary>Array length '{0}' provided by the get-only collection of type '{1}' is less than the number of array elements found in the input stream.  Consider increasing the length of the array.</summary>
        </member>
        <member name="P:System.SR.ArrayExceededSizeAttribute">
            <summary>Array length '{0}' provided by Size attribute is not equal to the number of array elements '{1}' from namespace '{2}' found.</summary>
        </member>
        <member name="P:System.SR.ArrayTypeIsNotSupported_GeneratingCode">
            <summary>An internal error has occurred. '{0}[]' is not supported when generating code for serialization.</summary>
        </member>
        <member name="P:System.SR.CannotDeserializeRefAtTopLevel">
            <summary>Cannot deserialize since root element references unrecognized object with id '{0}'.</summary>
        </member>
        <member name="P:System.SR.CannotLoadMemberType">
            <summary>Cannot load member type '{0}'.</summary>
        </member>
        <member name="P:System.SR.CannotSerializeObjectWithCycles">
            <summary>Object graph for type '{0}' contains cycles and cannot be serialized if references are not tracked. Consider using the DataContractAttribute with the IsReference property set to true.</summary>
        </member>
        <member name="P:System.SR.CanOnlyStoreIntoArgOrLocGot0">
            <summary>An internal error has occurred. Data can only be stored into ArgBuilder or LocalBuilder. Got: {0}.</summary>
        </member>
        <member name="P:System.SR.CharIsInvalidPrimitive">
            <summary>An internal error has occurred. Char is not a valid schema primitive and should be treated as int in DataContract.</summary>
        </member>
        <member name="P:System.SR.CallbackMustReturnVoid">
            <summary>Serialization Callback '{1}' in type '{0}' must return void.</summary>
        </member>
        <member name="P:System.SR.CallbackParameterInvalid">
            <summary>Serialization Callback '{1}' in type '{0}' must have a single parameter of type '{2}'.</summary>
        </member>
        <member name="P:System.SR.CallbacksCannotBeVirtualMethods">
            <summary>Virtual Method '{0}' of type '{1}' cannot be marked with '{2}' attribute.</summary>
        </member>
        <member name="P:System.SR.CollectionMustHaveAddMethod">
            <summary>Collection type '{0}' does not have a valid Add method.</summary>
        </member>
        <member name="P:System.SR.CollectionMustHaveGetEnumeratorMethod">
            <summary>Collection type '{0}' does not have a valid GetEnumerator method.</summary>
        </member>
        <member name="P:System.SR.CollectionMustHaveItemType">
            <summary>Collection type '{0}' must have a non-null item type.</summary>
        </member>
        <member name="P:System.SR.CollectionTypeCannotBeBuiltIn">
            <summary>{0} is a built-in type and cannot be a collection.</summary>
        </member>
        <member name="P:System.SR.CollectionTypeCannotHaveDataContract">
            <summary>{0} has DataContractAttribute attribute.</summary>
        </member>
        <member name="P:System.SR.CollectionTypeDoesNotHaveAddMethod">
            <summary>{0} does not have a valid Add method with parameter of type '{1}'.</summary>
        </member>
        <member name="P:System.SR.CollectionTypeDoesNotHaveDefaultCtor">
            <summary>{0} does not have a default constructor.</summary>
        </member>
        <member name="P:System.SR.CollectionTypeHasMultipleDefinitionsOfInterface">
            <summary>{0} has multiple definitions of interface '{1}'.</summary>
        </member>
        <member name="P:System.SR.CollectionTypeIsNotIEnumerable">
            <summary>{0} does not implement IEnumerable interface.</summary>
        </member>
        <member name="P:System.SR.DataContractCacheOverflow">
            <summary>An internal error has occurred. DataContract cache overflow.</summary>
        </member>
        <member name="P:System.SR.DataContractNamespaceAlreadySet">
            <summary>ContractNamespaceAttribute attribute maps CLR namespace '{2}' to multiple data contract namespaces '{0}' and '{1}'. You can map a CLR namespace to only one data contract namespace.</summary>
        </member>
        <member name="P:System.SR.DataContractNamespaceIsNotValid">
            <summary>DataContract namespace '{0}' is not a valid URI.</summary>
        </member>
        <member name="P:System.SR.DataContractNamespaceReserved">
            <summary>DataContract namespace '{0}' cannot be specified since it is reserved.</summary>
        </member>
        <member name="P:System.SR.DataMemberOnEnumField">
            <summary>Member '{0}.{1}' has DataMemberAttribute attribute. Use EnumMemberAttribute attribute instead.</summary>
        </member>
        <member name="P:System.SR.DcTypeNotFoundOnDeserialize">
            <summary>Element '{2}:{3}' contains data of the '{0}:{1}' data contract. The deserializer has no knowledge of any type that maps to this contract. Add the type corresponding to '{1}' to the list of known types - for example, by using the KnownTypeAttribute attribut ...</summary>
        </member>
        <member name="P:System.SR.DcTypeNotFoundOnSerialize">
            <summary>Type '{0}' with data contract name '{1}:{2}' is not expected. Add any types not known statically to the list of known types - for example, by using the KnownTypeAttribute attribute or by adding them to the list of known types passed to DataContractSerializ ...</summary>
        </member>
        <member name="P:System.SR.DcTypeNotResolvedOnDeserialize">
            <summary>Element '{2}:{3}' contains data from a type that maps to the name '{0}:{1}'. The deserializer has no knowledge of any type that maps to this name. Consider changing the implementation of the ResolveName method on your DataContractResolver to return a non-n ...</summary>
        </member>
        <member name="P:System.SR.DeserializedObjectWithIdNotFound">
            <summary>Deserialized object with reference id '{0}' not found in stream.</summary>
        </member>
        <member name="P:System.SR.DupContractInKnownTypes">
            <summary>Type '{0}' cannot be added to list of known types since another type '{1}' with the same data contract name '{2}:{3}' is already present.</summary>
        </member>
        <member name="P:System.SR.DupKeyValueName">
            <summary>The collection data contract type '{0}' specifies the same value '{1}' for both the KeyName and the ValueName properties. This is not allowed. Consider changing either the KeyName or the ValueName property.</summary>
        </member>
        <member name="P:System.SR.DupEnumMemberValue">
            <summary>Type '{2}' contains two members '{0}' 'and '{1}' with the same name '{3}'. Multiple members with the same name in one type are not supported. Consider changing one of the member names using EnumMemberAttribute attribute.</summary>
        </member>
        <member name="P:System.SR.DupMemberName">
            <summary>Type '{2}' contains two members '{0}' 'and '{1}' with the same data member name '{3}'. Multiple members with the same name in one type are not supported. Consider changing one of the member names using DataMemberAttribute attribute.</summary>
        </member>
        <member name="P:System.SR.DuplicateAttribute">
            <summary>Invalid Callback. Method '{3}' in type '{2}' has both '{0}' and '{1}'.</summary>
        </member>
        <member name="P:System.SR.DuplicateCallback">
            <summary>Invalid attribute. Both '{0}' and '{1}' in type '{2}' have '{3}'.</summary>
        </member>
        <member name="P:System.SR.EncounteredWithNameNamespace">
            <summary>{0}. Encountered '{1}'  with name '{2}', namespace '{3}'.</summary>
        </member>
        <member name="P:System.SR.EnumTypeCannotHaveIsReference">
            <summary>Enum type '{0}' cannot have the IsReference setting of '{1}'. Either change the setting to '{2}', or remove it completely.</summary>
        </member>
        <member name="P:System.SR.ErrorDeserializing">
            <summary>There was an error deserializing the object {0}. {1}</summary>
        </member>
        <member name="P:System.SR.ErrorInLine">
            <summary>Error in line {0} position {1}.</summary>
        </member>
        <member name="P:System.SR.ErrorIsStartObject">
            <summary>There was an error checking start element of object {0}. {1}</summary>
        </member>
        <member name="P:System.SR.ErrorSerializing">
            <summary>There was an error serializing the object {0}. {1}</summary>
        </member>
        <member name="P:System.SR.ErrorTypeInfo">
            <summary>of type {0}</summary>
        </member>
        <member name="P:System.SR.ErrorWriteEndObject">
            <summary>There was an error writing end element of object {0}. {1}</summary>
        </member>
        <member name="P:System.SR.ErrorWriteStartObject">
            <summary>There was an error writing start element of object {0}. {1}</summary>
        </member>
        <member name="P:System.SR.ExceededMaxItemsQuota">
            <summary>Maximum number of items that can be serialized or deserialized in an object graph is '{0}'.</summary>
        </member>
        <member name="P:System.SR.ExpectingElement">
            <summary>Expecting element '{1}' from namespace '{0}'.</summary>
        </member>
        <member name="P:System.SR.ExpectingElementAtDeserialize">
            <summary>Expecting state '{0}' when ReadObject is called.</summary>
        </member>
        <member name="P:System.SR.ExpectingEnd">
            <summary>Expecting End'{0}'.</summary>
        </member>
        <member name="P:System.SR.ExpectingState">
            <summary>Expecting state '{0}'.</summary>
        </member>
        <member name="P:System.SR.GenericNameBraceMismatch">
            <summary>The data contract name '{0}' for type '{1}' has a curly brace '{{' that is not matched with a closing curly brace. Curly braces have special meaning in data contract names - they are used to customize the naming of data contracts for generic types.</summary>
        </member>
        <member name="P:System.SR.GenericParameterNotValid">
            <summary>In the data contract name for type '{1}', there are curly braces with '{0}' inside, which is an invalid value. Curly braces have special meaning in data contract names - they are used to customize the naming of data contracts for generic types. Based on th ...</summary>
        </member>
        <member name="P:System.SR.InconsistentIsReference">
            <summary>The IsReference setting for type '{0}' is '{1}', but the same setting for its parent class '{2}' is '{3}'. Derived types must have the same value for IsReference as the base type. Change the setting on type '{0}' to '{3}', or on type '{2}' to '{1}', or do  ...</summary>
        </member>
        <member name="P:System.SR.IndexedPropertyCannotBeSerialized">
            <summary>Property '{1}' in type '{0}' cannot be serialized because serialization of indexed properties is not supported.</summary>
        </member>
        <member name="P:System.SR.InvalidCollectionContractItemName">
            <summary>Type '{0}' cannot have CollectionDataContractAttribute attribute ItemName set to null or empty string.</summary>
        </member>
        <member name="P:System.SR.InvalidCollectionContractKeyName">
            <summary>Type '{0}' cannot have CollectionDataContractAttribute attribute KeyName set to null or empty string.</summary>
        </member>
        <member name="P:System.SR.InvalidCollectionContractKeyNoDictionary">
            <summary>The collection data contract type '{0}' specifies '{1}' for the KeyName property. This is not allowed since the type is not IDictionary. Remove the setting for the KeyName property.</summary>
        </member>
        <member name="P:System.SR.InvalidCollectionContractName">
            <summary>Type '{0}' cannot have CollectionDataContractAttribute attribute Name set to null or empty string.</summary>
        </member>
        <member name="P:System.SR.InvalidCollectionContractNamespace">
            <summary>Type '{0}' cannot have CollectionDataContractAttribute attribute Namespace set to null.</summary>
        </member>
        <member name="P:System.SR.InvalidCollectionContractValueName">
            <summary>Type '{0}' cannot have CollectionDataContractAttribute attribute ValueName set to null or empty string.</summary>
        </member>
        <member name="P:System.SR.InvalidCollectionContractValueNoDictionary">
            <summary>The collection data contract type '{0}' specifies '{1}' for the ValueName property. This is not allowed since the type is not IDictionary. Remove the setting for the ValueName property.</summary>
        </member>
        <member name="P:System.SR.InvalidCollectionDataContract">
            <summary>Type '{0}' with CollectionDataContractAttribute attribute is an invalid collection type since it</summary>
        </member>
        <member name="P:System.SR.InvalidCollectionType">
            <summary>Type '{0}' is an invalid collection type since it</summary>
        </member>
        <member name="P:System.SR.InvalidDataContractName">
            <summary>Type '{0}' cannot have DataContractAttribute attribute Name set to null or empty string.</summary>
        </member>
        <member name="P:System.SR.InvalidDataContractNamespace">
            <summary>Type '{0}' cannot have DataContractAttribute attribute Namespace set to null.</summary>
        </member>
        <member name="P:System.SR.InvalidDataMemberName">
            <summary>Member '{0}' in type '{1}' cannot have DataMemberAttribute attribute Name set to null or empty string.</summary>
        </member>
        <member name="P:System.SR.InvalidDataNode">
            <summary>'{0}' is an invalid data node when deserializing extension data.</summary>
        </member>
        <member name="P:System.SR.InvalidEnumBaseType">
            <summary>Type '{0}' in namespace '{1}' is not a valid base type for enum '{2}' in namespace '{3}'.</summary>
        </member>
        <member name="P:System.SR.InvalidEnumMemberValue">
            <summary>'{0}' in type '{1}' cannot have EnumMemberAttribute attribute Value set to null or empty string.</summary>
        </member>
        <member name="P:System.SR.InvalidEnumValueOnRead">
            <summary>Invalid enum value '{0}' cannot be deserialized into type '{1}'. Ensure that the necessary enum values are present and are marked with EnumMemberAttribute attribute if the type has DataContractAttribute attribute.</summary>
        </member>
        <member name="P:System.SR.InvalidEnumValueOnWrite">
            <summary>Enum value '{0}' is invalid for type '{1}' and cannot be serialized. Ensure that the necessary enum values are present and are marked with EnumMemberAttribute attribute if the type has DataContractAttribute attribute.</summary>
        </member>
        <member name="P:System.SR.InvalidGetSchemaMethod">
            <summary>Type '{0}' cannot have MethodName on XmlSchemaProviderAttribute attribute set to null or empty string.</summary>
        </member>
        <member name="P:System.SR.InvalidGlobalDataContractNamespace">
            <summary>CLR namespace '{0}' cannot have ContractNamespace set to null.</summary>
        </member>
        <member name="P:System.SR.InvalidMember">
            <summary>Member '{0}.{1}' cannot be serialized since it is neither a field nor a property, and therefore cannot be marked with the DataMemberAttribute attribute. Remove the DataMemberAttribute attribute from the '{1}' member.</summary>
        </member>
        <member name="P:System.SR.InvalidNonNullReturnValueByIsAny">
            <summary>Method '{0}.{1}()' returns a non-null value. The return value must be null since IsAny</summary>
        </member>
        <member name="P:System.SR.InvalidPrimitiveType_Serialization">
            <summary>Type '{0}' is not a valid serializable type.</summary>
        </member>
        <member name="P:System.SR.InvalidReturnTypeOnGetSchemaMethod">
            <summary>Method '{0}.{1}()' returns '{2}'. The return type must be compatible with '{3}'.</summary>
        </member>
        <member name="P:System.SR.InvalidSizeDefinition">
            <summary>Invalid Size '{0}'. Must be non-negative integer.</summary>
        </member>
        <member name="P:System.SR.InvalidXmlDataContractName">
            <summary>XML data contract Name for type '{0}' cannot be set to null or empty string.</summary>
        </member>
        <member name="P:System.SR.InvalidXsIdDefinition">
            <summary>Invalid Id '{0}'. Must not be null or empty.</summary>
        </member>
        <member name="P:System.SR.InvalidXsRefDefinition">
            <summary>Invalid Ref '{0}'. Must not be null or empty.</summary>
        </member>
        <member name="P:System.SR.IsAnyCannotBeNull">
            <summary>A null value cannot be serialized at the top level for IXmlSerializable root type '{0}' since its IsAny setting is 'true'. This type must write all its contents including the root element. Verify that the IXmlSerializable implementation is correct.</summary>
        </member>
        <member name="P:System.SR.IsAnyCannotBeSerializedAsDerivedType">
            <summary>An object of type '{0}' cannot be serialized at the top level for IXmlSerializable root type '{1}' since its IsAny setting is 'true'. This type must write all its contents including the root element. Verify that the IXmlSerializable implementation is corre ...</summary>
        </member>
        <member name="P:System.SR.IsAnyCannotHaveXmlRoot">
            <summary>Type '{0}' cannot specify an XmlRootAttribute attribute because its IsAny setting is 'true'. This type must write all its contents including the root element. Verify that the IXmlSerializable implementation is correct.</summary>
        </member>
        <member name="P:System.SR.IsNotAssignableFrom">
            <summary>An internal error has occurred. '{0}' is not assignable from '{1}' - error generating code for serialization.</summary>
        </member>
        <member name="P:System.SR.IsRequiredDataMemberOnIsReferenceDataContractType">
            <summary>'{0}.{1}' has the IsRequired setting of '{2}. However, '{0}' has the IsReference setting of '{2}', because either it is set explicitly, or it is derived from a base class. Set IsRequired on '{0}.{1}' to false, or disable IsReference on '{0}'.</summary>
        </member>
        <member name="P:System.SR.IXmlSerializableCannotHaveCollectionDataContract">
            <summary>Type '{0}' cannot be IXmlSerializable and have CollectionDataContractAttribute attribute.</summary>
        </member>
        <member name="P:System.SR.IXmlSerializableCannotHaveDataContract">
            <summary>Type '{0}' cannot be IXmlSerializable and have DataContractAttribute attribute.</summary>
        </member>
        <member name="P:System.SR.IXmlSerializableIllegalOperation">
            <summary>This method cannot be called from IXmlSerializable implementations.</summary>
        </member>
        <member name="P:System.SR.IXmlSerializableMissingEndElements">
            <summary>IXmlSerializable.WriteXml method of type '{0}' did not close all open tags. Verify that the IXmlSerializable implementation is correct.</summary>
        </member>
        <member name="P:System.SR.IXmlSerializableMustHaveDefaultConstructor">
            <summary>IXmlSerializable Type '{0}' must have default constructor.</summary>
        </member>
        <member name="P:System.SR.IXmlSerializableWritePastSubTree">
            <summary>IXmlSerializable.WriteXml method of type '{0}' attempted to close too many tags.  Verify that the IXmlSerializable implementation is correct.</summary>
        </member>
        <member name="P:System.SR.KnownTypeAttributeEmptyString">
            <summary>Method name specified by KnownTypeAttribute attribute on type '{0}' cannot be the empty string.</summary>
        </member>
        <member name="P:System.SR.KnownTypeAttributeUnknownMethod">
            <summary>KnownTypeAttribute attribute on type '{1}' specifies a method named '{0}' to provide known types. Static method '{0}()' was not found on this type. Ensure that the method exists and is marked as static.</summary>
        </member>
        <member name="P:System.SR.KnownTypeAttributeReturnType">
            <summary>KnownTypeAttribute attribute on type '{0}' specifies a method named '{1}' to provide known types. The return type of this method is invalid because it is not assignable to IEnumerable&lt;Type&gt;. Ensure that the method exists and has a valid signature.</summary>
        </member>
        <member name="P:System.SR.KnownTypeAttributeOneScheme">
            <summary>Type '{0}': If a KnownTypeAttribute attribute specifies a method it must be the only KnownTypeAttribute attribute on that type.</summary>
        </member>
        <member name="P:System.SR.KnownTypeAttributeValidMethodTypes">
            <summary>Method specified by KnownTypeAttribute attribute on type '{0}' does not expose valid types.</summary>
        </member>
        <member name="P:System.SR.KnownTypeAttributeNoData">
            <summary>KnownTypeAttribute attribute on type '{0}' contains no data.</summary>
        </member>
        <member name="P:System.SR.KnownTypeAttributeMethodNull">
            <summary>Method specified by KnownTypeAttribute attribute on type '{0}' returned null.</summary>
        </member>
        <member name="P:System.SR.MaxArrayLengthExceeded">
            <summary>The maximum array length ({0}) has been exceeded while reading XML data for array of type '{1}'.</summary>
        </member>
        <member name="P:System.SR.MissingGetSchemaMethod">
            <summary>Type '{0}' does not have a static method '{1}' that takes a parameter of type 'System.Xml.Schema.XmlSchemaSet' as specified by the XmlSchemaProviderAttribute attribute.</summary>
        </member>
        <member name="P:System.SR.MultipleIdDefinition">
            <summary>Invalid XML encountered. The same Id value '{0}' is defined more than once. Multiple objects cannot be deserialized using the same Id.</summary>
        </member>
        <member name="P:System.SR.NoConversionPossibleTo">
            <summary>An internal error has occurred. No conversion is possible to '{0}' - error generating code for serialization.</summary>
        </member>
        <member name="P:System.SR.NoGetMethodForProperty">
            <summary>No get method for property '{1}' in type '{0}'.</summary>
        </member>
        <member name="P:System.SR.NoSetMethodForProperty">
            <summary>No set method for property '{1}' in type '{0}'.</summary>
        </member>
        <member name="P:System.SR.NullKnownType">
            <summary>One of the known types provided to the serializer via '{0}' argument was invalid because it was null. All known types specified must be non-null values.</summary>
        </member>
        <member name="P:System.SR.NullValueReturnedForGetOnlyCollection">
            <summary>The get-only collection of type '{0}' returned a null value.  The input stream contains collection items which cannot be added if the instance is null.  Consider initializing the collection either in the constructor of the object or in the getter.</summary>
        </member>
        <member name="P:System.SR.ObjectTableOverflow">
            <summary>An internal error has occurred. Object table overflow. This could be caused by serializing or deserializing extremely large object graphs.</summary>
        </member>
        <member name="P:System.SR.ParameterCountMismatch">
            <summary>Invalid number of parameters to call method '{0}'. Expected '{1}' parameters, but '{2}' were provided.</summary>
        </member>
        <member name="P:System.SR.PartialTrustCollectionContractAddMethodNotPublic">
            <summary>The collection data contract type '{0}' cannot be deserialized because the method '{1}' is not public. Making the method public will fix this error. Alternatively, you can make it internal, and use the InternalsVisibleToAttribute attribute on your assembly ...</summary>
        </member>
        <member name="P:System.SR.PartialTrustCollectionContractNoPublicConstructor">
            <summary>The collection data contract type '{0}' cannot be deserialized because it does not have a public parameterless constructor. Adding a public parameterless constructor will fix this error. Alternatively, you can make it internal, and use the InternalsVisible ...</summary>
        </member>
        <member name="P:System.SR.PartialTrustCollectionContractTypeNotPublic">
            <summary>The collection data contract type '{0}' cannot be deserialized because it does not have a public parameterless constructor. Adding a public parameterless constructor will fix this error. Alternatively, you can make it internal, and use the InternalsVisible ...</summary>
        </member>
        <member name="P:System.SR.PartialTrustDataContractOnSerializingNotPublic">
            <summary>The data contract type '{0}' cannot be serialized because the OnSerializing method '{1}' is not public. Making the method public will fix this error. Alternatively, you can make it internal, and use the InternalsVisibleToAttribute attribute on your assembl ...</summary>
        </member>
        <member name="P:System.SR.PartialTrustDataContractOnSerializedNotPublic">
            <summary>The data contract type '{0}' cannot be serialized because the OnSerialized method '{1}' is not public. Making the method public will fix this error. Alternatively, you can make it internal, and use the InternalsVisibleToAttribute attribute on your assembly ...</summary>
        </member>
        <member name="P:System.SR.PartialTrustDataContractOnDeserializingNotPublic">
            <summary>The data contract type '{0}' cannot be deserialized because the OnDeserializing method '{1}' is not public. Making the method public will fix this error. Alternatively, you can make it internal, and use the InternalsVisibleToAttribute attribute on your ass ...</summary>
        </member>
        <member name="P:System.SR.PartialTrustDataContractOnDeserializedNotPublic">
            <summary>The data contract type '{0}' cannot be deserialized because the OnDeserialized method '{1}' is not public. Making the method public will fix this error. Alternatively, you can make it internal, and use the InternalsVisibleToAttribute attribute on your asse ...</summary>
        </member>
        <member name="P:System.SR.PartialTrustDataContractFieldGetNotPublic">
            <summary>The data contract type '{0}' cannot be serialized because the member '{1}' is not public. Making the member public will fix this error. Alternatively, you can make it internal, and use the InternalsVisibleToAttribute attribute on your assembly in order to  ...</summary>
        </member>
        <member name="P:System.SR.PartialTrustDataContractFieldSetNotPublic">
            <summary>The data contract type '{0}' cannot be deserialized because the member '{1}' is not public. Making the member public will fix this error. Alternatively, you can make it internal, and use the InternalsVisibleToAttribute attribute on your assembly in order t ...</summary>
        </member>
        <member name="P:System.SR.PartialTrustDataContractPropertyGetNotPublic">
            <summary>The data contract type '{0}' cannot be serialized because the property '{1}' does not have a public getter. Adding a public getter will fix this error. Alternatively, you can make it internal, and use the InternalsVisibleToAttribute attribute on your assem ...</summary>
        </member>
        <member name="P:System.SR.PartialTrustDataContractPropertySetNotPublic">
            <summary>The data contract type '{0}' cannot be deserialized because the property '{1}' does not have a public setter. Adding a public setter will fix this error. Alternatively, you can make it internal, and use the InternalsVisibleToAttribute attribute on your ass ...</summary>
        </member>
        <member name="P:System.SR.PartialTrustDataContractTypeNotPublic">
            <summary>The data contract type '{0}' is not serializable because it is not public. Making the type public will fix this error. Alternatively, you can make it internal, and use the InternalsVisibleToAttribute attribute on your assembly in order to enable serializat ...</summary>
        </member>
        <member name="P:System.SR.PartialTrustNonAttributedSerializableTypeNoPublicConstructor">
            <summary>The type '{0}' cannot be deserialized because it does not have a public parameterless constructor. Alternatively, you can make it internal, and use the InternalsVisibleToAttribute attribute on your assembly in order to enable serialization of internal memb ...</summary>
        </member>
        <member name="P:System.SR.PartialTrustIXmlSerializableTypeNotPublic">
            <summary>The IXmlSerializable type '{0}' is not serializable in partial trust because it is not public. Adding a public parameterless constructor will fix this error. Alternatively, you can make it internal, and use the InternalsVisibleToAttribute attribute on your ...</summary>
        </member>
        <member name="P:System.SR.PartialTrustIXmlSerialzableNoPublicConstructor">
            <summary>The IXmlSerializable type '{0}' cannot be deserialized because it does not have a public parameterless constructor. Adding a public parameterless constructor will fix this error. Alternatively, you can make it internal, and use the InternalsVisibleToAttrib ...</summary>
        </member>
        <member name="P:System.SR.NonAttributedSerializableTypesMustHaveDefaultConstructor">
            <summary>The Type '{0}' must have a parameterless constructor.</summary>
        </member>
        <member name="P:System.SR.AttributedTypesCannotInheritFromNonAttributedSerializableTypes">
            <summary>Type '{0}' cannot inherit from a type that is not marked with DataContractAttribute or SerializableAttribute.  Consider marking the base type '{1}' with DataContractAttribute or SerializableAttribute, or removing them from the derived type.</summary>
        </member>
        <member name="P:System.SR.QuotaIsReadOnly">
            <summary>The '{0}' quota is readonly.</summary>
        </member>
        <member name="P:System.SR.QuotaCopyReadOnly">
            <summary>Cannot copy XmlDictionaryReaderQuotas. Target is readonly.</summary>
        </member>
        <member name="P:System.SR.RequiredMemberMustBeEmitted">
            <summary>Member {0} in type {1} cannot be serialized. This exception is usually caused by trying to use a null value where a null value is not allowed. The '{0}' member is set to its default value (usually null or zero). The member's EmitDefault setting is 'false', ...</summary>
        </member>
        <member name="P:System.SR.ResolveTypeReturnedFalse">
            <summary>An object of type '{0}' which derives from DataContractResolver returned false from its TryResolveType method when attempting to resolve the name for an object of type '{1}', indicating that the resolution failed. Change the TryResolveType implementation t ...</summary>
        </member>
        <member name="P:System.SR.ResolveTypeReturnedNull">
            <summary>An object of type '{0}' which derives from DataContractResolver returned a null typeName or typeNamespace but not both from its TryResolveType method when attempting to resolve the name for an object of type '{1}'. Change the TryResolveType implementation  ...</summary>
        </member>
        <member name="P:System.SR.SupportForMultidimensionalArraysNotPresent">
            <summary>Multi-dimensional arrays are not supported.</summary>
        </member>
        <member name="P:System.SR.TooManyCollectionContracts">
            <summary>Type '{0}' has more than one CollectionDataContractAttribute attribute.</summary>
        </member>
        <member name="P:System.SR.TooManyDataContracts">
            <summary>Type '{0}' has more than one DataContractAttribute attribute.</summary>
        </member>
        <member name="P:System.SR.TooManyDataMembers">
            <summary>Member '{0}.{1}' has more than one DataMemberAttribute attribute.</summary>
        </member>
        <member name="P:System.SR.TooManyEnumMembers">
            <summary>Member '{0}.{1}' has more than one EnumMemberAttribute attribute.</summary>
        </member>
        <member name="P:System.SR.TooManyIgnoreDataMemberAttributes">
            <summary>Member '{0}.{1}' has more than one IgnoreDataMemberAttribute attribute.</summary>
        </member>
        <member name="P:System.SR.TypeNotSerializable">
            <summary>Type '{0}' cannot be serialized. Consider marking it with the DataContractAttribute attribute, and marking all of its members you want serialized with the DataMemberAttribute attribute. Alternatively, you can ensure that the type is public and has a parame ...</summary>
        </member>
        <member name="P:System.SR.UnexpectedContractType">
            <summary>An internal error has occurred. Unexpected contract type '{0}' for type '{1}' encountered.</summary>
        </member>
        <member name="P:System.SR.UnexpectedElementExpectingElements">
            <summary>'{0}' '{1}' from namespace '{2}' is not expected. Expecting element '{3}'.</summary>
        </member>
        <member name="P:System.SR.UnexpectedEndOfFile">
            <summary>Unexpected end of file.</summary>
        </member>
        <member name="P:System.SR.UnknownConstantType">
            <summary>Internal Error: Unrecognized constant type {0}.</summary>
        </member>
        <member name="P:System.SR.ValueTypeCannotBeNull">
            <summary>ValueType '{0}' cannot be null.</summary>
        </member>
        <member name="P:System.SR.ValueTypeCannotHaveBaseType">
            <summary>Data contract '{0}' from namespace '{1}' is a value type and cannot have base contract '{2}' from namespace '{3}'.</summary>
        </member>
        <member name="P:System.SR.ValueTypeCannotHaveId">
            <summary>ValueType '{0}' cannot have id.</summary>
        </member>
        <member name="P:System.SR.ValueTypeCannotHaveIsReference">
            <summary>Value type '{0}' cannot have the IsReference setting of '{1}'. Either change the setting to '{2}', or remove it completely.</summary>
        </member>
        <member name="P:System.SR.ValueTypeCannotHaveRef">
            <summary>ValueType '{0}' cannot have ref to another object.</summary>
        </member>
        <member name="P:System.SR.XmlElementAttributes">
            <summary>Only Element nodes have attributes.</summary>
        </member>
        <member name="P:System.SR.XmlForObjectCannotHaveContent">
            <summary>Element {0} from namespace {1} cannot have child contents to be deserialized as an object. Please use XElement to deserialize this pattern of XML.</summary>
        </member>
        <member name="P:System.SR.XmlInvalidConversion">
            <summary>The value '{0}' cannot be parsed as the type '{1}'.</summary>
        </member>
        <member name="P:System.SR.XmlInvalidConversionWithoutValue">
            <summary>The value cannot be parsed as the type '{0}'.</summary>
        </member>
        <member name="P:System.SR.XmlStartElementExpected">
            <summary>Start element expected. Found {0}.</summary>
        </member>
        <member name="P:System.SR.XmlWriterMustBeInElement">
            <summary>WriteState '{0}' not valid. Caller must write start element before serializing in contentOnly mode.</summary>
        </member>
        <member name="P:System.SR.NonOptionalFieldMemberOnIsReferenceSerializableType">
            <summary>{0}.{1}' is not marked with OptionalFieldAttribute, thus indicating that it must be serialized. However, '{0}' derives from a class marked with DataContractAttribute and an IsReference setting of '{2}'. It is not possible to have required data members on I ...</summary>
        </member>
        <member name="P:System.SR.OffsetExceedsBufferSize">
            <summary>The specified offset exceeds the buffer size ({0} bytes).</summary>
        </member>
        <member name="P:System.SR.SizeExceedsRemainingBufferSpace">
            <summary>The specified size exceeds the remaining buffer space ({0} bytes).</summary>
        </member>
        <member name="P:System.SR.ValueMustBeInRange">
            <summary>The value of this argument must fall within the range {0} to {1}.</summary>
        </member>
        <member name="P:System.SR.XmlArrayTooSmallOutput">
            <summary>Array too small.  Must be able to hold at least {0}.</summary>
        </member>
        <member name="P:System.SR.XmlAsyncIsRunningException">
            <summary>An asynchronous operation is already in progress.</summary>
        </member>
        <member name="P:System.SR.XmlInvalidBase64Length">
            <summary>Base64 sequence length ({0}) not valid. Must be a multiple of 4.</summary>
        </member>
        <member name="P:System.SR.XmlInvalidBase64Sequence">
            <summary>The characters '{0}' at offset {1} are not a valid Base64 sequence.</summary>
        </member>
        <member name="P:System.SR.XmlInvalidBinHexLength">
            <summary>BinHex sequence length ({0}) not valid. Must be a multiple of 2.</summary>
        </member>
        <member name="P:System.SR.XmlInvalidBinHexSequence">
            <summary>The characters '{0}' at offset {1} are not a valid BinHex sequence.</summary>
        </member>
        <member name="P:System.SR.XmlInvalidHighSurrogate">
            <summary>High surrogate char '0x{0}' not valid. High surrogate chars range from 0xD800 to 0xDBFF.</summary>
        </member>
        <member name="P:System.SR.XmlInvalidLowSurrogate">
            <summary>Low surrogate char '0x{0}' not valid. Low surrogate chars range from 0xDC00 to 0xDFFF.</summary>
        </member>
        <member name="P:System.SR.XmlInvalidSurrogate">
            <summary>Surrogate char '0x{0}' not valid. Surrogate chars range from 0x10000 to 0x10FFFF.</summary>
        </member>
        <member name="P:System.SR.InvalidLocalNameEmpty">
            <summary>The empty string is not a valid local name.</summary>
        </member>
        <member name="P:System.SR.XmlArrayTooSmall">
            <summary>Array too small.</summary>
        </member>
        <member name="P:System.SR.XmlArrayTooSmallInput">
            <summary>Array too small.  Length of available data must be at least {0}.</summary>
        </member>
        <member name="P:System.SR.XmlBadBOM">
            <summary>Unrecognized Byte Order Mark.</summary>
        </member>
        <member name="P:System.SR.XmlMaxNameTableCharCountExceeded">
            <summary>The maximum nametable character count quota ({0}) has been exceeded while reading XML data. The nametable is a data structure used to store strings encountered during XML processing - long XML documents with non-repeating element names, attribute names and ...</summary>
        </member>
        <member name="P:System.SR.XmlBase64DataExpected">
            <summary>Base64 encoded data expected. Found {0}.</summary>
        </member>
        <member name="P:System.SR.XmlCDATAInvalidAtTopLevel">
            <summary>CData elements not valid at top level of an XML document.</summary>
        </member>
        <member name="P:System.SR.XmlCloseCData">
            <summary>']]&gt;' not valid in text node content.</summary>
        </member>
        <member name="P:System.SR.XmlConversionOverflow">
            <summary>The value '{0}' cannot be represented with the type '{1}'.</summary>
        </member>
        <member name="P:System.SR.XmlDeclarationRequired">
            <summary>An XML declaration with an encoding is required for all non UTF-8 documents.</summary>
        </member>
        <member name="P:System.SR.XmlDeclMissingVersion">
            <summary>Version not found in XML declaration.</summary>
        </member>
        <member name="P:System.SR.XmlDeclMissing">
            <summary>An XML declaration is required for all non UTF-8 documents.</summary>
        </member>
        <member name="P:System.SR.XmlDeclNotFirst">
            <summary>No characters can appear before the XML declaration.</summary>
        </member>
        <member name="P:System.SR.XmlDictionaryStringIDRange">
            <summary>XmlDictionaryString IDs must be in the range from {0} to {1}.</summary>
        </member>
        <member name="P:System.SR.XmlDictionaryStringIDUndefinedSession">
            <summary>XmlDictionaryString ID {0} not defined in the XmlBinaryReaderSession.</summary>
        </member>
        <member name="P:System.SR.XmlDictionaryStringIDUndefinedStatic">
            <summary>XmlDictionaryString ID {0} not defined in the static dictionary.</summary>
        </member>
        <member name="P:System.SR.XmlDuplicateAttribute">
            <summary>Duplicate attribute found. Both '{0}' and '{1}' are from the namespace '{2}'.</summary>
        </member>
        <member name="P:System.SR.XmlEmptyNamespaceRequiresNullPrefix">
            <summary>The empty namespace requires a null or empty prefix.</summary>
        </member>
        <member name="P:System.SR.XmlEncodingMismatch">
            <summary>The encoding in the declaration '{0}' does not match the encoding of the document '{1}'.</summary>
        </member>
        <member name="P:System.SR.XmlEncodingNotSupported">
            <summary>XML encoding not supported.</summary>
        </member>
        <member name="P:System.SR.XmlEndElementExpected">
            <summary>End element '{0}' from namespace '{1}' expected. Found {2}.</summary>
        </member>
        <member name="P:System.SR.XmlEndElementNoOpenNodes">
            <summary>No corresponding start element is open.</summary>
        </member>
        <member name="P:System.SR.XmlExpectedEncoding">
            <summary>The expected encoding '{0}' does not match the actual encoding '{1}'.</summary>
        </member>
        <member name="P:System.SR.XmlFoundCData">
            <summary>cdata '{0}'</summary>
        </member>
        <member name="P:System.SR.XmlFoundComment">
            <summary>comment '{0}'</summary>
        </member>
        <member name="P:System.SR.XmlFoundElement">
            <summary>element '{0}' from namespace '{1}'</summary>
        </member>
        <member name="P:System.SR.XmlFoundEndElement">
            <summary>end element '{0}' from namespace '{1}'</summary>
        </member>
        <member name="P:System.SR.XmlFoundEndOfFile">
            <summary>end of file</summary>
        </member>
        <member name="P:System.SR.XmlFoundNodeType">
            <summary>node {0}</summary>
        </member>
        <member name="P:System.SR.XmlFoundText">
            <summary>text '{0}'</summary>
        </member>
        <member name="P:System.SR.XmlFullStartElementExpected">
            <summary>Non-empty start element expected. Found {0}.</summary>
        </member>
        <member name="P:System.SR.XmlFullStartElementLocalNameNsExpected">
            <summary>Non-empty start element '{0}' from namespace '{1}' expected. Found {2}.</summary>
        </member>
        <member name="P:System.SR.XmlFullStartElementNameExpected">
            <summary>Non-empty start element '{0}' expected. Found {1}.</summary>
        </member>
        <member name="P:System.SR.XmlIDDefined">
            <summary>ID already defined.</summary>
        </member>
        <member name="P:System.SR.XmlKeyAlreadyExists">
            <summary>The specified key already exists in the dictionary.</summary>
        </member>
        <member name="P:System.SR.XmlIllegalOutsideRoot">
            <summary>Text cannot be written outside the root element.</summary>
        </member>
        <member name="P:System.SR.XmlInvalidBytes">
            <summary>Invalid byte encoding.</summary>
        </member>
        <member name="P:System.SR.XmlInvalidCharRef">
            <summary>Character reference not valid.</summary>
        </member>
        <member name="P:System.SR.XmlInvalidCommentChars">
            <summary>XML comments cannot contain '--' or end with '-'.</summary>
        </member>
        <member name="P:System.SR.XmlInvalidDeclaration">
            <summary>XML declaration can only be written at the beginning of the document.</summary>
        </member>
        <member name="P:System.SR.XmlInvalidDepth">
            <summary>Cannot call '{0}' while Depth is '{1}'.</summary>
        </member>
        <member name="P:System.SR.XmlInvalidEncoding_UTF8">
            <summary>XML encoding must be 'UTF-8'.</summary>
        </member>
        <member name="P:System.SR.XmlInvalidFFFE">
            <summary>Characters with hexadecimal values 0xFFFE and 0xFFFF are not valid.</summary>
        </member>
        <member name="P:System.SR.XmlInvalidFormat">
            <summary>The input source is not correctly formatted.</summary>
        </member>
        <member name="P:System.SR.XmlInvalidID">
            <summary>ID must be &gt;</summary>
        </member>
        <member name="P:System.SR.XmlInvalidOperation">
            <summary>The reader cannot be advanced.</summary>
        </member>
        <member name="P:System.SR.XmlInvalidPrefixState">
            <summary>A prefix cannot be defined while WriteState is '{0}'.</summary>
        </member>
        <member name="P:System.SR.XmlInvalidQualifiedName">
            <summary>Expected XML qualified name. Found '{0}'.</summary>
        </member>
        <member name="P:System.SR.XmlInvalidRootData">
            <summary>The data at the root level is invalid.</summary>
        </member>
        <member name="P:System.SR.XmlInvalidStandalone">
            <summary>'standalone' value in declaration must be 'yes' or 'no'.</summary>
        </member>
        <member name="P:System.SR.XmlInvalidUniqueId">
            <summary>UniqueId cannot be zero length.</summary>
        </member>
        <member name="P:System.SR.XmlInvalidUTF8Bytes">
            <summary>'{0}' contains invalid UTF-8 bytes.</summary>
        </member>
        <member name="P:System.SR.XmlInvalidVersion">
            <summary>XML version must be '1.0'.</summary>
        </member>
        <member name="P:System.SR.XmlInvalidWriteState">
            <summary>'{0}' cannot be called while WriteState is '{1}'.</summary>
        </member>
        <member name="P:System.SR.XmlInvalidXmlByte">
            <summary>The byte 0x{0} is not valid at this location.</summary>
        </member>
        <member name="P:System.SR.XmlInvalidXmlSpace">
            <summary>'{0}' is not a valid xml:space value. Valid values are 'default' and 'preserve'.</summary>
        </member>
        <member name="P:System.SR.XmlLineInfo">
            <summary>Line {0}, position {1}.</summary>
        </member>
        <member name="P:System.SR.XmlMalformedDecl">
            <summary>Malformed XML declaration.</summary>
        </member>
        <member name="P:System.SR.XmlMaxArrayLengthExceeded">
            <summary>The maximum array length quota ({0}) has been exceeded while reading XML data. This quota may be increased by changing the MaxArrayLength property on the XmlDictionaryReaderQuotas object used when creating the XML reader.</summary>
        </member>
        <member name="P:System.SR.XmlMaxArrayLengthOrMaxItemsQuotaExceeded">
            <summary>The maximum array length quota ({0}) or the maximum items in object graph quota has been exceeded while reading XML data. These quotas may be increased by changing the MaxArrayLength property on XmlDictionaryReaderQuotas or the MaxItemsInObjectGraph settin ...</summary>
        </member>
        <member name="P:System.SR.XmlMaxBytesPerReadExceeded">
            <summary>The 'maximum bytes per Read operation' quota ({0}) has been exceeded while reading XML data. Long element start tags (consisting of the element name, attribute names and attribute values) may trigger this quota. This quota may be increased by changing the  ...</summary>
        </member>
        <member name="P:System.SR.XmlMaxDepthExceeded">
            <summary>The maximum read depth ({0}) has been exceeded because XML data being read has more levels of nesting than is allowed by the quota. This quota may be increased by changing the MaxDepth property on the XmlDictionaryReaderQuotas object used when creating the ...</summary>
        </member>
        <member name="P:System.SR.XmlMaxStringContentLengthExceeded">
            <summary>The maximum string content length quota ({0}) has been exceeded while reading XML data. This quota may be increased by changing the MaxStringContentLength property on the XmlDictionaryReaderQuotas object used when creating the XML reader.</summary>
        </member>
        <member name="P:System.SR.XmlMethodNotSupported">
            <summary>This XmlWriter implementation does not support the '{0}' method.</summary>
        </member>
        <member name="P:System.SR.XmlMissingLowSurrogate">
            <summary>The surrogate pair is invalid. Missing a low surrogate character.</summary>
        </member>
        <member name="P:System.SR.XmlMultipleRootElements">
            <summary>There are multiple root elements.</summary>
        </member>
        <member name="P:System.SR.XmlNamespaceNotFound">
            <summary>The namespace '{0}' is not defined.</summary>
        </member>
        <member name="P:System.SR.XmlNestedArraysNotSupported">
            <summary>Nested arrays are not supported.</summary>
        </member>
        <member name="P:System.SR.XmlNoRootElement">
            <summary>The document does not have a root element.</summary>
        </member>
        <member name="P:System.SR.XmlOnlyOneRoot">
            <summary>Only one root element is permitted per document.</summary>
        </member>
        <member name="P:System.SR.XmlOnlyWhitespace">
            <summary>Only whitespace characters can be written with this method.</summary>
        </member>
        <member name="P:System.SR.XmlOnlySingleValue">
            <summary>Only a single typed value may be written inside an attribute or content.</summary>
        </member>
        <member name="P:System.SR.XmlPrefixBoundToNamespace">
            <summary>The prefix '{0}' is bound to the namespace '{1}' and cannot be changed to '{2}'.</summary>
        </member>
        <member name="P:System.SR.XmlProcessingInstructionNotSupported">
            <summary>Processing instructions (other than the XML declaration) and DTDs are not supported.</summary>
        </member>
        <member name="P:System.SR.XmlReservedPrefix">
            <summary>Prefixes beginning with 'xml' (regardless of casing) are reserved for use by XML.</summary>
        </member>
        <member name="P:System.SR.XmlSpaceBetweenAttributes">
            <summary>Whitespace must appear between attributes.</summary>
        </member>
        <member name="P:System.SR.XmlSpecificBindingNamespace">
            <summary>The namespace '{1}' can only be bound to the prefix '{0}'.</summary>
        </member>
        <member name="P:System.SR.XmlSpecificBindingPrefix">
            <summary>The prefix '{0}' can only be bound to the namespace '{1}'.</summary>
        </member>
        <member name="P:System.SR.XmlStartElementLocalNameNsExpected">
            <summary>Start element '{0}' from namespace '{1}' expected. Found {2}.</summary>
        </member>
        <member name="P:System.SR.XmlStartElementNameExpected">
            <summary>Start element '{0}' expected. Found {1}.</summary>
        </member>
        <member name="P:System.SR.XmlTagMismatch">
            <summary>Start element '{0}' does not match end element '{1}'.</summary>
        </member>
        <member name="P:System.SR.XmlTokenExpected">
            <summary>The token '{0}' was expected but found '{1}'.</summary>
        </member>
        <member name="P:System.SR.XmlUndefinedPrefix">
            <summary>The prefix '{0}' is not defined.</summary>
        </member>
        <member name="P:System.SR.XmlUnexpectedEndElement">
            <summary>No matching start tag for end element.</summary>
        </member>
        <member name="P:System.SR.XmlUnexpectedEndOfFile">
            <summary>Unexpected end of file. Following elements are not closed: {0}.</summary>
        </member>
        <member name="P:System.SR.XmlWriterClosed">
            <summary>The XmlWriter is closed.</summary>
        </member>
        <member name="P:System.SR.XmlObjectAssignedToIncompatibleInterface">
            <summary>'{0}' is an XML type and cannot be serialized when assigned to an interface type that does not implement IXmlSerializable ('{1}'.)</summary>
        </member>
        <member name="P:System.SR.CollectionAssignedToIncompatibleInterface">
            <summary>'{0}' is a collection type and cannot be serialized when assigned to an interface type that does not implement IEnumerable ('{1}'.)</summary>
        </member>
        <member name="P:System.SR.JsonInvalidBytes">
            <summary>Invalid byte encoding.</summary>
        </member>
        <member name="P:System.SR.JsonDuplicateMemberNames">
            <summary>The data contract type '{0}' is not serializable with DataContractJsonSerializer because the data member '{1}' is duplicated in its type hierarchy.</summary>
        </member>
        <member name="P:System.SR.JsonUnsupportedForIsReference">
            <summary>The type '{0}' cannot be serialized to JSON because its IsReference setting is '{1}'. The JSON format does not support references because there is no standardized format for representing references. To enable serialization, disable the IsReference setting  ...</summary>
        </member>
        <member name="P:System.SR.SerializationCodeIsMissingForType">
            <summary>Type '{0}' cannot be serialized, serialization code for the type is missing. Consult the SDK documentation for adding it as a root serialization type.</summary>
        </member>
        <member name="P:System.SR.InvalidXmlDeserializingExtensionData">
            <summary>The XML encountered when deserializing extension data is invalid.</summary>
        </member>
        <member name="P:System.SR.InvalidStateInExtensionDataReader">
            <summary>An internal error has occurred. ExtensionDataReader is in an invalid state.</summary>
        </member>
        <member name="P:System.SR.JsonTypeNotSupportedByDataContractJsonSerializer">
            <summary>DataContractJsonSerializer does not support objects of type '{0}'.</summary>
        </member>
        <member name="P:System.SR.GetOnlyCollectionMustHaveAddMethod">
            <summary>Collection interface type '{0}' is being used as a get-only property and does not have an Add method. Consider adding a setter to the property or using a collection data contract that does have an Add method - for example IList or ICollection&lt;T&gt;.</summary>
        </member>
        <member name="P:System.SR.JsonUnexpectedAttributeValue">
            <summary>The attribute 'type' must have one of the following strings as its values: 'string', 'number', 'array', 'object', 'null', or 'boolean'.  Encountered unexpected value '{0}'</summary>
        </member>
        <member name="P:System.SR.JsonInvalidDateTimeString">
            <summary>DateTime content '{0}' does not start with '{1}' and end with '{2}' as required for JSON.</summary>
        </member>
        <member name="P:System.SR.GenericCallbackException">
            <summary>A user callback threw an exception.  Check the exception stack and inner exception to determine the callback that failed.</summary>
        </member>
        <member name="P:System.SR.JsonEncounteredUnexpectedCharacter">
            <summary>Encountered unexpected character '{0}'.</summary>
        </member>
        <member name="P:System.SR.JsonOffsetExceedsBufferSize">
            <summary>The specified offset exceeds the buffer size ({0} bytes).</summary>
        </member>
        <member name="P:System.SR.JsonSizeExceedsRemainingBufferSpace">
            <summary>The specified size exceeds the remaining buffer space ('{0}' bytes).</summary>
        </member>
        <member name="P:System.SR.InvalidCharacterEncountered">
            <summary>Encountered invalid character '{0}'.</summary>
        </member>
        <member name="P:System.SR.JsonInvalidFFFE">
            <summary>Characters with hexadecimal values 0xFFFE and 0xFFFF are not valid.</summary>
        </member>
        <member name="P:System.SR.JsonDateTimeOutOfRange">
            <summary>DateTime values that are greater than DateTime.MaxValue or smaller than DateTime.MinValue when converted to UTC cannot be serialized to JSON.</summary>
        </member>
        <member name="P:System.SR.JsonWriteArrayNotSupported">
            <summary>To write JSON arrays, use XML writer methods to write the attribute type='array' followed by methods like WriteStartElement (with the local name 'item'), WriteAttributeString, and WriteEndElement to write the JSON array items.</summary>
        </member>
        <member name="P:System.SR.JsonMethodNotSupported">
            <summary>This XmlDictionaryWriter implementation does not support the '{0}' method.</summary>
        </member>
        <member name="P:System.SR.JsonNoMatchingStartAttribute">
            <summary>There is no open attribute.</summary>
        </member>
        <member name="P:System.SR.JsonNamespaceMustBeEmpty">
            <summary>Encountered unexpected namespace '{0}'. The namespace must be empty.</summary>
        </member>
        <member name="P:System.SR.JsonEndElementNoOpenNodes">
            <summary>No corresponding start element is open.</summary>
        </member>
        <member name="P:System.SR.JsonOpenAttributeMustBeClosedFirst">
            <summary>Cannot call {0} while an attribute is being written.</summary>
        </member>
        <member name="P:System.SR.JsonMustSpecifyDataType">
            <summary>You must write an attribute '{0}'='{1}' after writing the attribute with local name '{2}'.</summary>
        </member>
        <member name="P:System.SR.JsonXmlProcessingInstructionNotSupported">
            <summary>Processing instructions (other than the XML declaration) are not supported.</summary>
        </member>
        <member name="P:System.SR.JsonXmlInvalidDeclaration">
            <summary>XML declaration can only be written at the beginning of the document.</summary>
        </member>
        <member name="P:System.SR.JsonInvalidLocalNameEmpty">
            <summary>The empty string is not a valid local name in JSON.</summary>
        </member>
        <member name="P:System.SR.JsonPrefixMustBeNullOrEmpty">
            <summary>Encountered unexpected prefix '{0}'. The prefix must be null or empty.</summary>
        </member>
        <member name="P:System.SR.JsonAttributeMustHaveElement">
            <summary>WriteStartElement must be called at least once before WriteStartAttribute may be called.</summary>
        </member>
        <member name="P:System.SR.JsonAttributeAlreadyWritten">
            <summary>Cannot write attribute with local name '{0}' multiple times.</summary>
        </member>
        <member name="P:System.SR.JsonServerTypeSpecifiedForInvalidDataType">
            <summary>Attempted to write an attribute with local name '{0}' after writing the attribute '{1}'='{2}'. An attribute with local name '{0}' may be written only after writing the attribute '{1}'='{3}'.</summary>
        </member>
        <member name="P:System.SR.JsonUnexpectedAttributeLocalName">
            <summary>Encountered unexpected attribute local name '{0}'. 'type' and '__type' are the only allowed local names for attributes. 'type' can be used to influence how data is written; its valid values are 'object', 'string', 'number', 'null', 'boolean', and 'array'.  ...</summary>
        </member>
        <member name="P:System.SR.JsonInvalidWriteState">
            <summary>'{0}' cannot be called while WriteState is '{1}'.</summary>
        </member>
        <member name="P:System.SR.JsonMultipleRootElementsNotAllowedOnWriter">
            <summary>This XmlDictionaryWriter implementation does not support the writing of multiple root elements.</summary>
        </member>
        <member name="P:System.SR.JsonInvalidRootElementName">
            <summary>Encountered invalid root element name '{0}'. '{1}' is the only allowed root element name.</summary>
        </member>
        <member name="P:System.SR.JsonNodeTypeArrayOrObjectNotSpecified">
            <summary>WriteStartElement cannot be called immediately after WriteStartElement without writing the 'type'='array' or 'type='object' attribute.</summary>
        </member>
        <member name="P:System.SR.JsonInvalidItemNameForArrayElement">
            <summary>Encountered unexpected element local name '{0}' for item in collection. '{1}' is the only valid local name for elements in a collection.</summary>
        </member>
        <member name="P:System.SR.JsonInvalidStartElementCall">
            <summary>WriteStartElement can be called at only the start of a document or immediately after calling WriteEndElement.</summary>
        </member>
        <member name="P:System.SR.JsonOnlyWhitespace">
            <summary>Unexpected character '{0}'. '{1}' can write only whitespace characters.</summary>
        </member>
        <member name="P:System.SR.JsonWriterClosed">
            <summary>The writer is closed.</summary>
        </member>
        <member name="P:System.SR.JsonCannotWriteStandaloneTextAfterQuotedText">
            <summary>Cannot write a CLR value that maps to number, array, object, true, false or null in JSON after a string value has been written.</summary>
        </member>
        <member name="P:System.SR.JsonMustUseWriteStringForWritingAttributeValues">
            <summary>To write attribute values with this XmlDictionaryWriter implementation, you must write either string or char[] values.</summary>
        </member>
        <member name="P:System.SR.JsonInvalidDataTypeSpecifiedForServerType">
            <summary>Attempted to write an attribute '{0}'='{1}' after writing the attribute with local name '{2}'. The attribute with local name '{2}' is only valid with an attribute '{0}'='{3}'.</summary>
        </member>
        <member name="P:System.SR.JsonInvalidMethodBetweenStartEndAttribute">
            <summary>Cannot write content while an attribute is being written.</summary>
        </member>
        <member name="P:System.SR.JsonCannotWriteTextAfterNonTextAttribute">
            <summary>Attempted to write text after writing attribute type='{0}'. Text may be written only after the attributes type='number', type='boolean', or type='string'.</summary>
        </member>
        <member name="P:System.SR.JsonNestedArraysNotSupported">
            <summary>Nested arrays are not supported.</summary>
        </member>
        <member name="P:System.SR.JsonEncodingNotSupported">
            <summary>Encoding not supported in JSON. UTF-8, Unicode, and BigEndianUnicode are the only supported encodings.</summary>
        </member>
        <member name="P:System.SR.JsonExpectedEncoding">
            <summary>The expected encoding '{0}' does not match the actual encoding '{1}'.</summary>
        </member>
        <member name="P:System.SR.JsonUnexpectedEndOfFile">
            <summary>Unexpected end of file.</summary>
        </member>
        <member name="P:System.SR.AssemblyNotFound">
            <summary>Assembly '{0}' is not found.</summary>
        </member>
        <member name="P:System.SR.ClrTypeNotFound">
            <summary>The deserializer cannot load the type to deserialize because type '{1}' could not be found in assembly '{0}'. Check that the type being serialized has the same contract as the type being deserialized and the same assembly is used.</summary>
        </member>
        <member name="P:System.SR.AttributeNotFound">
            <summary>XML '{2}' '{3}:{4}' does not contain expected attribute '{0}:{1}'. The deserializer has no knowledge of which type to deserialize. Check that the type being serialized has the same contract as the type being deserialized.</summary>
        </member>
        <member name="P:System.SR.JsonDuplicateMemberInInput">
            <summary>The data contract type '{0}' cannot be deserialized because the data member '{1}' was found more than once in the input.</summary>
        </member>
        <member name="P:System.SR.JsonRequiredMembersNotFound">
            <summary>The data contract type '{0}' cannot be deserialized because the required data members '{1}' were not found.</summary>
        </member>
        <member name="P:System.SR.JsonOneRequiredMemberNotFound">
            <summary>The data contract type '{0}' cannot be deserialized because the required data member '{1}' was not found.</summary>
        </member>
        <member name="P:System.SR.EnumTypeNotSupportedByDataContractJsonSerializer">
            <summary>DataContractJsonSerializer does not support data members of type '{0}'.  Consider using int, System.Object, or a concrete enum definition instead.</summary>
        </member>
        <member name="P:System.SR.KeyTypeCannotBeParsedInSimpleDictionary">
            <summary>The dictionary of type '{0}' cannot be deserialized as a simple dictionary because its key type '{1}' does not have a public static Parse method.</summary>
        </member>
        <member name="P:System.SR.SurrogatesWithGetOnlyCollectionsNotSupportedSerDeser">
            <summary>Using surrogates with get-only collection properties is not supported.  Consider removing the surrogate associated with '{0}'.</summary>
        </member>
        <member name="P:System.SR.FactoryObjectContainsSelfReference">
            <summary>Object graph of type '{0}' with Id '{2}' contains a reference to itself. The object has been replaced with a new object of type '{1}' either because it implements IObjectReference or because it is surrogated. The serializer does not support fixing up the n ...</summary>
        </member>
        <member name="P:System.SR.RecursiveCollectionType">
            <summary>Type '{0}' is a recursive collection data contract which is not supported. Consider modifying the definition of collection '{0}' to remove references to itself.</summary>
        </member>
        <member name="P:System.SR.UnknownXmlType">
            <summary>Type '{0}' is not a valid XML type.</summary>
        </member>
        <member name="P:System.SR.DupContractInDataContractSet">
            <summary>DataContract with name '{0}' and namespace '{1}' cannot be added to DataContractSet since another contract with the same data contract name is already present and the contracts are not equivalent.</summary>
        </member>
        <member name="P:System.SR.DupTypeContractInDataContractSet">
            <summary>DataContract for type '{0}' cannot be added to DataContractSet since type '{1}' with the same data contract name '{2}' in namespace '{3}' is already present and the contracts are not equivalent.</summary>
        </member>
        <member name="P:System.SR.GenericTypeNameMismatch">
            <summary>DataContract name '{0}' from namespace '{1}' does not match the generic name '{2}' from namespace '{3}'.</summary>
        </member>
        <member name="P:System.SR.GenericTypeNotExportable">
            <summary>Type '{0}' cannot be exported as a schema type because it is an open generic type. You can only export a generic type if all its generic parameter types are actual types.</summary>
        </member>
        <member name="P:System.SR.CannotExportNullAssembly">
            <summary>Cannot export null assembly provided via '{0}' parameter.</summary>
        </member>
        <member name="P:System.SR.CannotExportNullKnownType">
            <summary>Cannot export null type provided via KnownTypesCollection.</summary>
        </member>
        <member name="P:System.SR.CannotExportNullType">
            <summary>Cannot export null type provided via '{0}' parameter.</summary>
        </member>
        <member name="P:System.SR.QueryGeneratorPathToMemberNotFound">
            <summary>Cannot find a path to the member when generating the XPath query.</summary>
        </member>
        <member name="P:System.SR.XmlInvalidStream">
            <summary>Stream returned by IStreamProvider cannot be null.</summary>
        </member>
        <member name="P:System.SR.ISerializableAssemblyNameSetToZero">
            <summary>Type '{0}' has set its ISerializable assembly name to "0". "0" is an invalid assembly name. Consider using the full name of mscorlib if you would like your type to be deserialized in that assembly.</summary>
        </member>
        <member name="P:System.SR.RequiresClassDataContractToSetIsISerializable">
            <summary>Only classes can be generated as ISerializable.</summary>
        </member>
        <member name="P:System.SR.ISerializableCannotHaveDataContract">
            <summary>Type '{0}' cannot be ISerializable and have DataContractAttribute attribute.</summary>
        </member>
        <member name="P:System.SR.SerializationInfo_ConstructorNotFound">
            <summary>The constructor with parameters (SerializationInfo, StreamingContext) is not found in ISerializable type '{0}'.</summary>
        </member>
        <member name="P:System.SR.ChangingFullTypeNameNotSupported">
            <summary>DataContractJsonSerializer does not support the setting of the FullTypeName of the object to be serialized to a value other than the default FullTypeName. Attempted to serialize object with full type name '{0}' and default full type name '{1}'.</summary>
        </member>
        <member name="P:System.SR.InterfaceTypeCannotBeCreated">
            <summary>Interface type '{0}' cannot be created. Consider replacing with a non-interface serializable type.</summary>
        </member>
        <member name="P:System.SR.ArraySizeAttributeIncorrect">
            <summary>Array Size '{0}' is not equal to the number of elements found '{1}'.</summary>
        </member>
        <member name="P:System.SR.DuplicateExtensionDataSetMethod">
            <summary>Invalid IExtensibleDataObject. Both '{0}' and '{1}' in type '{2}' provide property setter.</summary>
        </member>
        <member name="P:System.SR.ExtensionDataSetMustReturnVoid">
            <summary>IExtensibleDataObject property setter '{1}' in type '{0}' must return void.</summary>
        </member>
        <member name="P:System.SR.ExtensionDataSetParameterInvalid">
            <summary>IExtensibleDataObject property setter '{1}' in type '{0}' must have a single parameter of type '{2}'.</summary>
        </member>
        <member name="P:System.SR.OnlyDataContractTypesCanHaveExtensionData">
            <summary>Type '{0}' does not have DataContractAttribute attribute and therefore cannot support IExtensibleDataObject.</summary>
        </member>
        <member name="P:System.SR.ParseJsonNumberReturnInvalidNumber">
            <summary>JsonObjectDataContract.ParseJsonNumber shouldn't return a TypeCode that we're not expecting.</summary>
        </member>
        <member name="P:System.SR.CouldNotReadSerializationSchema">
            <summary>An internal error has occurred. Could not load serialization schema. Consider providing schema with namespace '{0}'.</summary>
        </member>
        <member name="P:System.SR.MissingSchemaType">
            <summary>Schema type '{0}' returned by CLR type '{1}' is not found in the XmlSchemaSet.</summary>
        </member>
        <member name="P:System.SR.InvalidReturnSchemaOnGetSchemaMethod">
            <summary>Method '{0}.GetSchema()' must return a schema with a valid Id.</summary>
        </member>
        <member name="P:System.SR.PlatformNotSupported_MtomEncoding">
            <summary>The Message Transmission Optimization Mechanism (MTOM) message encoding is not supported on this platform.</summary>
        </member>
        <member name="P:System.SR.PlatformNotSupported_NetDataContractSerializer">
            <summary>System.Runtime.Serialization.NetDataContractSerializer is not supported on this platform.</summary>
        </member>
        <member name="P:System.SR.PlatformNotSupported_IDataContractSurrogate">
            <summary>The implementation of the function requires System.Runtime.Serialization.IDataContractSurrogate which is not supported on this platform.</summary>
        </member>
        <member name="P:System.SR.PlatformNotSupported_SchemaImporter">
            <summary>The implementation of the function requires System.Runtime.Serialization.SchemaImporter which is not supported on this platform.</summary>
        </member>
        <member name="P:System.SR.FactoryTypeNotISerializable">
            <summary>Factory type '{0}' for ISerializable type '{1}' must also be ISerializable.</summary>
        </member>
        <member name="P:System.SR.XmlCanonicalizationStarted">
            <summary>Canonicalization already started.</summary>
        </member>
        <member name="P:System.SR.XmlCanonicalizationNotStarted">
            <summary>Canonicalization not started.</summary>
        </member>
        <member name="P:System.SR.CombinedPrefixNSLength">
            <summary>The combined length of the prefix and namespace must not be greater than {0}.</summary>
        </member>
        <member name="P:System.SR.InvalidInclusivePrefixListCollection">
            <summary>The inclusive namespace prefix collection cannot contain null as one of the items.</summary>
        </member>
        <member name="P:System.SR.CannotSetTwice">
            <summary>Cannot set option twice.</summary>
        </member>
        <member name="P:System.SR.MustBeGreaterThanZero">
            <summary>'{0}' must be greater than 0.</summary>
        </member>
        <member name="P:System.SR.ReadOnlyClassDeserialization">
            <summary>{0} The class cannot be deserialized.</summary>
        </member>
        <member name="P:System.SR.ReadOnlyCollectionDeserialization">
            <summary>Collection type '{0}' cannot be deserialized since it</summary>
        </member>
        <member name="P:System.SR.UnknownNullType">
            <summary>Unknown Type for null value</summary>
        </member>
        <member name="P:System.SR.AmbiguousReferencedTypes1">
            <summary>List of referenced types contains more than one type with same data contract name. Need to exclude all but one of the following types. Only matching types can be valid references: {0}</summary>
        </member>
        <member name="P:System.SR.AmbiguousReferencedTypes3">
            <summary>List of referenced types contains more than one type with data contract name '{0}' in namespace '{1}'. Need to exclude all but one of the following types. Only matching types can be valid references: {2}</summary>
        </member>
        <member name="P:System.SR.AmbiguousReferencedCollectionTypes1">
            <summary>List of referenced collection types contains more than one type with same data contract name. Include only one of the following types. Only matching types can be valid references: {0}</summary>
        </member>
        <member name="P:System.SR.AmbiguousReferencedCollectionTypes3">
            <summary>List of referenced collection types contains more than one type with data contract name '{0}' in namespace '{1}'. Include only one of the following types. Only matching types can be valid references: {2}</summary>
        </member>
        <member name="P:System.SR.ReferencedCollectionTypesCannotContainNull">
            <summary>ReferencedCollectionTypes specified via ImportOptions must contain valid types. Cannot contain null.</summary>
        </member>
        <member name="P:System.SR.ReferencedTypeMatchingMessage">
            <summary>(matching)</summary>
        </member>
        <member name="P:System.SR.ReferencedTypeNotMatchingMessage">
            <summary>(not matching)</summary>
        </member>
        <member name="P:System.SR.ReferencedTypesCannotContainNull">
            <summary>ReferencedTypes specified via ImportOptions must contain valid types. Cannot contain null.</summary>
        </member>
        <member name="P:System.SR.SurrogatesWithGetOnlyCollectionsNotSupported">
            <summary>Using surrogates with get-only collection properties is not supported.  Consider removing the surrogate associated with '{0}' or adding a setter to '{1}.{2}'.</summary>
        </member>
        <member name="P:System.SR.AbstractElementNotSupported">
            <summary>The element cannot have 'abstract' set to 'true'.</summary>
        </member>
        <member name="P:System.SR.AbstractTypeNotSupported">
            <summary>The type cannot have 'abstract' set to 'true'.</summary>
        </member>
        <member name="P:System.SR.AnnotationAttributeNotFound">
            <summary>Invalid '{0}' annotation in type '{1}' from namespace '{2}'. Attribute '{3}' not present.</summary>
        </member>
        <member name="P:System.SR.AnonymousTypeNotSupported">
            <summary>Anonymous type in element '{0}' from namespace '{1}' is not supported.</summary>
        </member>
        <member name="P:System.SR.AnyAttributeNotSupported">
            <summary>'anyAttribute' is not supported.</summary>
        </member>
        <member name="P:System.SR.ArrayItemFormMustBe">
            <summary>Form for element '{0}' must be qualified.</summary>
        </member>
        <member name="P:System.SR.ArrayTypeCannotBeImported">
            <summary>Array type '{0}' in namespace '{1}' cannot be imported. {2}</summary>
        </member>
        <member name="P:System.SR.BaseTypeNotISerializable">
            <summary>One of its base types, '{0}' from namespace '{1}' is not ISerializable.</summary>
        </member>
        <member name="P:System.SR.CannotComputeUniqueName">
            <summary>A unique name cannot be computed for '{0}' because there are already Int32.MaxValue types of with the same name.</summary>
        </member>
        <member name="P:System.SR.CannotHaveDuplicateAttributeNames">
            <summary>The type contains two attributes with the same name '{0}'. Multiple attributes with the same name in one type are not supported.</summary>
        </member>
        <member name="P:System.SR.CannotHaveDuplicateElementNames">
            <summary>The type contains two elements with the same name '{0}'. Multiple elements with the same name in one type are not supported because members marked with DataMemberAttribute attribute must have unique names.</summary>
        </member>
        <member name="P:System.SR.CannotImportInvalidSchemas">
            <summary>Cannot import invalid schemas. Compilation on the XmlSchemaSet failed.</summary>
        </member>
        <member name="P:System.SR.CannotImportNullDataContractName">
            <summary>Cannot import type for null XmlQualifiedName specified via parameter.</summary>
        </member>
        <member name="P:System.SR.CannotImportNullSchema">
            <summary>Cannot import null XmlSchema contained in XmlSchemaSet specified via parameter.</summary>
        </member>
        <member name="P:System.SR.ComplexTypeRestrictionNotSupported">
            <summary>An internal error has occurred. Could not load serialization schema. Consider providing schema with namespace '{0}'.</summary>
        </member>
        <member name="P:System.SR.DefaultOnElementNotSupported">
            <summary>Default value on element '{0}' is not supported.</summary>
        </member>
        <member name="P:System.SR.DerivedTypeNotISerializable">
            <summary>It is not ISerializable but its base type '{0}' in namespace '{1}' is ISerializable.</summary>
        </member>
        <member name="P:System.SR.ElementMaxOccursMustBe">
            <summary>'maxOccurs' on element '{0}' must be 1.</summary>
        </member>
        <member name="P:System.SR.ElementMinOccursMustBe">
            <summary>'minOccurs' on element '{0}' must be 0 or 1.</summary>
        </member>
        <member name="P:System.SR.ElementRefOnLocalElementNotSupported">
            <summary>Ref to element '{0}' in '{1}' namespace is not supported.</summary>
        </member>
        <member name="P:System.SR.EnumEnumerationFacetsMustHaveValue">
            <summary>Enumeration facets without 'value' are not supported.</summary>
        </member>
        <member name="P:System.SR.EnumListInAnonymousTypeNotSupported">
            <summary>Anonymous type with &lt;list&gt; cannot be used to create Flags enumeration because it is not a valid enum type.</summary>
        </member>
        <member name="P:System.SR.EnumListMustContainAnonymousType">
            <summary>Simple type list must contain an anonymous type specifying enumeration facets.</summary>
        </member>
        <member name="P:System.SR.EnumOnlyEnumerationFacetsSupported">
            <summary>Facets other than enumeration facets are not supported.</summary>
        </member>
        <member name="P:System.SR.EnumRestrictionInvalid">
            <summary>Anonymous type with &lt;restriction&gt; cannot be used to create Flags enumeration because it is not a valid enum type.</summary>
        </member>
        <member name="P:System.SR.EnumTypeCannotBeImported">
            <summary>Enum type '{0}' in namespace '{1}' cannot be imported. {2}</summary>
        </member>
        <member name="P:System.SR.EnumUnionInAnonymousTypeNotSupported">
            <summary>Anonymous type with &lt;union&gt;. cannot be used to create Flags enumeration because it is not a valid enum type.</summary>
        </member>
        <member name="P:System.SR.FixedOnElementNotSupported">
            <summary>Fixed value on element '{0}' is not supported.</summary>
        </member>
        <member name="P:System.SR.FormMustBeQualified">
            <summary>Form on element '{0}' must be qualified.</summary>
        </member>
        <member name="P:System.SR.GenericAnnotationAttributeNotFound">
            <summary>Annotation for generic type '{0}' did not have attribute '{1}'.</summary>
        </member>
        <member name="P:System.SR.GenericAnnotationForNestedLevelMustBeIncreasing">
            <summary>Nested level on annotation elements '{0}' from namespace '{1}' for generic type '{2}' must be in increasing order.</summary>
        </member>
        <member name="P:System.SR.GenericAnnotationHasInvalidAttributeValue">
            <summary>Annotation element '{0}' from namespace '{1}' for generic type '{2}' has an invalid value '{3}' for attribute '{4}'. Expecting value to be of type '{5}'.</summary>
        </member>
        <member name="P:System.SR.GenericAnnotationHasInvalidElement">
            <summary>Annotation for generic type '{2}' has an invalid element '{0}' from namespace '{1}'.</summary>
        </member>
        <member name="P:System.SR.InvalidAnnotationExpectingText">
            <summary>Annotation '{0}' from namespace '{1}' has an invalid element '{2}' from namespace '{3}'. Expecting text.</summary>
        </member>
        <member name="P:System.SR.InvalidClassDerivation">
            <summary>Type '{0}' in namespace '{1}' cannot be used as the base type of a data contract type, because it itself does not have a data contract. Consider marking type '{0}' with the DataContractAttribute attribute.</summary>
        </member>
        <member name="P:System.SR.InvalidEmitDefaultAnnotation">
            <summary>Annotation for element {0} in type {1} from namespace {2} specifies EmitDefaultValue as 'true'. This requires the element to be either nillable or the element's type must be a value type.</summary>
        </member>
        <member name="P:System.SR.InvalidISerializableDerivation">
            <summary>Cannot import type '{0}' in namespace '{1}' as its base type because derived type is ISerializable but the base type is not ISerializable.</summary>
        </member>
        <member name="P:System.SR.InvalidKeyValueType">
            <summary>It is an invalid dictionary type. Element '{0}' must reference a complex type containing a sequence with two required elements. Either fix the schema or remove the IsDictionary annotation.</summary>
        </member>
        <member name="P:System.SR.InvalidKeyValueTypeNamespace">
            <summary>It is an invalid dictionary type since element '{0}' references a type from a different namespace '{1}'. Either fix the schema or remove the IsDictionary annotation.</summary>
        </member>
        <member name="P:System.SR.IsDictionaryFormattedIncorrectly">
            <summary>'{0}' is an invalid value for IsDictionary annotation. {1}</summary>
        </member>
        <member name="P:System.SR.IsValueTypeFormattedIncorrectly">
            <summary>'{0}' is an invalid value for IsValueType annotation. {1}</summary>
        </member>
        <member name="P:System.SR.ISerializableContainsMoreThanOneItems">
            <summary>Its root sequence contains more than one particle.</summary>
        </member>
        <member name="P:System.SR.ISerializableDerivedContainsOneOrMoreItems">
            <summary>Derived ISerializable types cannot contain any particles.</summary>
        </member>
        <member name="P:System.SR.ISerializableDoesNotContainAny">
            <summary>It does not contain root sequence with a wildcard element &lt;any&gt;.</summary>
        </member>
        <member name="P:System.SR.ISerializableMustRefFactoryTypeAttribute">
            <summary>It does not reference attribute '{0}' from namespace '{1}'.</summary>
        </member>
        <member name="P:System.SR.ISerializableTypeCannotBeImported">
            <summary>ISerializable type '{0}' in namespace '{1}' cannot be imported. '{2}'</summary>
        </member>
        <member name="P:System.SR.ISerializableWildcardMaxOccursMustBe">
            <summary>'maxOccurs' on the wildcard element must be '{0}'.</summary>
        </member>
        <member name="P:System.SR.ISerializableWildcardMinOccursMustBe">
            <summary>'minOccurs' on the wildcard element must be '{0}'.</summary>
        </member>
        <member name="P:System.SR.ISerializableWildcardNamespaceInvalid">
            <summary>Namespace on the wildcard element must be '{0}'.</summary>
        </member>
        <member name="P:System.SR.ISerializableWildcardProcessContentsInvalid">
            <summary>ProcessContents on the wildcard element must be '{0}'.</summary>
        </member>
        <member name="P:System.SR.MixedContentNotSupported">
            <summary>Complex type with mixed content is not supported.</summary>
        </member>
        <member name="P:System.SR.MustContainOnlyLocalElements">
            <summary>The root sequence must contain only local elements. Group ref, choice, any and nested sequences are not supported.</summary>
        </member>
        <member name="P:System.SR.RedefineNotSupported">
            <summary>Redefine is not supported.</summary>
        </member>
        <member name="P:System.SR.RootParticleMustBeSequence">
            <summary>The root particle must be a sequence.</summary>
        </member>
        <member name="P:System.SR.RootSequenceMaxOccursMustBe">
            <summary>'maxOccurs' on the root sequence must be 1.</summary>
        </member>
        <member name="P:System.SR.RootSequenceMustBeRequired">
            <summary>'minOccurs' on the root sequence must be 1.</summary>
        </member>
        <member name="P:System.SR.SimpleContentNotSupported">
            <summary>Complex types with simple content extension are not supported.</summary>
        </member>
        <member name="P:System.SR.SimpleTypeRestrictionDoesNotSpecifyBase">
            <summary>Simple type restriction must specify a base type.</summary>
        </member>
        <member name="P:System.SR.SimpleTypeUnionNotSupported">
            <summary>Simple types with &lt;union&gt; content are not supported.</summary>
        </member>
        <member name="P:System.SR.SpecifiedTypeNotFoundInSchema">
            <summary>Invalid type specified. Type with name '{0}' not found in schema with namespace '{1}'.</summary>
        </member>
        <member name="P:System.SR.SubstitutionGroupOnElementNotSupported">
            <summary>Substitution group on element '{0}' is not supported.</summary>
        </member>
        <member name="P:System.SR.TopLevelElementRepresentsDifferentType">
            <summary>The global element found in the schema with same name references a different type '{0}' in namespace '{1}'. Data contract types must have the same name as their root element name. Consider removing the global element or changing its type.</summary>
        </member>
        <member name="P:System.SR.TypeCannotBeImported">
            <summary>Type '{0}' in namespace '{1}' cannot be imported. {2}</summary>
        </member>
        <member name="P:System.SR.TypeCannotBeImportedHowToFix">
            <summary>{0} Either change the schema so that the types can map to data contract types or use ImportXmlType or use a different serializer.</summary>
        </member>
        <member name="P:System.SR.TypeShouldNotContainAttributes">
            <summary>Attributes must be optional and from namespace '{0}'.</summary>
        </member>
    </members>
</doc>
