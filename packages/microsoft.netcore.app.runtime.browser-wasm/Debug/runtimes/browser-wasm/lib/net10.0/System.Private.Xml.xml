<?xml version="1.0"?>
<doc>
    <assembly>
        <name>System.Private.Xml</name>
    </assembly>
    <members>
        <member name="T:System.Text.StringBuilderCache">
            <summary>Provide a cached reusable instance of stringbuilder per thread.</summary>
        </member>
        <member name="M:System.Text.StringBuilderCache.Acquire(System.Int32)">
            <summary>Get a StringBuilder for the specified capacity.</summary>
            <remarks>If a StringBuilder of an appropriate size is cached, it will be returned and the cache emptied.</remarks>
        </member>
        <member name="M:System.Text.StringBuilderCache.Release(System.Text.StringBuilder)">
            <summary>Place the specified builder in the cache if it is not too big.</summary>
        </member>
        <member name="M:System.Text.StringBuilderCache.GetStringAndRelease(System.Text.StringBuilder)">
            <summary>ToString() the stringbuilder, Release it to the cache, and return the resulting string.</summary>
        </member>
        <member name="M:System.Text.ValueStringBuilder.GetPinnableReference">
            <summary>
            Get a pinnable reference to the builder.
            Does not ensure there is a null char after <see cref="P:System.Text.ValueStringBuilder.Length"/>
            This overload is pattern matched in the C# 7.3+ compiler so you can omit
            the explicit method call, and write eg "fixed (char* c = builder)"
            </summary>
        </member>
        <member name="M:System.Text.ValueStringBuilder.GetPinnableReference(System.Boolean)">
            <summary>
            Get a pinnable reference to the builder.
            </summary>
            <param name="terminate">Ensures that the builder has a null char after <see cref="P:System.Text.ValueStringBuilder.Length"/></param>
        </member>
        <member name="P:System.Text.ValueStringBuilder.RawChars">
            <summary>Returns the underlying storage of the builder.</summary>
        </member>
        <member name="M:System.Text.ValueStringBuilder.AsSpan(System.Boolean)">
            <summary>
            Returns a span around the contents of the builder.
            </summary>
            <param name="terminate">Ensures that the builder has a null char after <see cref="P:System.Text.ValueStringBuilder.Length"/></param>
        </member>
        <member name="M:System.Text.ValueStringBuilder.Grow(System.Int32)">
            <summary>
            Resize the internal buffer either by doubling current buffer size or
            by adding <paramref name="additionalCapacityBeyondPos"/> to
            <see cref="F:System.Text.ValueStringBuilder._pos"/> whichever is greater.
            </summary>
            <param name="additionalCapacityBeyondPos">
            Number of chars requested beyond current position.
            </param>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.DecodeCharRegex_0">
            <summary>Custom <see cref="T:System.Text.RegularExpressions.Regex"/>-derived type for the DecodeCharRegex method.</summary>
        </member>
        <member name="F:System.Text.RegularExpressions.Generated.DecodeCharRegex_0.Instance">
            <summary>Cached, thread-safe singleton instance.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.DecodeCharRegex_0.#ctor">
            <summary>Initializes the instance.</summary>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.DecodeCharRegex_0.RunnerFactory">
            <summary>Provides a factory for creating <see cref="T:System.Text.RegularExpressions.RegexRunner"/> instances to be used by methods on <see cref="T:System.Text.RegularExpressions.Regex"/>.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.DecodeCharRegex_0.RunnerFactory.CreateInstance">
            <summary>Creates an instance of a <see cref="T:System.Text.RegularExpressions.RegexRunner"/> used by methods on <see cref="T:System.Text.RegularExpressions.Regex"/>.</summary>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.DecodeCharRegex_0.RunnerFactory.Runner">
            <summary>Provides the runner that contains the custom logic implementing the specified regular expression.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.DecodeCharRegex_0.RunnerFactory.Runner.Scan(System.ReadOnlySpan{System.Char})">
            <summary>Scan the <paramref name="inputSpan"/> starting from base.runtextstart for the next match.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.DecodeCharRegex_0.RunnerFactory.Runner.TryFindNextPossibleStartingPosition(System.ReadOnlySpan{System.Char})">
            <summary>Search <paramref name="inputSpan"/> starting from base.runtextpos for the next location a match could possibly start.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
            <returns>true if a possible match was found; false if no more matches are possible.</returns>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.DecodeCharRegex_0.RunnerFactory.Runner.TryMatchAtCurrentPosition(System.ReadOnlySpan{System.Char})">
            <summary>Determine whether <paramref name="inputSpan"/> at base.runtextpos is a match for the regular expression.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
            <returns>true if the regular expression matches at the current position; otherwise, false.</returns>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.EncodeCharRegex_1">
            <summary>Custom <see cref="T:System.Text.RegularExpressions.Regex"/>-derived type for the EncodeCharRegex method.</summary>
        </member>
        <member name="F:System.Text.RegularExpressions.Generated.EncodeCharRegex_1.Instance">
            <summary>Cached, thread-safe singleton instance.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.EncodeCharRegex_1.#ctor">
            <summary>Initializes the instance.</summary>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.EncodeCharRegex_1.RunnerFactory">
            <summary>Provides a factory for creating <see cref="T:System.Text.RegularExpressions.RegexRunner"/> instances to be used by methods on <see cref="T:System.Text.RegularExpressions.Regex"/>.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.EncodeCharRegex_1.RunnerFactory.CreateInstance">
            <summary>Creates an instance of a <see cref="T:System.Text.RegularExpressions.RegexRunner"/> used by methods on <see cref="T:System.Text.RegularExpressions.Regex"/>.</summary>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.EncodeCharRegex_1.RunnerFactory.Runner">
            <summary>Provides the runner that contains the custom logic implementing the specified regular expression.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.EncodeCharRegex_1.RunnerFactory.Runner.Scan(System.ReadOnlySpan{System.Char})">
            <summary>Scan the <paramref name="inputSpan"/> starting from base.runtextstart for the next match.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.EncodeCharRegex_1.RunnerFactory.Runner.TryFindNextPossibleStartingPosition(System.ReadOnlySpan{System.Char})">
            <summary>Search <paramref name="inputSpan"/> starting from base.runtextpos for the next location a match could possibly start.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
            <returns>true if a possible match was found; false if no more matches are possible.</returns>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.EncodeCharRegex_1.RunnerFactory.Runner.TryMatchAtCurrentPosition(System.ReadOnlySpan{System.Char})">
            <summary>Determine whether <paramref name="inputSpan"/> at base.runtextpos is a match for the regular expression.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
            <returns>true if the regular expression matches at the current position; otherwise, false.</returns>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.LanguageRegex_2">
            <summary>Custom <see cref="T:System.Text.RegularExpressions.Regex"/>-derived type for the LanguageRegex method.</summary>
        </member>
        <member name="F:System.Text.RegularExpressions.Generated.LanguageRegex_2.Instance">
            <summary>Cached, thread-safe singleton instance.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.LanguageRegex_2.#ctor">
            <summary>Initializes the instance.</summary>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.LanguageRegex_2.RunnerFactory">
            <summary>Provides a factory for creating <see cref="T:System.Text.RegularExpressions.RegexRunner"/> instances to be used by methods on <see cref="T:System.Text.RegularExpressions.Regex"/>.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.LanguageRegex_2.RunnerFactory.CreateInstance">
            <summary>Creates an instance of a <see cref="T:System.Text.RegularExpressions.RegexRunner"/> used by methods on <see cref="T:System.Text.RegularExpressions.Regex"/>.</summary>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.LanguageRegex_2.RunnerFactory.Runner">
            <summary>Provides the runner that contains the custom logic implementing the specified regular expression.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.LanguageRegex_2.RunnerFactory.Runner.Scan(System.ReadOnlySpan{System.Char})">
            <summary>Scan the <paramref name="inputSpan"/> starting from base.runtextstart for the next match.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.LanguageRegex_2.RunnerFactory.Runner.TryFindNextPossibleStartingPosition(System.ReadOnlySpan{System.Char})">
            <summary>Search <paramref name="inputSpan"/> starting from base.runtextpos for the next location a match could possibly start.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
            <returns>true if a possible match was found; false if no more matches are possible.</returns>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.LanguageRegex_2.RunnerFactory.Runner.TryMatchAtCurrentPosition(System.ReadOnlySpan{System.Char})">
            <summary>Determine whether <paramref name="inputSpan"/> at base.runtextpos is a match for the regular expression.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
            <returns>true if the regular expression matches at the current position; otherwise, false.</returns>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.Regex1_3">
            <summary>Custom <see cref="T:System.Text.RegularExpressions.Regex"/>-derived type for the Regex1 method.</summary>
        </member>
        <member name="F:System.Text.RegularExpressions.Generated.Regex1_3.Instance">
            <summary>Cached, thread-safe singleton instance.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.Regex1_3.#ctor">
            <summary>Initializes the instance.</summary>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.Regex1_3.RunnerFactory">
            <summary>Provides a factory for creating <see cref="T:System.Text.RegularExpressions.RegexRunner"/> instances to be used by methods on <see cref="T:System.Text.RegularExpressions.Regex"/>.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.Regex1_3.RunnerFactory.CreateInstance">
            <summary>Creates an instance of a <see cref="T:System.Text.RegularExpressions.RegexRunner"/> used by methods on <see cref="T:System.Text.RegularExpressions.Regex"/>.</summary>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.Regex1_3.RunnerFactory.Runner">
            <summary>Provides the runner that contains the custom logic implementing the specified regular expression.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.Regex1_3.RunnerFactory.Runner.Scan(System.ReadOnlySpan{System.Char})">
            <summary>Scan the <paramref name="inputSpan"/> starting from base.runtextstart for the next match.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.Regex1_3.RunnerFactory.Runner.TryFindNextPossibleStartingPosition(System.ReadOnlySpan{System.Char})">
            <summary>Search <paramref name="inputSpan"/> starting from base.runtextpos for the next location a match could possibly start.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
            <returns>true if a possible match was found; false if no more matches are possible.</returns>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.Regex1_3.RunnerFactory.Runner.TryMatchAtCurrentPosition(System.ReadOnlySpan{System.Char})">
            <summary>Determine whether <paramref name="inputSpan"/> at base.runtextpos is a match for the regular expression.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
            <returns>true if the regular expression matches at the current position; otherwise, false.</returns>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.Regex2_4">
            <summary>Custom <see cref="T:System.Text.RegularExpressions.Regex"/>-derived type for the Regex2 method.</summary>
        </member>
        <member name="F:System.Text.RegularExpressions.Generated.Regex2_4.Instance">
            <summary>Cached, thread-safe singleton instance.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.Regex2_4.#ctor">
            <summary>Initializes the instance.</summary>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.Regex2_4.RunnerFactory">
            <summary>Provides a factory for creating <see cref="T:System.Text.RegularExpressions.RegexRunner"/> instances to be used by methods on <see cref="T:System.Text.RegularExpressions.Regex"/>.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.Regex2_4.RunnerFactory.CreateInstance">
            <summary>Creates an instance of a <see cref="T:System.Text.RegularExpressions.RegexRunner"/> used by methods on <see cref="T:System.Text.RegularExpressions.Regex"/>.</summary>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.Regex2_4.RunnerFactory.Runner">
            <summary>Provides the runner that contains the custom logic implementing the specified regular expression.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.Regex2_4.RunnerFactory.Runner.Scan(System.ReadOnlySpan{System.Char})">
            <summary>Scan the <paramref name="inputSpan"/> starting from base.runtextstart for the next match.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.Regex2_4.RunnerFactory.Runner.TryFindNextPossibleStartingPosition(System.ReadOnlySpan{System.Char})">
            <summary>Search <paramref name="inputSpan"/> starting from base.runtextpos for the next location a match could possibly start.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
            <returns>true if a possible match was found; false if no more matches are possible.</returns>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.Regex2_4.RunnerFactory.Runner.TryMatchAtCurrentPosition(System.ReadOnlySpan{System.Char})">
            <summary>Determine whether <paramref name="inputSpan"/> at base.runtextpos is a match for the regular expression.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
            <returns>true if the regular expression matches at the current position; otherwise, false.</returns>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.EnsureArrayIndexRegex_5">
            <summary>Custom <see cref="T:System.Text.RegularExpressions.Regex"/>-derived type for the EnsureArrayIndexRegex method.</summary>
        </member>
        <member name="F:System.Text.RegularExpressions.Generated.EnsureArrayIndexRegex_5.Instance">
            <summary>Cached, thread-safe singleton instance.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.EnsureArrayIndexRegex_5.#ctor">
            <summary>Initializes the instance.</summary>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.EnsureArrayIndexRegex_5.RunnerFactory">
            <summary>Provides a factory for creating <see cref="T:System.Text.RegularExpressions.RegexRunner"/> instances to be used by methods on <see cref="T:System.Text.RegularExpressions.Regex"/>.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.EnsureArrayIndexRegex_5.RunnerFactory.CreateInstance">
            <summary>Creates an instance of a <see cref="T:System.Text.RegularExpressions.RegexRunner"/> used by methods on <see cref="T:System.Text.RegularExpressions.Regex"/>.</summary>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.EnsureArrayIndexRegex_5.RunnerFactory.Runner">
            <summary>Provides the runner that contains the custom logic implementing the specified regular expression.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.EnsureArrayIndexRegex_5.RunnerFactory.Runner.Scan(System.ReadOnlySpan{System.Char})">
            <summary>Scan the <paramref name="inputSpan"/> starting from base.runtextstart for the next match.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.EnsureArrayIndexRegex_5.RunnerFactory.Runner.TryFindNextPossibleStartingPosition(System.ReadOnlySpan{System.Char})">
            <summary>Search <paramref name="inputSpan"/> starting from base.runtextpos for the next location a match could possibly start.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
            <returns>true if a possible match was found; false if no more matches are possible.</returns>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.EnsureArrayIndexRegex_5.RunnerFactory.Runner.TryMatchAtCurrentPosition(System.ReadOnlySpan{System.Char})">
            <summary>Determine whether <paramref name="inputSpan"/> at base.runtextpos is a match for the regular expression.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
            <returns>true if the regular expression matches at the current position; otherwise, false.</returns>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.P0Regex_6">
            <summary>Custom <see cref="T:System.Text.RegularExpressions.Regex"/>-derived type for the P0Regex method.</summary>
        </member>
        <member name="F:System.Text.RegularExpressions.Generated.P0Regex_6.Instance">
            <summary>Cached, thread-safe singleton instance.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.P0Regex_6.#ctor">
            <summary>Initializes the instance.</summary>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.P0Regex_6.RunnerFactory">
            <summary>Provides a factory for creating <see cref="T:System.Text.RegularExpressions.RegexRunner"/> instances to be used by methods on <see cref="T:System.Text.RegularExpressions.Regex"/>.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.P0Regex_6.RunnerFactory.CreateInstance">
            <summary>Creates an instance of a <see cref="T:System.Text.RegularExpressions.RegexRunner"/> used by methods on <see cref="T:System.Text.RegularExpressions.Regex"/>.</summary>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.P0Regex_6.RunnerFactory.Runner">
            <summary>Provides the runner that contains the custom logic implementing the specified regular expression.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.P0Regex_6.RunnerFactory.Runner.Scan(System.ReadOnlySpan{System.Char})">
            <summary>Scan the <paramref name="inputSpan"/> starting from base.runtextstart for the next match.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.P0Regex_6.RunnerFactory.Runner.TryFindNextPossibleStartingPosition(System.ReadOnlySpan{System.Char})">
            <summary>Search <paramref name="inputSpan"/> starting from base.runtextpos for the next location a match could possibly start.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
            <returns>true if a possible match was found; false if no more matches are possible.</returns>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.P0Regex_6.RunnerFactory.Runner.TryMatchAtCurrentPosition(System.ReadOnlySpan{System.Char})">
            <summary>Determine whether <paramref name="inputSpan"/> at base.runtextpos is a match for the regular expression.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
            <returns>true if the regular expression matches at the current position; otherwise, false.</returns>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.UnknownNodeNullAnyTypeRegex_7">
            <summary>Custom <see cref="T:System.Text.RegularExpressions.Regex"/>-derived type for the UnknownNodeNullAnyTypeRegex method.</summary>
        </member>
        <member name="F:System.Text.RegularExpressions.Generated.UnknownNodeNullAnyTypeRegex_7.Instance">
            <summary>Cached, thread-safe singleton instance.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.UnknownNodeNullAnyTypeRegex_7.#ctor">
            <summary>Initializes the instance.</summary>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.UnknownNodeNullAnyTypeRegex_7.RunnerFactory">
            <summary>Provides a factory for creating <see cref="T:System.Text.RegularExpressions.RegexRunner"/> instances to be used by methods on <see cref="T:System.Text.RegularExpressions.Regex"/>.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.UnknownNodeNullAnyTypeRegex_7.RunnerFactory.CreateInstance">
            <summary>Creates an instance of a <see cref="T:System.Text.RegularExpressions.RegexRunner"/> used by methods on <see cref="T:System.Text.RegularExpressions.Regex"/>.</summary>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.UnknownNodeNullAnyTypeRegex_7.RunnerFactory.Runner">
            <summary>Provides the runner that contains the custom logic implementing the specified regular expression.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.UnknownNodeNullAnyTypeRegex_7.RunnerFactory.Runner.Scan(System.ReadOnlySpan{System.Char})">
            <summary>Scan the <paramref name="inputSpan"/> starting from base.runtextstart for the next match.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.UnknownNodeNullAnyTypeRegex_7.RunnerFactory.Runner.TryFindNextPossibleStartingPosition(System.ReadOnlySpan{System.Char})">
            <summary>Search <paramref name="inputSpan"/> starting from base.runtextpos for the next location a match could possibly start.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
            <returns>true if a possible match was found; false if no more matches are possible.</returns>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.UnknownNodeNullAnyTypeRegex_7.RunnerFactory.Runner.TryMatchAtCurrentPosition(System.ReadOnlySpan{System.Char})">
            <summary>Determine whether <paramref name="inputSpan"/> at base.runtextpos is a match for the regular expression.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
            <returns>true if the regular expression matches at the current position; otherwise, false.</returns>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.UnknownNodeObjectEmptyRegex_8">
            <summary>Custom <see cref="T:System.Text.RegularExpressions.Regex"/>-derived type for the UnknownNodeObjectEmptyRegex method.</summary>
        </member>
        <member name="F:System.Text.RegularExpressions.Generated.UnknownNodeObjectEmptyRegex_8.Instance">
            <summary>Cached, thread-safe singleton instance.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.UnknownNodeObjectEmptyRegex_8.#ctor">
            <summary>Initializes the instance.</summary>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.UnknownNodeObjectEmptyRegex_8.RunnerFactory">
            <summary>Provides a factory for creating <see cref="T:System.Text.RegularExpressions.RegexRunner"/> instances to be used by methods on <see cref="T:System.Text.RegularExpressions.Regex"/>.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.UnknownNodeObjectEmptyRegex_8.RunnerFactory.CreateInstance">
            <summary>Creates an instance of a <see cref="T:System.Text.RegularExpressions.RegexRunner"/> used by methods on <see cref="T:System.Text.RegularExpressions.Regex"/>.</summary>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.UnknownNodeObjectEmptyRegex_8.RunnerFactory.Runner">
            <summary>Provides the runner that contains the custom logic implementing the specified regular expression.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.UnknownNodeObjectEmptyRegex_8.RunnerFactory.Runner.Scan(System.ReadOnlySpan{System.Char})">
            <summary>Scan the <paramref name="inputSpan"/> starting from base.runtextstart for the next match.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.UnknownNodeObjectEmptyRegex_8.RunnerFactory.Runner.TryFindNextPossibleStartingPosition(System.ReadOnlySpan{System.Char})">
            <summary>Search <paramref name="inputSpan"/> starting from base.runtextpos for the next location a match could possibly start.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
            <returns>true if a possible match was found; false if no more matches are possible.</returns>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.UnknownNodeObjectEmptyRegex_8.RunnerFactory.Runner.TryMatchAtCurrentPosition(System.ReadOnlySpan{System.Char})">
            <summary>Determine whether <paramref name="inputSpan"/> at base.runtextpos is a match for the regular expression.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
            <returns>true if the regular expression matches at the current position; otherwise, false.</returns>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.UnknownNodeObjectNullRegex_9">
            <summary>Custom <see cref="T:System.Text.RegularExpressions.Regex"/>-derived type for the UnknownNodeObjectNullRegex method.</summary>
        </member>
        <member name="F:System.Text.RegularExpressions.Generated.UnknownNodeObjectNullRegex_9.Instance">
            <summary>Cached, thread-safe singleton instance.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.UnknownNodeObjectNullRegex_9.#ctor">
            <summary>Initializes the instance.</summary>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.UnknownNodeObjectNullRegex_9.RunnerFactory">
            <summary>Provides a factory for creating <see cref="T:System.Text.RegularExpressions.RegexRunner"/> instances to be used by methods on <see cref="T:System.Text.RegularExpressions.Regex"/>.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.UnknownNodeObjectNullRegex_9.RunnerFactory.CreateInstance">
            <summary>Creates an instance of a <see cref="T:System.Text.RegularExpressions.RegexRunner"/> used by methods on <see cref="T:System.Text.RegularExpressions.Regex"/>.</summary>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.UnknownNodeObjectNullRegex_9.RunnerFactory.Runner">
            <summary>Provides the runner that contains the custom logic implementing the specified regular expression.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.UnknownNodeObjectNullRegex_9.RunnerFactory.Runner.Scan(System.ReadOnlySpan{System.Char})">
            <summary>Scan the <paramref name="inputSpan"/> starting from base.runtextstart for the next match.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.UnknownNodeObjectNullRegex_9.RunnerFactory.Runner.TryFindNextPossibleStartingPosition(System.ReadOnlySpan{System.Char})">
            <summary>Search <paramref name="inputSpan"/> starting from base.runtextpos for the next location a match could possibly start.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
            <returns>true if a possible match was found; false if no more matches are possible.</returns>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.UnknownNodeObjectNullRegex_9.RunnerFactory.Runner.TryMatchAtCurrentPosition(System.ReadOnlySpan{System.Char})">
            <summary>Determine whether <paramref name="inputSpan"/> at base.runtextpos is a match for the regular expression.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
            <returns>true if the regular expression matches at the current position; otherwise, false.</returns>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.UnknownNodeObjectRegex_10">
            <summary>Custom <see cref="T:System.Text.RegularExpressions.Regex"/>-derived type for the UnknownNodeObjectRegex method.</summary>
        </member>
        <member name="F:System.Text.RegularExpressions.Generated.UnknownNodeObjectRegex_10.Instance">
            <summary>Cached, thread-safe singleton instance.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.UnknownNodeObjectRegex_10.#ctor">
            <summary>Initializes the instance.</summary>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.UnknownNodeObjectRegex_10.RunnerFactory">
            <summary>Provides a factory for creating <see cref="T:System.Text.RegularExpressions.RegexRunner"/> instances to be used by methods on <see cref="T:System.Text.RegularExpressions.Regex"/>.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.UnknownNodeObjectRegex_10.RunnerFactory.CreateInstance">
            <summary>Creates an instance of a <see cref="T:System.Text.RegularExpressions.RegexRunner"/> used by methods on <see cref="T:System.Text.RegularExpressions.Regex"/>.</summary>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.UnknownNodeObjectRegex_10.RunnerFactory.Runner">
            <summary>Provides the runner that contains the custom logic implementing the specified regular expression.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.UnknownNodeObjectRegex_10.RunnerFactory.Runner.Scan(System.ReadOnlySpan{System.Char})">
            <summary>Scan the <paramref name="inputSpan"/> starting from base.runtextstart for the next match.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.UnknownNodeObjectRegex_10.RunnerFactory.Runner.TryFindNextPossibleStartingPosition(System.ReadOnlySpan{System.Char})">
            <summary>Search <paramref name="inputSpan"/> starting from base.runtextpos for the next location a match could possibly start.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
            <returns>true if a possible match was found; false if no more matches are possible.</returns>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.UnknownNodeObjectRegex_10.RunnerFactory.Runner.TryMatchAtCurrentPosition(System.ReadOnlySpan{System.Char})">
            <summary>Determine whether <paramref name="inputSpan"/> at base.runtextpos is a match for the regular expression.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
            <returns>true if the regular expression matches at the current position; otherwise, false.</returns>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.ParamsReadRegex_11">
            <summary>Custom <see cref="T:System.Text.RegularExpressions.Regex"/>-derived type for the ParamsReadRegex method.</summary>
        </member>
        <member name="F:System.Text.RegularExpressions.Generated.ParamsReadRegex_11.Instance">
            <summary>Cached, thread-safe singleton instance.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.ParamsReadRegex_11.#ctor">
            <summary>Initializes the instance.</summary>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.ParamsReadRegex_11.RunnerFactory">
            <summary>Provides a factory for creating <see cref="T:System.Text.RegularExpressions.RegexRunner"/> instances to be used by methods on <see cref="T:System.Text.RegularExpressions.Regex"/>.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.ParamsReadRegex_11.RunnerFactory.CreateInstance">
            <summary>Creates an instance of a <see cref="T:System.Text.RegularExpressions.RegexRunner"/> used by methods on <see cref="T:System.Text.RegularExpressions.Regex"/>.</summary>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.ParamsReadRegex_11.RunnerFactory.Runner">
            <summary>Provides the runner that contains the custom logic implementing the specified regular expression.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.ParamsReadRegex_11.RunnerFactory.Runner.Scan(System.ReadOnlySpan{System.Char})">
            <summary>Scan the <paramref name="inputSpan"/> starting from base.runtextstart for the next match.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.ParamsReadRegex_11.RunnerFactory.Runner.TryFindNextPossibleStartingPosition(System.ReadOnlySpan{System.Char})">
            <summary>Search <paramref name="inputSpan"/> starting from base.runtextpos for the next location a match could possibly start.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
            <returns>true if a possible match was found; false if no more matches are possible.</returns>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.ParamsReadRegex_11.RunnerFactory.Runner.TryMatchAtCurrentPosition(System.ReadOnlySpan{System.Char})">
            <summary>Determine whether <paramref name="inputSpan"/> at base.runtextpos is a match for the regular expression.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
            <returns>true if the regular expression matches at the current position; otherwise, false.</returns>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.Utilities">
            <summary>Helper methods used by generated <see cref="T:System.Text.RegularExpressions.Regex"/>-derived implementations.</summary>
        </member>
        <member name="F:System.Text.RegularExpressions.Generated.Utilities.s_defaultTimeout">
            <summary>Default timeout value set in <see cref="T:System.AppContext"/>, or <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout"/> if none was set.</summary>
        </member>
        <member name="F:System.Text.RegularExpressions.Generated.Utilities.s_hasTimeout">
            <summary>Whether <see cref="F:System.Text.RegularExpressions.Generated.Utilities.s_defaultTimeout"/> is non-infinite.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.Utilities.StackPush(System.Int32[]@,System.Int32@,System.Int32)">
            <summary>Pushes 1 value onto the backtracking stack.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.Utilities.StackPush(System.Int32[]@,System.Int32@,System.Int32,System.Int32)">
            <summary>Pushes 2 values onto the backtracking stack.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.Utilities.ValidateStackCookie(System.Int32,System.Int32)">
            <summary>Validates that a stack cookie popped off the backtracking stack holds the expected value. Debug only.</summary>
        </member>
        <member name="F:System.Text.RegularExpressions.Generated.Utilities.s_indexOfString_24E3F0A96FA8DE99FB25D242D87DAC774B6CA6628023D99447766181AE8B5C1F">
            <summary>Supports searching for the string "paramsRead[".</summary>
        </member>
        <member name="F:System.Text.RegularExpressions.Generated.Utilities.s_indexOfString_49E5939642BED022FF4CCC68711C353694EC5E15398AE4B384C29A17BD819BDF">
            <summary>Supports searching for the string "UnknownNode((object)".</summary>
        </member>
        <member name="F:System.Text.RegularExpressions.Generated.Utilities.s_indexOfString_A33692426CD23EBB54EC2CE470CB74EA3BB2120AA9FB6C85181C764DD117847E">
            <summary>Supports searching for the string "UnknownNode(null, @\"".</summary>
        </member>
        <member name="F:System.Text.RegularExpressions.Generated.Utilities.s_indexOfString_C94AE607B1711C3F90CF8B8C224548ED74A865FE986797F62276464CE6F9271D">
            <summary>Supports searching for the string "((".</summary>
        </member>
        <member name="F:System.Text.RegularExpressions.Generated.Utilities.s_indexOfString__x_OrdinalIgnoreCase">
            <summary>Supports searching for the string "_x".</summary>
        </member>
        <member name="P:System.HexConverter.CharToHexLookup">
            <summary>Map from an ASCII char to its hex value, e.g. arr['b'] == 11. 0xFF means it's not a hex digit.</summary>
        </member>
        <member name="T:System.Xml.BitStack">
            <summary>
            Manages a stack of bits.  Exposes push, pop, and peek operations.
            </summary>
        </member>
        <member name="M:System.Xml.BitStack.#ctor">
            <summary>
            Initialize stack.
            </summary>
        </member>
        <member name="M:System.Xml.BitStack.PushBit(System.Boolean)">
            <summary>
            Push a 0 or 1 bit onto the stack.
            </summary>
        </member>
        <member name="M:System.Xml.BitStack.PopBit">
            <summary>
            Pop the top bit from the stack and return it.
            </summary>
        </member>
        <member name="M:System.Xml.BitStack.PeekBit">
            <summary>
            Return the top bit on the stack without pushing or popping.
            </summary>
        </member>
        <member name="M:System.Xml.BitStack.PushCurr">
            <summary>
            this.curr has enough space for 31 bits (minus 1 for sentinel bit).  Once this space is
            exhausted, a uint stack is created to handle the overflow.
            </summary>
        </member>
        <member name="M:System.Xml.BitStack.PopCurr">
            <summary>
            If all bits have been popped from this.curr, then pop the previous uint value from the stack in
            order to provide another 31 bits.
            </summary>
        </member>
        <member name="M:System.Xml.HtmlEncodedRawTextWriter.WriteDocType(System.String,System.String,System.String,System.String)">
            Html rules allow public ID without system ID and always output "html"
        </member>
        <member name="M:System.Xml.HtmlEncodedRawTextWriterIndent.WriteDocType(System.String,System.String,System.String,System.String)">
            <summary>
            Serialize the document type declaration.
            </summary>
        </member>
        <member name="M:System.Xml.HtmlUtf8RawTextWriter.WriteDocType(System.String,System.String,System.String,System.String)">
            Html rules allow public ID without system ID and always output "html"
        </member>
        <member name="M:System.Xml.HtmlUtf8RawTextWriterIndent.WriteDocType(System.String,System.String,System.String,System.String)">
            <summary>
            Serialize the document type declaration.
            </summary>
        </member>
        <member name="T:System.Xml.NameTable">
            <devdoc>
               <para>
                  XmlNameTable implemented as a simple hash table.
               </para>
            </devdoc>
        </member>
        <member name="M:System.Xml.NameTable.#ctor">
            <devdoc>
                 Public constructor.
            </devdoc>
        </member>
        <member name="M:System.Xml.NameTable.Add(System.String)">
            <devdoc>
                 Add the given string to the NameTable or return
                 the existing string if it is already in the NameTable.
            </devdoc>
        </member>
        <member name="M:System.Xml.NameTable.Add(System.Char[],System.Int32,System.Int32)">
            <devdoc>
                 Add the given string to the NameTable or return
                 the existing string if it is already in the NameTable.
            </devdoc>
        </member>
        <member name="M:System.Xml.NameTable.Get(System.String)">
            <devdoc>
                 Find the matching string in the NameTable.
            </devdoc>
        </member>
        <member name="M:System.Xml.NameTable.Get(System.Char[],System.Int32,System.Int32)">
            <devdoc>
                 Find the matching string atom given a range of
                 characters.
            </devdoc>
        </member>
        <member name="T:System.Xml.Ref">
            <summary>
            Ref class is used to verify string atomization in debug mode.
            </summary>
        </member>
        <member name="T:System.Xml.Serialization.CodeGenerationOptions">
            <summary>
            Specifies various flavours of XmlCodeExporter generated code.
            </summary>
        </member>
        <member name="F:System.Xml.Serialization.CodeGenerationOptions.None">
            <summary>
            Default: use clr primitives for xsd primitives, generate fields and arrays.
            </summary>
        </member>
        <member name="F:System.Xml.Serialization.CodeGenerationOptions.GenerateProperties">
            <summary>
            Generate propertyes instead of fields
            </summary>
        </member>
        <member name="F:System.Xml.Serialization.CodeGenerationOptions.GenerateNewAsync">
            <summary>
            Generate new RAD asynchronous pattern. The feature allows customers to use an event-based model for invoking Web services asynchronously
            </summary>
        </member>
        <member name="F:System.Xml.Serialization.CodeGenerationOptions.GenerateOldAsync">
            <summary>
            Generate old asynchronous pattern: BeginXXX/EndXXX.
            </summary>
        </member>
        <member name="F:System.Xml.Serialization.CodeGenerationOptions.GenerateOrder">
            <summary>
            Generate OM using explicit ordering feature.
            </summary>
        </member>
        <member name="F:System.Xml.Serialization.CodeGenerationOptions.EnableDataBinding">
            <summary>
            Generate OM INotifyPropertyChanged interface to enable data binding.
            </summary>
        </member>
        <member name="T:System.Xml.Serialization.CodeIdentifier">
            <internalonly/>
             <devdoc>
                <para>[To be supplied.]</para>
             </devdoc>
        </member>
        <member name="M:System.Xml.Serialization.CodeIdentifier.MakePascal(System.String)">
            <devdoc>
               <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="M:System.Xml.Serialization.CodeIdentifier.MakeCamel(System.String)">
            <devdoc>
               <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="M:System.Xml.Serialization.CodeIdentifier.MakeValid(System.String)">
            <devdoc>
               <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="T:System.Xml.Serialization.CodeIdentifiers">
            <internalonly/>
             <devdoc>
                <para>[To be supplied.]</para>
             </devdoc>
        </member>
        <member name="P:System.Xml.Serialization.CodeIdentifiers.UseCamelCasing">
            <devdoc>
               <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="M:System.Xml.Serialization.CodeIdentifiers.MakeRightCase(System.String)">
            <devdoc>
               <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="M:System.Xml.Serialization.CodeIdentifiers.MakeUnique(System.String)">
            <devdoc>
               <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="M:System.Xml.Serialization.CodeIdentifiers.AddReserved(System.String)">
            <devdoc>
               <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="M:System.Xml.Serialization.CodeIdentifiers.RemoveReserved(System.String)">
            <devdoc>
               <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="M:System.Xml.Serialization.CodeIdentifiers.AddUnique(System.String,System.Object)">
            <devdoc>
               <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="M:System.Xml.Serialization.CodeIdentifiers.IsInUse(System.String)">
            <devdoc>
               <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="M:System.Xml.Serialization.CodeIdentifiers.Add(System.String,System.Object)">
            <devdoc>
               <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="M:System.Xml.Serialization.CodeIdentifiers.Remove(System.String)">
            <devdoc>
               <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="M:System.Xml.Serialization.CodeIdentifiers.ToArray(System.Type)">
            <devdoc>
               <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="M:System.Xml.Serialization.TempAssembly.LoadGeneratedAssembly(System.Type,System.String,System.Xml.Serialization.XmlSerializerImplementation@)">
            <devdoc>
               <para>
               Attempts to load pre-generated serialization assembly.
               First check for the [XmlSerializerAssembly] attribute
               </para>
            </devdoc>
        </member>
        <member name="T:System.Xml.Serialization.IndentedWriter">
            <summary>
            This class will write to a stream and manage indentation.
            </summary>
        </member>
        <member name="T:System.Xml.Serialization.IXmlSerializable">
            <internalonly/>
             <devdoc>
                <para>[To be supplied.]</para>
             </devdoc>
        </member>
        <member name="P:System.Xml.Serialization.SourceInfo.Regex1">
            <remarks>
            Pattern:<br/>
            <code>([(][(](?&lt;t&gt;[^)]+)[)])?(?&lt;a&gt;[^[]+)[[](?&lt;ia&gt;.+)[]][)]?</code><br/>
            Explanation:<br/>
            <code>
             Optional (greedy).<br/>
                 1st capture group.<br/>
                     Match the string "((".<br/>
                     "t" capture group.<br/>
                         Match a character other than ')' atomically at least once.<br/>
                     Match ')'.<br/>
             "a" capture group.<br/>
                 Match a character other than '[' atomically at least once.<br/>
             Match '['.<br/>
             "ia" capture group.<br/>
                 Match a character other than '\n' greedily at least once.<br/>
             Match ']'.<br/>
             Match ')' atomically, optionally.<br/>
            </code>
            </remarks>
        </member>
        <member name="P:System.Xml.Serialization.SourceInfo.Regex2">
            <remarks>
            Pattern:<br/>
            <code>[(][(](?&lt;cast&gt;[^)]+)[)](?&lt;arg&gt;[^)]+)[)]</code><br/>
            Explanation:<br/>
            <code>
             Match the string "((".<br/>
             "cast" capture group.<br/>
                 Match a character other than ')' atomically at least once.<br/>
             Match ')'.<br/>
             "arg" capture group.<br/>
                 Match a character other than ')' atomically at least once.<br/>
             Match ')'.<br/>
            </code>
            </remarks>
        </member>
        <member name="T:System.Xml.Serialization.XmlAnyAttributeAttribute">
            <devdoc>
               <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="M:System.Xml.Serialization.XmlAnyAttributeAttribute.#ctor">
            <devdoc>
               <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="T:System.Xml.Serialization.XmlAnyElementAttribute">
            <devdoc>
               <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="M:System.Xml.Serialization.XmlAnyElementAttribute.#ctor">
            <devdoc>
               <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="M:System.Xml.Serialization.XmlAnyElementAttribute.#ctor(System.String)">
            <devdoc>
               <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="M:System.Xml.Serialization.XmlAnyElementAttribute.#ctor(System.String,System.String)">
            <devdoc>
               <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="P:System.Xml.Serialization.XmlAnyElementAttribute.Name">
            <devdoc>
               <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="P:System.Xml.Serialization.XmlAnyElementAttribute.Namespace">
            <devdoc>
               <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="P:System.Xml.Serialization.XmlAnyElementAttribute.Order">
            <devdoc>
               <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="T:System.Xml.Serialization.XmlAnyElementAttributes">
            <devdoc>
               <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="P:System.Xml.Serialization.XmlAnyElementAttributes.Item(System.Int32)">
            <devdoc>
               <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="M:System.Xml.Serialization.XmlAnyElementAttributes.Add(System.Xml.Serialization.XmlAnyElementAttribute)">
            <devdoc>
               <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="M:System.Xml.Serialization.XmlAnyElementAttributes.Insert(System.Int32,System.Xml.Serialization.XmlAnyElementAttribute)">
            <devdoc>
               <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="M:System.Xml.Serialization.XmlAnyElementAttributes.IndexOf(System.Xml.Serialization.XmlAnyElementAttribute)">
            <devdoc>
               <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="M:System.Xml.Serialization.XmlAnyElementAttributes.Contains(System.Xml.Serialization.XmlAnyElementAttribute)">
            <devdoc>
               <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="M:System.Xml.Serialization.XmlAnyElementAttributes.Remove(System.Xml.Serialization.XmlAnyElementAttribute)">
            <devdoc>
               <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="M:System.Xml.Serialization.XmlAnyElementAttributes.CopyTo(System.Xml.Serialization.XmlAnyElementAttribute[],System.Int32)">
            <devdoc>
               <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="T:System.Xml.Serialization.XmlArrayAttribute">
            <devdoc>
               <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="M:System.Xml.Serialization.XmlArrayAttribute.#ctor">
            <devdoc>
               <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="M:System.Xml.Serialization.XmlArrayAttribute.#ctor(System.String)">
            <devdoc>
               <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="P:System.Xml.Serialization.XmlArrayAttribute.ElementName">
            <devdoc>
               <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="P:System.Xml.Serialization.XmlArrayAttribute.Namespace">
            <devdoc>
               <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="P:System.Xml.Serialization.XmlArrayAttribute.IsNullable">
            <devdoc>
               <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="P:System.Xml.Serialization.XmlArrayAttribute.Form">
            <devdoc>
               <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="P:System.Xml.Serialization.XmlArrayAttribute.Order">
            <devdoc>
               <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="T:System.Xml.Serialization.XmlArrayItemAttribute">
            <devdoc>
               <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="M:System.Xml.Serialization.XmlArrayItemAttribute.#ctor">
            <devdoc>
               <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="M:System.Xml.Serialization.XmlArrayItemAttribute.#ctor(System.String)">
            <devdoc>
               <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="M:System.Xml.Serialization.XmlArrayItemAttribute.#ctor(System.Type)">
            <devdoc>
               <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="M:System.Xml.Serialization.XmlArrayItemAttribute.#ctor(System.String,System.Type)">
            <devdoc>
               <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="P:System.Xml.Serialization.XmlArrayItemAttribute.Type">
            <devdoc>
               <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="P:System.Xml.Serialization.XmlArrayItemAttribute.ElementName">
            <devdoc>
               <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="P:System.Xml.Serialization.XmlArrayItemAttribute.Namespace">
            <devdoc>
               <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="P:System.Xml.Serialization.XmlArrayItemAttribute.DataType">
            <devdoc>
               <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="P:System.Xml.Serialization.XmlArrayItemAttribute.IsNullable">
            <devdoc>
               <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="P:System.Xml.Serialization.XmlArrayItemAttribute.Form">
            <devdoc>
               <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="T:System.Xml.Serialization.XmlArrayItemAttributes">
            <devdoc>
               <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="P:System.Xml.Serialization.XmlArrayItemAttributes.Item(System.Int32)">
            <devdoc>
               <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="M:System.Xml.Serialization.XmlArrayItemAttributes.Add(System.Xml.Serialization.XmlArrayItemAttribute)">
            <devdoc>
               <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="M:System.Xml.Serialization.XmlArrayItemAttributes.Insert(System.Int32,System.Xml.Serialization.XmlArrayItemAttribute)">
            <devdoc>
               <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="M:System.Xml.Serialization.XmlArrayItemAttributes.IndexOf(System.Xml.Serialization.XmlArrayItemAttribute)">
            <devdoc>
               <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="M:System.Xml.Serialization.XmlArrayItemAttributes.Contains(System.Xml.Serialization.XmlArrayItemAttribute)">
            <devdoc>
               <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="M:System.Xml.Serialization.XmlArrayItemAttributes.Remove(System.Xml.Serialization.XmlArrayItemAttribute)">
            <devdoc>
               <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="M:System.Xml.Serialization.XmlArrayItemAttributes.CopyTo(System.Xml.Serialization.XmlArrayItemAttribute[],System.Int32)">
            <devdoc>
               <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="T:System.Xml.Serialization.XmlAttributeAttribute">
            <devdoc>
               <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="M:System.Xml.Serialization.XmlAttributeAttribute.#ctor">
            <devdoc>
               <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="M:System.Xml.Serialization.XmlAttributeAttribute.#ctor(System.String)">
            <devdoc>
               <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="M:System.Xml.Serialization.XmlAttributeAttribute.#ctor(System.Type)">
            <devdoc>
               <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="M:System.Xml.Serialization.XmlAttributeAttribute.#ctor(System.String,System.Type)">
            <devdoc>
               <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="P:System.Xml.Serialization.XmlAttributeAttribute.Type">
            <devdoc>
               <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="P:System.Xml.Serialization.XmlAttributeAttribute.AttributeName">
            <devdoc>
               <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="P:System.Xml.Serialization.XmlAttributeAttribute.Namespace">
            <devdoc>
               <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="P:System.Xml.Serialization.XmlAttributeAttribute.DataType">
            <devdoc>
               <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="P:System.Xml.Serialization.XmlAttributeAttribute.Form">
            <devdoc>
               <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="T:System.Xml.Serialization.XmlAttributeOverrides">
            <devdoc>
               <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="M:System.Xml.Serialization.XmlAttributeOverrides.Add(System.Type,System.Xml.Serialization.XmlAttributes)">
            <devdoc>
               <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="M:System.Xml.Serialization.XmlAttributeOverrides.Add(System.Type,System.String,System.Xml.Serialization.XmlAttributes)">
            <devdoc>
               <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="P:System.Xml.Serialization.XmlAttributeOverrides.Item(System.Type)">
            <devdoc>
               <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="P:System.Xml.Serialization.XmlAttributeOverrides.Item(System.Type,System.String)">
            <devdoc>
               <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="T:System.Xml.Serialization.XmlAttributes">
            <devdoc>
               <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="M:System.Xml.Serialization.XmlAttributes.#ctor">
            <devdoc>
               <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="M:System.Xml.Serialization.XmlAttributes.#ctor(System.Reflection.ICustomAttributeProvider)">
            <devdoc>
               <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="P:System.Xml.Serialization.XmlAttributes.XmlElements">
            <devdoc>
               <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="P:System.Xml.Serialization.XmlAttributes.XmlAttribute">
            <devdoc>
               <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="P:System.Xml.Serialization.XmlAttributes.XmlEnum">
            <devdoc>
               <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="P:System.Xml.Serialization.XmlAttributes.XmlText">
            <devdoc>
               <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="P:System.Xml.Serialization.XmlAttributes.XmlArray">
            <devdoc>
               <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="P:System.Xml.Serialization.XmlAttributes.XmlArrayItems">
            <devdoc>
               <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="P:System.Xml.Serialization.XmlAttributes.XmlDefaultValue">
            <devdoc>
               <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="P:System.Xml.Serialization.XmlAttributes.XmlIgnore">
            <devdoc>
               <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="P:System.Xml.Serialization.XmlAttributes.XmlType">
            <devdoc>
               <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="P:System.Xml.Serialization.XmlAttributes.XmlRoot">
            <devdoc>
               <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="P:System.Xml.Serialization.XmlAttributes.XmlAnyElements">
            <devdoc>
               <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="P:System.Xml.Serialization.XmlAttributes.XmlAnyAttribute">
            <devdoc>
               <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="P:System.Xml.Serialization.XmlAttributes.Xmlns">
            <devdoc>
               <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="T:System.Xml.Serialization.XmlChoiceIdentifierAttribute">
            <devdoc>
               <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="M:System.Xml.Serialization.XmlChoiceIdentifierAttribute.#ctor">
            <devdoc>
               <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="M:System.Xml.Serialization.XmlChoiceIdentifierAttribute.#ctor(System.String)">
            <devdoc>
               <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="P:System.Xml.Serialization.XmlChoiceIdentifierAttribute.MemberName">
            <devdoc>
               <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="T:System.Xml.Serialization.XmlCustomFormatter">
            <summary>
              The <see cref="T:System.Xml.Serialization.XmlCustomFormatter"/> class provides a set of static methods for converting
              primitive type values to and from their XML string representations.</summary>
        </member>
        <member name="T:System.Xml.Serialization.XmlElementAttribute">
            <devdoc>
               <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="M:System.Xml.Serialization.XmlElementAttribute.#ctor">
            <devdoc>
               <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="M:System.Xml.Serialization.XmlElementAttribute.#ctor(System.String)">
            <devdoc>
               <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="M:System.Xml.Serialization.XmlElementAttribute.#ctor(System.Type)">
            <devdoc>
               <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="M:System.Xml.Serialization.XmlElementAttribute.#ctor(System.String,System.Type)">
            <devdoc>
               <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="P:System.Xml.Serialization.XmlElementAttribute.Type">
            <devdoc>
               <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="P:System.Xml.Serialization.XmlElementAttribute.ElementName">
            <devdoc>
               <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="P:System.Xml.Serialization.XmlElementAttribute.Namespace">
            <devdoc>
               <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="P:System.Xml.Serialization.XmlElementAttribute.DataType">
            <devdoc>
               <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="P:System.Xml.Serialization.XmlElementAttribute.IsNullable">
            <devdoc>
               <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="P:System.Xml.Serialization.XmlElementAttribute.Form">
            <devdoc>
               <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="P:System.Xml.Serialization.XmlElementAttribute.Order">
            <devdoc>
               <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="T:System.Xml.Serialization.XmlElementAttributes">
            <devdoc>
               <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="P:System.Xml.Serialization.XmlElementAttributes.Item(System.Int32)">
            <devdoc>
               <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="M:System.Xml.Serialization.XmlElementAttributes.Add(System.Xml.Serialization.XmlElementAttribute)">
            <devdoc>
               <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="M:System.Xml.Serialization.XmlElementAttributes.Insert(System.Int32,System.Xml.Serialization.XmlElementAttribute)">
            <devdoc>
               <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="M:System.Xml.Serialization.XmlElementAttributes.IndexOf(System.Xml.Serialization.XmlElementAttribute)">
            <devdoc>
               <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="M:System.Xml.Serialization.XmlElementAttributes.Contains(System.Xml.Serialization.XmlElementAttribute)">
            <devdoc>
               <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="M:System.Xml.Serialization.XmlElementAttributes.Remove(System.Xml.Serialization.XmlElementAttribute)">
            <devdoc>
               <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="M:System.Xml.Serialization.XmlElementAttributes.CopyTo(System.Xml.Serialization.XmlElementAttribute[],System.Int32)">
            <devdoc>
               <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="T:System.Xml.Serialization.XmlEnumAttribute">
            <devdoc>
               <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="M:System.Xml.Serialization.XmlEnumAttribute.#ctor">
            <devdoc>
               <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="M:System.Xml.Serialization.XmlEnumAttribute.#ctor(System.String)">
            <devdoc>
               <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="P:System.Xml.Serialization.XmlEnumAttribute.Name">
            <devdoc>
               <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="T:System.Xml.Serialization.XmlIgnoreAttribute">
            <devdoc>
               <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="M:System.Xml.Serialization.XmlIgnoreAttribute.#ctor">
            <devdoc>
               <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="T:System.Xml.Serialization.XmlIncludeAttribute">
            <devdoc>
               <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="M:System.Xml.Serialization.XmlIncludeAttribute.#ctor(System.Type)">
            <devdoc>
               <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="P:System.Xml.Serialization.XmlIncludeAttribute.Type">
            <devdoc>
               <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="T:System.Xml.Serialization.XmlMapping">
            <internalonly/>
             <devdoc>
                <para>[To be supplied.]</para>
             </devdoc>
        </member>
        <member name="P:System.Xml.Serialization.XmlMapping.ElementName">
            <devdoc>
               <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="P:System.Xml.Serialization.XmlMapping.XsdElementName">
            <devdoc>
               <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="P:System.Xml.Serialization.XmlMapping.Namespace">
            <devdoc>
               <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="M:System.Xml.Serialization.XmlMapping.SetKey(System.String)">
            <internalonly/>
        </member>
        <member name="M:System.Xml.Serialization.XmlMapping.SetKeyInternal(System.String)">
            <internalonly/>
        </member>
        <member name="T:System.Xml.Serialization.XmlMemberMapping">
            <internalonly/>
        </member>
        <member name="P:System.Xml.Serialization.XmlMemberMapping.ElementName">
            <devdoc>
               <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="P:System.Xml.Serialization.XmlMemberMapping.XsdElementName">
            <devdoc>
               <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="P:System.Xml.Serialization.XmlMemberMapping.Namespace">
            <devdoc>
               <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="P:System.Xml.Serialization.XmlMemberMapping.MemberName">
            <devdoc>
               <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="P:System.Xml.Serialization.XmlMemberMapping.TypeName">
            <devdoc>
               <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="P:System.Xml.Serialization.XmlMemberMapping.TypeNamespace">
            <devdoc>
               <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="P:System.Xml.Serialization.XmlMemberMapping.TypeFullName">
            <devdoc>
               <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="P:System.Xml.Serialization.XmlMemberMapping.CheckSpecified">
            <devdoc>
               <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="T:System.Xml.Serialization.XmlMembersMapping">
            <internalonly/>
             <devdoc>
                <para>[To be supplied.]</para>
             </devdoc>
        </member>
        <member name="P:System.Xml.Serialization.XmlMembersMapping.TypeName">
            <devdoc>
               <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="P:System.Xml.Serialization.XmlMembersMapping.TypeNamespace">
            <devdoc>
               <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="P:System.Xml.Serialization.XmlMembersMapping.Item(System.Int32)">
            <devdoc>
               <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="P:System.Xml.Serialization.XmlMembersMapping.Count">
            <devdoc>
               <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="T:System.Xml.Serialization.XmlNamespaceDeclarationsAttribute">
            <devdoc>
               <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="M:System.Xml.Serialization.XmlNamespaceDeclarationsAttribute.#ctor">
            <devdoc>
               <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="T:System.Xml.Serialization.XmlReflectionImporter">
            <internalonly/>
             <devdoc>
                <para>[To be supplied.]</para>
             </devdoc>
        </member>
        <member name="M:System.Xml.Serialization.XmlReflectionImporter.#ctor">
            <devdoc>
               <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="M:System.Xml.Serialization.XmlReflectionImporter.#ctor(System.String)">
            <devdoc>
               <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="M:System.Xml.Serialization.XmlReflectionImporter.#ctor(System.Xml.Serialization.XmlAttributeOverrides)">
            <devdoc>
               <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="M:System.Xml.Serialization.XmlReflectionImporter.#ctor(System.Xml.Serialization.XmlAttributeOverrides,System.String)">
            <devdoc>
               <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="M:System.Xml.Serialization.XmlReflectionImporter.IncludeTypes(System.Reflection.ICustomAttributeProvider)">
            <devdoc>
               <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="M:System.Xml.Serialization.XmlReflectionImporter.IncludeType(System.Type)">
            <devdoc>
               <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="M:System.Xml.Serialization.XmlReflectionImporter.ImportTypeMapping(System.Type)">
            <devdoc>
               <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="M:System.Xml.Serialization.XmlReflectionImporter.ImportTypeMapping(System.Type,System.String)">
            <devdoc>
               <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="M:System.Xml.Serialization.XmlReflectionImporter.ImportTypeMapping(System.Type,System.Xml.Serialization.XmlRootAttribute)">
            <devdoc>
               <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="M:System.Xml.Serialization.XmlReflectionImporter.ImportTypeMapping(System.Type,System.Xml.Serialization.XmlRootAttribute,System.String)">
            <devdoc>
               <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="M:System.Xml.Serialization.XmlReflectionImporter.ImportMembersMapping(System.String,System.String,System.Xml.Serialization.XmlReflectionMember[],System.Boolean)">
            <devdoc>
               <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="M:System.Xml.Serialization.XmlReflectionImporter.ImportMembersMapping(System.String,System.String,System.Xml.Serialization.XmlReflectionMember[],System.Boolean,System.Boolean)">
            <devdoc>
               <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="M:System.Xml.Serialization.XmlReflectionImporter.ImportMembersMapping(System.String,System.String,System.Xml.Serialization.XmlReflectionMember[],System.Boolean,System.Boolean,System.Boolean)">
             <devdoc>
                <para>[To be supplied.]</para>
             </devdoc>
            
        </member>
        <member name="M:System.Xml.Serialization.XmlReflectionImporter.ImportMembersMapping(System.String,System.String,System.Xml.Serialization.XmlReflectionMember[],System.Boolean,System.Boolean,System.Boolean,System.Xml.Serialization.XmlMappingAccess)">
             <devdoc>
                <para>[To be supplied.]</para>
             </devdoc>
            
        </member>
        <member name="T:System.Xml.Serialization.XmlReflectionMember">
            <internalonly/>
             <devdoc>
                <para>[To be supplied.]</para>
             </devdoc>
        </member>
        <member name="P:System.Xml.Serialization.XmlReflectionMember.MemberType">
            <devdoc>
               <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="P:System.Xml.Serialization.XmlReflectionMember.XmlAttributes">
            <devdoc>
               <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="P:System.Xml.Serialization.XmlReflectionMember.SoapAttributes">
            <devdoc>
               <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="P:System.Xml.Serialization.XmlReflectionMember.MemberName">
            <devdoc>
               <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="P:System.Xml.Serialization.XmlReflectionMember.IsReturnValue">
            <devdoc>
               <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="P:System.Xml.Serialization.XmlReflectionMember.OverrideIsNullable">
            <devdoc>
               <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="T:System.Xml.Serialization.XmlRootAttribute">
            <devdoc>
               <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="M:System.Xml.Serialization.XmlRootAttribute.#ctor">
            <devdoc>
               <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="M:System.Xml.Serialization.XmlRootAttribute.#ctor(System.String)">
            <devdoc>
               <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="P:System.Xml.Serialization.XmlRootAttribute.ElementName">
            <devdoc>
               <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="P:System.Xml.Serialization.XmlRootAttribute.Namespace">
            <devdoc>
               <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="P:System.Xml.Serialization.XmlRootAttribute.DataType">
            <devdoc>
               <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="P:System.Xml.Serialization.XmlRootAttribute.IsNullable">
            <devdoc>
               <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="T:System.Xml.Serialization.XmlSchemaProviderAttribute">
            <devdoc>
               <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="M:System.Xml.Serialization.XmlSchemaProviderAttribute.#ctor(System.String)">
            <devdoc>
               <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="P:System.Xml.Serialization.XmlSchemaProviderAttribute.MethodName">
            <devdoc>
               <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="P:System.Xml.Serialization.XmlSchemaProviderAttribute.IsAny">
            <devdoc>
               <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="T:System.Xml.Serialization.XmlSerializationGeneratedCode">
            <internalonly/>
        </member>
        <member name="T:System.Xml.Serialization.XmlSerializationReader">
            <internalonly/>
        </member>
        <member name="M:System.Xml.Serialization.XmlSerializationReader.ResolveDynamicAssembly(System.String)">
            <internalonly/>
        </member>
        <member name="M:System.Xml.Serialization.XmlSerializationReader.GetXsiType">
            <devdoc>
               <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="M:System.Xml.Serialization.XmlSerializationReader.ReadNullableQualifiedName">
            <devdoc>
               <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="M:System.Xml.Serialization.XmlSerializationReader.ReadElementQualifiedName">
            <devdoc>
               <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="T:System.Xml.Serialization.XmlSerializationReader.Fixup">
            <internalonly/>
        </member>
        <member name="T:System.Xml.Serialization.XmlSerializationFixupCallback">
            <internalonly/>
        </member>
        <member name="T:System.Xml.Serialization.XmlSerializationCollectionFixupCallback">
            <internalonly/>
        </member>
        <member name="T:System.Xml.Serialization.XmlSerializationReadCallback">
            <internalonly/>
        </member>
        <member name="P:System.Xml.Serialization.XmlSerializationReaderILGen.EnsureArrayIndexRegex">
            <remarks>
            Pattern:<br/>
            <code>(?&lt;locA1&gt;[^ ]+) = .+EnsureArrayIndex[(](?&lt;locA2&gt;[^,]+), (?&lt;locI1&gt;[^,]+),[^;]+;(?&lt;locA3&gt;[^[]+)[[](?&lt;locI2&gt;[^+]+)[+][+][]]</code><br/>
            Explanation:<br/>
            <code>
             "locA1" capture group.<br/>
                 Match a character other than ' ' atomically at least once.<br/>
             Match the string " = ".<br/>
             Match a character other than '\n' greedily at least once.<br/>
             Match the string "EnsureArrayIndex(".<br/>
             "locA2" capture group.<br/>
                 Match a character other than ',' atomically at least once.<br/>
             Match the string ", ".<br/>
             "locI1" capture group.<br/>
                 Match a character other than ',' atomically at least once.<br/>
             Match ','.<br/>
             Match a character other than ';' atomically at least once.<br/>
             Match ';'.<br/>
             "locA3" capture group.<br/>
                 Match a character other than '[' atomically at least once.<br/>
             Match '['.<br/>
             "locI2" capture group.<br/>
                 Match a character other than '+' atomically at least once.<br/>
             Match the string "++]".<br/>
            </code>
            </remarks>
        </member>
        <member name="P:System.Xml.Serialization.XmlSerializationReaderILGen.P0Regex">
            <remarks>
            Pattern:<br/>
            <code>(?&lt;a&gt;[^[]+)[[](?&lt;ia&gt;.+)[]]</code><br/>
            Explanation:<br/>
            <code>
             "a" capture group.<br/>
                 Match a character other than '[' atomically at least once.<br/>
             Match '['.<br/>
             "ia" capture group.<br/>
                 Match a character other than '\n' greedily at least once.<br/>
             Match ']'.<br/>
            </code>
            </remarks>
        </member>
        <member name="P:System.Xml.Serialization.XmlSerializationReaderILGen.UnknownNodeNullAnyTypeRegex">
            <remarks>
            Pattern:<br/>
            <code>UnknownNode[(]null, @["](?&lt;qnames&gt;[^"]*)["][)];</code><br/>
            Explanation:<br/>
            <code>
             Match the string "UnknownNode(null, @\"".<br/>
             "qnames" capture group.<br/>
                 Match a character other than '"' atomically any number of times.<br/>
             Match the string "\");".<br/>
            </code>
            </remarks>
        </member>
        <member name="P:System.Xml.Serialization.XmlSerializationReaderILGen.UnknownNodeObjectEmptyRegex">
            <remarks>
            Pattern:<br/>
            <code>UnknownNode[(][(]object[)](?&lt;o&gt;[^,]+), @["](?&lt;qnames&gt;[^"]*)["][)];</code><br/>
            Explanation:<br/>
            <code>
             Match the string "UnknownNode((object)".<br/>
             "o" capture group.<br/>
                 Match a character other than ',' atomically at least once.<br/>
             Match the string ", @\"".<br/>
             "qnames" capture group.<br/>
                 Match a character other than '"' atomically any number of times.<br/>
             Match the string "\");".<br/>
            </code>
            </remarks>
        </member>
        <member name="P:System.Xml.Serialization.XmlSerializationReaderILGen.UnknownNodeObjectNullRegex">
            <remarks>
            Pattern:<br/>
            <code>UnknownNode[(][(]object[)](?&lt;o&gt;[^,]+), null[)];</code><br/>
            Explanation:<br/>
            <code>
             Match the string "UnknownNode((object)".<br/>
             "o" capture group.<br/>
                 Match a character other than ',' atomically at least once.<br/>
             Match the string ", null);".<br/>
            </code>
            </remarks>
        </member>
        <member name="P:System.Xml.Serialization.XmlSerializationReaderILGen.UnknownNodeObjectRegex">
            <remarks>
            Pattern:<br/>
            <code>UnknownNode[(][(]object[)](?&lt;o&gt;[^)]+)[)];</code><br/>
            Explanation:<br/>
            <code>
             Match the string "UnknownNode((object)".<br/>
             "o" capture group.<br/>
                 Match a character other than ')' atomically at least once.<br/>
             Match the string ");".<br/>
            </code>
            </remarks>
        </member>
        <member name="P:System.Xml.Serialization.XmlSerializationReaderILGen.ParamsReadRegex">
            <remarks>
            Pattern:<br/>
            <code>paramsRead\\[(?&lt;index&gt;[0-9]+)\\]</code><br/>
            Explanation:<br/>
            <code>
             Match the string "paramsRead[".<br/>
             "index" capture group.<br/>
                 Match a character in the set [0-9] atomically at least once.<br/>
             Match ']'.<br/>
            </code>
            </remarks>
        </member>
        <member name="T:System.Xml.Serialization.XmlSerializationWriter">
            <internalonly/>
        </member>
        <member name="P:System.Xml.Serialization.XmlSerializationWriter.Namespaces">
            <devdoc>
               <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="M:System.Xml.Serialization.XmlSerializationWriter.ResolveDynamicAssembly(System.String)">
            <internalonly/>
        </member>
        <member name="M:System.Xml.Serialization.XmlSerializationWriter.WriteNullableQualifiedNameEncoded(System.String,System.String,System.Xml.XmlQualifiedName,System.Xml.XmlQualifiedName)">
            <devdoc>
               <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="M:System.Xml.Serialization.XmlSerializationWriter.WriteNullableQualifiedNameLiteral(System.String,System.String,System.Xml.XmlQualifiedName)">
            <devdoc>
               <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="M:System.Xml.Serialization.XmlSerializationWriter.WriteElementQualifiedName(System.String,System.Xml.XmlQualifiedName)">
            <devdoc>
               <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="M:System.Xml.Serialization.XmlSerializationWriter.WriteElementQualifiedName(System.String,System.String,System.Xml.XmlQualifiedName)">
            <devdoc>
               <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="M:System.Xml.Serialization.XmlSerializationWriter.WriteNamespaceDeclarations(System.Xml.Serialization.XmlSerializerNamespaces)">
            <internalonly/>
        </member>
        <member name="T:System.Xml.Serialization.XmlSerializationWriteCallback">
            <internalonly/>
        </member>
        <member name="T:System.Xml.Serialization.XmlSerializerNamespaces">
            <devdoc>
               <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="M:System.Xml.Serialization.XmlSerializerNamespaces.#ctor">
            <devdoc>
               <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="M:System.Xml.Serialization.XmlSerializerNamespaces.#ctor(System.Xml.Serialization.XmlSerializerNamespaces)">
            <internalonly/>
            <devdoc>
               <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="M:System.Xml.Serialization.XmlSerializerNamespaces.#ctor(System.Xml.XmlQualifiedName[])">
            <devdoc>
               <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="M:System.Xml.Serialization.XmlSerializerNamespaces.#ctor(System.Collections.Generic.IList{System.Xml.XmlQualifiedName})">
            <devdoc>
               <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="M:System.Xml.Serialization.XmlSerializerNamespaces.Add(System.String,System.String)">
            <devdoc>
               <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="M:System.Xml.Serialization.XmlSerializerNamespaces.ToArray">
            <devdoc>
               <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="P:System.Xml.Serialization.XmlSerializerNamespaces.Count">
            <devdoc>
               <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="T:System.Xml.Serialization.XmlTextAttribute">
            <devdoc>
               <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="M:System.Xml.Serialization.XmlTextAttribute.#ctor">
            <devdoc>
               <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="M:System.Xml.Serialization.XmlTextAttribute.#ctor(System.Type)">
            <devdoc>
               <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="P:System.Xml.Serialization.XmlTextAttribute.Type">
            <devdoc>
               <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="P:System.Xml.Serialization.XmlTextAttribute.DataType">
            <devdoc>
               <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="T:System.Xml.Serialization.XmlTypeAttribute">
            <devdoc>
               <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="M:System.Xml.Serialization.XmlTypeAttribute.#ctor">
            <devdoc>
               <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="M:System.Xml.Serialization.XmlTypeAttribute.#ctor(System.String)">
            <devdoc>
               <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="P:System.Xml.Serialization.XmlTypeAttribute.AnonymousType">
            <devdoc>
               <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="P:System.Xml.Serialization.XmlTypeAttribute.IncludeInSchema">
            <devdoc>
               <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="P:System.Xml.Serialization.XmlTypeAttribute.TypeName">
            <devdoc>
               <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="P:System.Xml.Serialization.XmlTypeAttribute.Namespace">
            <devdoc>
               <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="T:System.Xml.Serialization.XmlTypeMapping">
            <devdoc>
               <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="P:System.Xml.Serialization.XmlTypeMapping.TypeName">
            <devdoc>
               <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="P:System.Xml.Serialization.XmlTypeMapping.TypeFullName">
            <devdoc>
               <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="P:System.Xml.Serialization.XmlTypeMapping.XsdTypeName">
            <devdoc>
               <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="P:System.Xml.Serialization.XmlTypeMapping.XsdTypeNamespace">
            <devdoc>
               <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="P:System.Xml.Serialization.XmlAttributeEventArgs.LineNumber">
            <summary>
            Gets the current line number.
            </summary>
        </member>
        <member name="P:System.Xml.Serialization.XmlAttributeEventArgs.LinePosition">
            <summary>
            Gets the current line position.
            </summary>
        </member>
        <member name="P:System.Xml.Serialization.XmlAttributeEventArgs.ExpectedAttributes">
            <summary>
            List the qnames of attributes expected in the current context.
            </summary>
        </member>
        <member name="P:System.Xml.Serialization.XmlElementEventArgs.ExpectedElements">
            <summary>
            List of qnames of elements expected in the current context.
            </summary>
        </member>
        <member name="P:System.Xml.Serialization.XmlNodeEventArgs.LineNumber">
            <summary>
            Gets the current line number.
            </summary>
        </member>
        <member name="P:System.Xml.Serialization.XmlNodeEventArgs.LinePosition">
            <summary>
            Gets the current line position.
            </summary>
        </member>
        <member name="T:System.Xml.ValidateNames">
            <summary>
            Contains various static functions and methods for parsing and validating:
                NCName (not namespace-aware, no colons allowed)
                QName (prefix:local-name)
            </summary>
        </member>
        <member name="M:System.Xml.ValidateNames.ParseNmtoken(System.String,System.Int32)">
            <summary>
            Attempts to parse the input string as an Nmtoken (see the XML spec production [7] &amp;&amp; XML Namespaces spec).
            Quits parsing when an invalid Nmtoken char is reached or the end of string is reached.
            Returns the number of valid Nmtoken chars that were parsed.
            </summary>
        </member>
        <member name="M:System.Xml.ValidateNames.ParseNmtokenNoNamespaces(System.String,System.Int32)">
            <summary>
            Attempts to parse the input string as an Nmtoken (see the XML spec production [7]) without taking
            into account the XML Namespaces spec. What it means is that the ':' character is allowed at any
            position and any number of times in the token.
            Quits parsing when an invalid Nmtoken char is reached or the end of string is reached.
            Returns the number of valid Nmtoken chars that were parsed.
            </summary>
        </member>
        <member name="M:System.Xml.ValidateNames.ParseNameNoNamespaces(System.String,System.Int32)">
            <summary>
            Attempts to parse the input string as a Name without taking into account the XML Namespaces spec.
            What it means is that the ':' character does not delimiter prefix and local name, but it is a regular
            name character, which is allowed to appear at any position and any number of times in the name.
            Quits parsing when an invalid Name char is reached or the end of string is reached.
            Returns the number of valid Name chars that were parsed.
            </summary>
        </member>
        <member name="M:System.Xml.ValidateNames.ParseNCName(System.String,System.Int32)">
            <summary>
            Attempts to parse the input string as an NCName (see the XML Namespace spec).
            Quits parsing when an invalid NCName char is reached or the end of string is reached.
            Returns the number of valid NCName chars that were parsed.
            </summary>
        </member>
        <member name="M:System.Xml.ValidateNames.ParseNCNameThrow(System.String)">
            <summary>
            Calls parseName and throws exception if the resulting name is not a valid NCName.
            Returns the input string if there is no error.
            </summary>
        </member>
        <member name="M:System.Xml.ValidateNames.ParseNCNameInternal(System.String,System.Boolean)">
            <summary>
            Calls parseName and returns false or throws exception if the resulting name is not
            a valid NCName.  Returns the input string if there is no error.
            </summary>
        </member>
        <member name="M:System.Xml.ValidateNames.ParseQName(System.String,System.Int32,System.Int32@)">
            <summary>
            Attempts to parse the input string as a QName (see the XML Namespace spec).
            Quits parsing when an invalid QName char is reached or the end of string is reached.
            Returns the number of valid QName chars that were parsed.
            Sets colonOffset to the offset of a colon character if it exists, or 0 otherwise.
            </summary>
        </member>
        <member name="M:System.Xml.ValidateNames.ParseQNameThrow(System.String)">
            <summary>
            Calls parseQName and throws exception if the resulting name is not a valid QName.
            Returns the colon offset in the name.
            </summary>
        </member>
        <member name="M:System.Xml.ValidateNames.ParseQNameThrow(System.String,System.String@,System.String@)">
            <summary>
            Calls parseQName and throws exception if the resulting name is not a valid QName.
            Returns the prefix and local name parts.
            </summary>
        </member>
        <member name="M:System.Xml.ValidateNames.ParseNameTestThrow(System.String,System.String@,System.String@)">
            <summary>
            Parses the input string as a NameTest (see the XPath spec), returning the prefix and
            local name parts.  Throws an exception if the given string is not a valid NameTest.
            If the NameTest contains a star, null values for localName (case NCName':*'), or for
            both localName and prefix (case '*') are returned.
            </summary>
        </member>
        <member name="M:System.Xml.ValidateNames.ThrowInvalidName(System.String,System.Int32,System.Int32)">
            <summary>
            Throws an invalid name exception.
            </summary>
            <param name="s">String that was parsed.</param>
            <param name="offsetStartChar">Offset in string where parsing began.</param>
            <param name="offsetBadChar">Offset in string where parsing failed.</param>
        </member>
        <member name="M:System.Xml.ValidateNames.StartsWithXml(System.String)">
            <summary>
            Returns true if "prefix" starts with the characters 'x', 'm', 'l' (case-insensitive).
            </summary>
        </member>
        <member name="M:System.Xml.ValidateNames.IsReservedNamespace(System.String)">
            <summary>
            Returns true if "s" is a namespace that is reserved by Xml 1.0 or Namespace 1.0.
            </summary>
        </member>
        <member name="M:System.Xml.ValidateNames.ValidateNameThrow(System.String,System.String,System.String,System.Xml.XPath.XPathNodeType,System.Xml.ValidateNames.Flags)">
            <summary>
            Throw if the specified name parts are not valid according to the rules of "nodeKind".  Check only rules that are
            specified by the Flags.
            NOTE: Namespaces should be passed using a prefix, ns pair.  "localName" is always string.Empty.
            </summary>
        </member>
        <member name="M:System.Xml.ValidateNames.ValidateName(System.String,System.String,System.String,System.Xml.XPath.XPathNodeType,System.Xml.ValidateNames.Flags)">
            <summary>
            Return false if the specified name parts are not valid according to the rules of "nodeKind".  Check only rules that are
            specified by the Flags.
            NOTE: Namespaces should be passed using a prefix, ns pair.  "localName" is always string.Empty.
            </summary>
        </member>
        <member name="M:System.Xml.ValidateNames.ValidateNameInternal(System.String,System.String,System.String,System.Xml.XPath.XPathNodeType,System.Xml.ValidateNames.Flags,System.Boolean)">
            <summary>
            Return false or throw if the specified name parts are not valid according to the rules of "nodeKind".  Check only rules
            that are specified by the Flags.
            NOTE: Namespaces should be passed using a prefix, ns pair.  "localName" is always string.Empty.
            </summary>
        </member>
        <member name="M:System.Xml.ValidateNames.CreateName(System.String,System.String)">
            <summary>
            Creates a colon-delimited qname from prefix and local name parts.
            </summary>
        </member>
        <member name="M:System.Xml.ValidateNames.SplitQName(System.String,System.String@,System.String@)">
            <summary>
            Split a QualifiedName into prefix and localname, w/o any checking.
            (Used for XmlReader/XPathNavigator MoveTo(name) methods)
            </summary>
        </member>
        <member name="T:System.Xml.XmlCharType">
            <summary>
             The XmlCharType class is used for quick character type recognition
             which is optimized for the first 127 ascii characters.
            </summary>
        </member>
        <member name="T:System.Xml.XmlConvert">
            <devdoc>
               Encodes and decodes XML names according to
               the "Encoding of arbitrary Unicode Characters in XML Names" specification.
            </devdoc>
        </member>
        <member name="M:System.Xml.XmlConvert.EncodeName(System.String)">
            <devdoc>
               <para>
                  Converts names, such
                  as DataTable or
                  DataColumn names, that contain characters that are not permitted in
                  XML names to valid names.</para>
            </devdoc>
        </member>
        <member name="M:System.Xml.XmlConvert.EncodeNmToken(System.String)">
            <devdoc>
               <para> Verifies the name is valid
                  according to production [7] in the XML spec.</para>
            </devdoc>
        </member>
        <member name="M:System.Xml.XmlConvert.EncodeLocalName(System.String)">
            <devdoc>
               <para>Converts names, such as DataTable or DataColumn names, that contain
                  characters that are not permitted in XML names to valid names.</para>
            </devdoc>
        </member>
        <member name="M:System.Xml.XmlConvert.DecodeName(System.String)">
            <devdoc>
               <para>
                  Transforms an XML name into an object name (such as DataTable or DataColumn).</para>
            </devdoc>
        </member>
        <member name="P:System.Xml.XmlConvert.DecodeCharRegex">
            <remarks>
            Pattern:<br/>
            <code>_[Xx][0-9a-fA-F]{4}(?:_|[0-9a-fA-F]{4}_)</code><br/>
            Explanation:<br/>
            <code>
             Match '_'.<br/>
             Match a character in the set [Xx].<br/>
             Match a character in the set [0-9A-Fa-f] exactly 4 times.<br/>
             Match with 2 alternative expressions, atomically.<br/>
                 Match '_'.<br/>
                 Match a sequence of expressions.<br/>
                     Match a character in the set [0-9A-Fa-f] exactly 4 times.<br/>
                     Match '_'.<br/>
            </code>
            </remarks>
        </member>
        <member name="P:System.Xml.XmlConvert.EncodeCharRegex">
            <remarks>
            Pattern:<br/>
            <code>(?&lt;=_)[Xx][0-9a-fA-F]{4}(?:_|[0-9a-fA-F]{4}_)</code><br/>
            Explanation:<br/>
            <code>
             Zero-width positive lookbehind.<br/>
                 Match '_' right-to-left.<br/>
             Match a character in the set [Xx].<br/>
             Match a character in the set [0-9A-Fa-f] exactly 4 times.<br/>
             Match with 2 alternative expressions, atomically.<br/>
                 Match '_'.<br/>
                 Match a sequence of expressions.<br/>
                     Match a character in the set [0-9A-Fa-f] exactly 4 times.<br/>
                     Match '_'.<br/>
            </code>
            </remarks>
        </member>
        <member name="M:System.Xml.XmlConvert.VerifyName(System.String)">
            <devdoc>
               <para>
               </para>
            </devdoc>
        </member>
        <member name="M:System.Xml.XmlConvert.VerifyNCName(System.String)">
            <devdoc>
               <para>
               </para>
            </devdoc>
        </member>
        <member name="M:System.Xml.XmlConvert.VerifyTOKEN(System.String)">
            <devdoc>
               <para>
               </para>
            </devdoc>
        </member>
        <member name="M:System.Xml.XmlConvert.VerifyNMTOKEN(System.String)">
            <devdoc>
               <para>
               </para>
            </devdoc>
        </member>
        <member name="T:System.Xml.XmlException">
            <devdoc>
               <para>Returns detailed information about the last parse error, including the error
                  number, line number, character position, and a text description.</para>
            </devdoc>
        </member>
        <member name="T:System.Xml.XmlNamespaceScope">
            <devdoc>
               <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="F:System.Xml.XmlNamespaceScope.All">
            <devdoc>
               <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="F:System.Xml.XmlNamespaceScope.ExcludeXml">
            <devdoc>
               <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="F:System.Xml.XmlNamespaceScope.Local">
            <devdoc>
               <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="T:System.Xml.XmlNameTable">
            <devdoc>
               <para> Table of atomized string objects. This provides an
                  efficient means for the XML parser to use the same string object for all
                  repeated element and attribute names in an XML document. This class is
               <see langword='abstract'/>
               .</para>
            </devdoc>
        </member>
        <member name="M:System.Xml.XmlNameTable.Get(System.Char[],System.Int32,System.Int32)">
            <devdoc>
               <para>Gets the atomized String object containing the same
                  chars as the specified range of chars in the given char array.</para>
            </devdoc>
        </member>
        <member name="M:System.Xml.XmlNameTable.Get(System.String)">
            <devdoc>
               <para>
                  Gets the atomized String object containing the same
                  value as the specified string.
               </para>
            </devdoc>
        </member>
        <member name="M:System.Xml.XmlNameTable.Add(System.Char[],System.Int32,System.Int32)">
            <devdoc>
               <para>Creates a new atom for the characters at the specified range
                  of characters in the specified string.</para>
            </devdoc>
        </member>
        <member name="M:System.Xml.XmlNameTable.Add(System.String)">
            <devdoc>
               <para>
                  Creates a new atom for the specified string.
               </para>
            </devdoc>
        </member>
        <member name="T:System.Xml.XmlNodeType">
            <devdoc>
               Specifies the type of node.
            </devdoc>
        </member>
        <member name="F:System.Xml.XmlNodeType.None">
            <devdoc>
               For XPathNavigator, cursor is not positioned
               on a node.
            </devdoc>
        </member>
        <member name="F:System.Xml.XmlNodeType.Element">
            <devdoc>
               <para>
                  An Element.
               </para>
               <para>
                  Example XML: &lt;Name&gt;
               </para>
               An Element node can have
               the following child node types: Element, Text, Comment, ProcessingInstruction,
               CDATA, and EntityReference. The Element node can be the child of the Document,
               DocumentFragment, EntityReference, and Element nodes.
            </devdoc>
        </member>
        <member name="F:System.Xml.XmlNodeType.Attribute">
            <devdoc>
               <para>
                  An
                  Attribute.
               </para>
               <para>
                  Example XML: id='123'
               </para>
               <para>
                  An Attribute node can have the following child node types: Text and
                  EntityReference. The Attribute node does not appear as the child node of any
                  other node type; note that it is not considered a child node of an Element.
               </para>
            </devdoc>
        </member>
        <member name="F:System.Xml.XmlNodeType.Text">
            <devdoc>
               <para>
                  The
                  text content of an element.
               </para>
               <para>
                  A Text node cannot have any child nodes. The Text node can appear as the
                  child node of the Attribute, DocumentFragment, Element, and EntityReference
                  nodes.
               </para>
            </devdoc>
        </member>
        <member name="F:System.Xml.XmlNodeType.CDATA">
            <devdoc>
               A CDATA section.
               Example XML: &lt;![CDATA[my escaped text]]&gt;
               CDATA sections are used to escape blocks of text that would otherwise be
               recognized as markup. A CDATASection node cannot have any child nodes. The
               CDATASection node can appear as the child of the DocumentFragment,
               EntityReference, and Element nodes.
            </devdoc>
        </member>
        <member name="F:System.Xml.XmlNodeType.EntityReference">
            <devdoc>
               <para>A reference to an entity.</para>
               <para>Example XML: &amp;foo;</para>
               <para>This applies to all entities, including character entity references. An
                  EntityReference node can have the following child node types: Element,
                  ProcessingInstruction, Comment, Text, CDATASection, and EntityReference. The
                  EntityReference node can appear as the child of the Attribute, DocumentFragment,
                  Element, and EntityReference nodes.</para>
            </devdoc>
        </member>
        <member name="F:System.Xml.XmlNodeType.Entity">
            <devdoc>
               <para>An entity declaration.</para>
               <para>Example XML: &lt;!ENTITY ...&gt;</para>
               <para>An Entity node can have child nodes that represent the expanded entity (for
                  example, Text and EntityReference nodes). The Entity node can appear as the
                  child of the DocumentType node.</para>
            </devdoc>
        </member>
        <member name="F:System.Xml.XmlNodeType.ProcessingInstruction">
            <devdoc>
               <para>
                  A processing instruction (PI).
               </para>
               <para>
                  Example XML: &lt;?pi test?&gt;
               </para>
               <para>
                  A PI node cannot have any child nodes. The PI node can
                  appear as the child of the Document, DocumentFragment, Element, and
                  EntityReference nodes.
               </para>
            </devdoc>
        </member>
        <member name="F:System.Xml.XmlNodeType.Comment">
            <devdoc>
               <para>
                  A Comment.
               </para>
               <para>
                  Example XML: &lt;!-- my comment --&gt;
               </para>
               <para>
                  A Comment node cannot have any child nodes. The Comment node can appear as
                  the child of the Document, DocumentFragment, Element, and EntityReference
                  nodes.
               </para>
            </devdoc>
        </member>
        <member name="F:System.Xml.XmlNodeType.Document">
            <devdoc>
               <para>
                  A document object, which, as the root of the document tree, provides access
                  to the entire XML document.
               </para>
               <para>
                  A Document node can have the following child node types: Element (maximum of
                  one), ProcessingInstruction, Comment, and DocumentType. The Document node cannot
                  appear as the child of any node types.
               </para>
            </devdoc>
        </member>
        <member name="F:System.Xml.XmlNodeType.DocumentType">
            <devdoc>
               <para>
                  The document type declaration, indicated by the &lt;!DOCTYPE&gt; tag.
               </para>
               <para>
                  Example XML: &lt;!DOCTYPE ...&gt;
               </para>
               <para>
                  A DocumentType node can have the following child node types: Notation and
                  Entity. The DocumentType node can appear as the child of the Document node.
               </para>
            </devdoc>
        </member>
        <member name="F:System.Xml.XmlNodeType.DocumentFragment">
            <devdoc>
               <para>
                  A document fragment.
               </para>
               <para>
                  The DocumentFragment node associates a node or subtree with a document
                  without actually being contained within the document. A DocumentFragment node
                  can have the following child node types: Element, ProcessingInstruction,
                  Comment, Text, CDATASection, and EntityReference. The DocumentFragment node
                  cannot appear as the child of any node types.
               </para>
            </devdoc>
        </member>
        <member name="F:System.Xml.XmlNodeType.Notation">
            <devdoc>
               <para>
                  A notation in the document type declaration.
               </para>
               <para>
                  Example XML: &lt;!NOTATION ...&gt;
               </para>
               <para>
                  A Notation node cannot have any child nodes. The Notation node can appear as
                  the child of the DocumentType node.
               </para>
            </devdoc>
        </member>
        <member name="F:System.Xml.XmlNodeType.Whitespace">
            <devdoc>
               <para>
                  Whitespace between markup.
               </para>
            </devdoc>
        </member>
        <member name="F:System.Xml.XmlNodeType.SignificantWhitespace">
            <devdoc>
               <para>
                  Whitespace between markup in a mixed content model.
               </para>
            </devdoc>
        </member>
        <member name="F:System.Xml.XmlNodeType.EndElement">
            <devdoc>
               <para>Returned when XmlReader gets to the end of an element.</para>
               <para>Example XML: &lt;/foo&gt;</para>
            </devdoc>
        </member>
        <member name="F:System.Xml.XmlNodeType.EndEntity">
            <devdoc>
               <para>Returned when XmlReader gets to the end of the entity
                  replacement as a result of a call to <see cref='M:System.Xml.XmlReader.ResolveEntity'/>
                  .</para>
            </devdoc>
        </member>
        <member name="F:System.Xml.XmlNodeType.XmlDeclaration">
            <devdoc>
               <para>
                  The XML declaration node..
               </para>
               <para>
                  Example XML: &lt;?xml version='1.0'?&gt;;
               </para>
               <para>
                   This has to be the first node in the document. It can have no children.
                   It is a child of the root node. It can have attributes that provide version
                   and encoding information.
               </para>
            </devdoc>
        </member>
        <member name="T:System.Xml.XmlQualifiedName">
            <devdoc>
               <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="F:System.Xml.XmlQualifiedName.Empty">
            <devdoc>
               <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="M:System.Xml.XmlQualifiedName.#ctor">
            <devdoc>
               <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="M:System.Xml.XmlQualifiedName.#ctor(System.String)">
            <devdoc>
               <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="M:System.Xml.XmlQualifiedName.#ctor(System.String,System.String)">
            <devdoc>
               <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="P:System.Xml.XmlQualifiedName.Namespace">
            <devdoc>
               <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="P:System.Xml.XmlQualifiedName.Name">
            <devdoc>
               <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="M:System.Xml.XmlQualifiedName.GetHashCode">
            <devdoc>
               <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="P:System.Xml.XmlQualifiedName.IsEmpty">
            <devdoc>
               <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="M:System.Xml.XmlQualifiedName.ToString">
            <devdoc>
               <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="M:System.Xml.XmlQualifiedName.Equals(System.Object)">
            <devdoc>
               <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="M:System.Xml.XmlQualifiedName.op_Equality(System.Xml.XmlQualifiedName,System.Xml.XmlQualifiedName)">
            <devdoc>
               <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="M:System.Xml.XmlQualifiedName.op_Inequality(System.Xml.XmlQualifiedName,System.Xml.XmlQualifiedName)">
            <devdoc>
               <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="M:System.Xml.XmlQualifiedName.ToString(System.String,System.String)">
            <devdoc>
               <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="T:System.Xml.XmlReservedNs">
            <summary>
            This class defines a set of common XML namespaces for sharing across multiple source files.
            </summary>
        </member>
        <member name="T:System.Xml.XmlResolver">
            <devdoc>
               <para>Resolves external XML resources named by a Uniform
                  Resource Identifier (URI). This class is <see langword='abstract'/>
                  .</para>
            </devdoc>
        </member>
        <member name="M:System.Xml.XmlResolver.GetEntity(System.Uri,System.String,System.Type)">
            <devdoc>
               <para>Maps a
                  URI to an Object containing the actual resource.</para>
            </devdoc>
        </member>
        <member name="M:System.Xml.XmlResolver.ResolveUri(System.Uri,System.String)">
            <devdoc>
               <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="P:System.Xml.XmlResolver.Credentials">
            <devdoc>
               <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="P:System.Xml.XmlResolver.FileSystemResolver">
            <summary>
            Gets an XML resolver which resolves only file system URIs.
            </summary>
            <value>An XML resolver which resolves only file system URIs.</value>
            <remarks>
            Calling <see cref="M:System.Xml.XmlResolver.GetEntity(System.Uri,System.String,System.Type)"/> or <see cref="M:System.Xml.XmlResolver.GetEntityAsync(System.Uri,System.String,System.Type)"/> on the
            <see cref="T:System.Xml.XmlResolver"/> instance returned by this property will resolve only URIs which scheme is file.
            </remarks>
        </member>
        <member name="P:System.Xml.XmlResolver.ThrowingResolver">
             <summary>
             Gets an XML resolver which forbids entity resolution.
             </summary>
             <value>An XML resolver which forbids entity resolution.</value>
             <remarks>
             Calling <see cref="M:System.Xml.XmlResolver.GetEntity(System.Uri,System.String,System.Type)"/> or <see cref="M:System.Xml.XmlResolver.GetEntityAsync(System.Uri,System.String,System.Type)"/> on the
             <see cref="T:System.Xml.XmlResolver"/> instance returned by this property is forbidden
             and will result in <see cref="T:System.Xml.XmlException"/> being thrown.
            
             Use <see cref="P:System.Xml.XmlResolver.ThrowingResolver"/> when external entity resolution must be
             prohibited, even when DTD processing is otherwise enabled.
             </remarks>
        </member>
        <member name="T:System.Xml.IDtdInfo">
            <summary>
            This is an interface for a compiled DTD information.
            It exposes information and functionality that XmlReader need in order to be able
            to expand entities, add default attributes and correctly normalize attribute values
            according to their data types.
            </summary>
        </member>
        <member name="P:System.Xml.IDtdInfo.Name">
            <summary>
            DOCTYPE name
            </summary>
        </member>
        <member name="P:System.Xml.IDtdInfo.InternalDtdSubset">
            <summary>
            Internal DTD subset as specified in the XML document
            </summary>
        </member>
        <member name="P:System.Xml.IDtdInfo.HasDefaultAttributes">
            <summary>
            Returns true if the DTD contains any declaration of a default attribute
            </summary>
        </member>
        <member name="P:System.Xml.IDtdInfo.HasNonCDataAttributes">
            <summary>
            Returns true if the DTD contains any declaration of an attribute
            whose type is other than CDATA
            </summary>
        </member>
        <member name="M:System.Xml.IDtdInfo.LookupAttributeList(System.String,System.String)">
            <summary>
            Looks up a DTD attribute list definition by its name.
            </summary>
            <param name="prefix">The prefix of the attribute list to look for</param>
            <param name="localName">The local name of the attribute list to look for</param>
            <returns>Interface representing an attribute list or null if none was found.</returns>
        </member>
        <member name="M:System.Xml.IDtdInfo.GetAttributeLists">
            <summary>
            Returns an enumerator of all attribute lists defined in the DTD.
            </summary>
        </member>
        <member name="M:System.Xml.IDtdInfo.LookupEntity(System.String)">
            <summary>
            Looks up a general DTD entity by its name.
            </summary>
            <param name="name">The name of the entity to look for</param>
            <returns>Interface representing an entity or null if none was found.</returns>
        </member>
        <member name="T:System.Xml.IDtdAttributeListInfo">
            <summary>
            Exposes information about attributes declared in an attribute list in a DTD
            that XmlReader need in order to be able to add default attributes
            and correctly normalize attribute values according to their data types.
            </summary>
        </member>
        <member name="P:System.Xml.IDtdAttributeListInfo.Prefix">
            <summary>
            Prefix of an element this attribute list belongs to.
            </summary>
        </member>
        <member name="P:System.Xml.IDtdAttributeListInfo.LocalName">
            <summary>
            Local name of an element this attribute list belongs to.
            </summary>
        </member>
        <member name="P:System.Xml.IDtdAttributeListInfo.HasNonCDataAttributes">
            <summary>
            Returns true if the attribute list has some declared attributes with
            type other than CDATA.
            </summary>
        </member>
        <member name="M:System.Xml.IDtdAttributeListInfo.LookupAttribute(System.String,System.String)">
            <summary>
            Looks up a DTD attribute definition by its name.
            </summary>
            <param name="prefix">The prefix of the attribute to look for</param>
            <param name="localName">The local name of the attribute to look for</param>
            <returns>Interface representing an attribute or null is none was found</returns>
        </member>
        <member name="M:System.Xml.IDtdAttributeListInfo.LookupDefaultAttributes">
            <summary>
            Returns enumeration of all default attributes
            defined in this attribute list.
            </summary>
            <returns>Enumerator of default attribute.</returns>
        </member>
        <member name="M:System.Xml.IDtdAttributeListInfo.LookupIdAttribute">
            <summary>
            Looks up a ID attribute defined in the attribute list. Returns
            null if the attribute list does define an ID attribute.
            </summary>
        </member>
        <member name="T:System.Xml.IDtdAttributeInfo">
            <summary>
            Exposes information about an attribute declared in a DTD
            that XmlReader need in order to be able to correctly normalize
            the attribute value according to its data types.
            </summary>
        </member>
        <member name="P:System.Xml.IDtdAttributeInfo.Prefix">
            <summary>
            The prefix of the attribute
            </summary>
        </member>
        <member name="P:System.Xml.IDtdAttributeInfo.LocalName">
            <summary>
            The local name of the attribute
            </summary>
        </member>
        <member name="P:System.Xml.IDtdAttributeInfo.LineNumber">
            <summary>
            The line number of the DTD attribute definition
            </summary>
        </member>
        <member name="P:System.Xml.IDtdAttributeInfo.LinePosition">
            <summary>
            The line position of the DTD attribute definition
            </summary>
        </member>
        <member name="P:System.Xml.IDtdAttributeInfo.IsNonCDataType">
            <summary>
            Returns true if the attribute is of a different type than CDATA
            </summary>
        </member>
        <member name="P:System.Xml.IDtdAttributeInfo.IsDeclaredInExternal">
            <summary>
            Returns true if the attribute was declared in an external DTD subset
            </summary>
        </member>
        <member name="P:System.Xml.IDtdAttributeInfo.IsXmlAttribute">
            <summary>
            Returns true if the attribute is xml:space or xml:lang
            </summary>
        </member>
        <member name="T:System.Xml.IDtdDefaultAttributeInfo">
            <summary>
            Exposes information about a default attribute
            declared in a DTD that XmlReader need in order to be able to add
            this attribute to the XML document (it is not present already)
            or correctly normalize the attribute value according to its data types.
            </summary>
        </member>
        <member name="P:System.Xml.IDtdDefaultAttributeInfo.DefaultValueExpanded">
            <summary>
            The expanded default value of the attribute
            the consumer assumes that all entity references
            were already resolved in the value and that the value
            is correctly normalized.
            </summary>
        </member>
        <member name="P:System.Xml.IDtdDefaultAttributeInfo.DefaultValueTyped">
            <summary>
            The typed default value of the attribute.
            </summary>
        </member>
        <member name="P:System.Xml.IDtdDefaultAttributeInfo.ValueLineNumber">
            <summary>
            The line number of the default value (in the DTD)
            </summary>
        </member>
        <member name="P:System.Xml.IDtdDefaultAttributeInfo.ValueLinePosition">
            <summary>
            The line position of the default value (in the DTD)
            </summary>
        </member>
        <member name="T:System.Xml.IDtdEntityInfo">
            <summary>
            Exposes information about a general entity
            declared in a DTD that XmlReader need in order to be able
            to expand the entity.
            </summary>
        </member>
        <member name="P:System.Xml.IDtdEntityInfo.Name">
            <summary>
            The name of the entity
            </summary>
        </member>
        <member name="P:System.Xml.IDtdEntityInfo.IsExternal">
            <summary>
            true if the entity is external (its value is in an external input)
            </summary>
        </member>
        <member name="P:System.Xml.IDtdEntityInfo.IsDeclaredInExternal">
            <summary>
            true if the entity was declared in external DTD subset
            </summary>
        </member>
        <member name="P:System.Xml.IDtdEntityInfo.IsUnparsedEntity">
            <summary>
            true if this is an unparsed entity
            </summary>
        </member>
        <member name="P:System.Xml.IDtdEntityInfo.IsParameterEntity">
            <summary>
            true if this is a parameter entity
            </summary>
        </member>
        <member name="P:System.Xml.IDtdEntityInfo.BaseUriString">
            <summary>
            The base URI of the entity value
            </summary>
        </member>
        <member name="P:System.Xml.IDtdEntityInfo.DeclaredUriString">
            <summary>
            The URI of the XML document where the entity was declared
            </summary>
        </member>
        <member name="P:System.Xml.IDtdEntityInfo.SystemId">
            <summary>
            SYSTEM identifier (URI) of the entity value - only used for external entities
            </summary>
        </member>
        <member name="P:System.Xml.IDtdEntityInfo.PublicId">
            <summary>
            PUBLIC identifier of the entity value - only used for external entities
            </summary>
        </member>
        <member name="P:System.Xml.IDtdEntityInfo.Text">
            <summary>
            Replacement text of an entity. Valid only for internal entities.
            </summary>
        </member>
        <member name="P:System.Xml.IDtdEntityInfo.LineNumber">
            <summary>
            The line number of the entity value
            </summary>
        </member>
        <member name="P:System.Xml.IDtdEntityInfo.LinePosition">
            <summary>
            The line position of the entity value
            </summary>
        </member>
        <member name="T:System.Xml.OnRemoveWriter">
            <summary>
            Event which is used when a raw writer in a processing pipeline wishes to remove itself from the pipeline and
            replace itself with another writer.
            </summary>
        </member>
        <member name="T:System.Xml.IRemovableWriter">
            <summary>
            This interface is implemented by writers which wish to remove themselves from the processing pipeline once they
            have accomplished some work.  An example would be the auto-detect writer, which removes itself from the pipeline
            once it has determined whether to use the Xml or the Html output mode.
            </summary>
        </member>
        <member name="T:System.Xml.QueryOutputWriter">
             <summary>
             This writer wraps an XmlRawWriter and inserts additional lexical information into the resulting
             Xml 1.0 document:
               1. CData sections
               2. DocType declaration
            
             It also performs well-formed document checks if standalone="yes" and/or a doc-type-decl is output.
             </summary>
        </member>
        <member name="P:System.Xml.QueryOutputWriter.NamespaceResolver">
            <summary>
            Get and set the namespace resolver that's used by this RawWriter to resolve prefixes.
            </summary>
        </member>
        <member name="M:System.Xml.QueryOutputWriter.WriteXmlDeclaration(System.Xml.XmlStandalone)">
            <summary>
            Write the xml declaration.  This must be the first call.
            </summary>
        </member>
        <member name="P:System.Xml.QueryOutputWriter.Settings">
            <summary>
            Return settings provided to factory.
            </summary>
        </member>
        <member name="M:System.Xml.QueryOutputWriter.WriteDocType(System.String,System.String,System.String,System.String)">
            <summary>
            Suppress this explicit call to WriteDocType if information was provided by XmlWriterSettings.
            </summary>
        </member>
        <member name="M:System.Xml.QueryOutputWriter.WriteStartElement(System.String,System.String,System.String)">
            <summary>
            Check well-formedness, possibly output doc-type-decl, and determine whether this element is a
            CData section element.
            </summary>
        </member>
        <member name="M:System.Xml.QueryOutputWriter.StartCDataSection">
            <summary>
            Write CData text if element is a CData element.  Return true if text should be written
            within a CData section.
            </summary>
        </member>
        <member name="M:System.Xml.QueryOutputWriter.EndCDataSection">
            <summary>
            No longer write CData text.
            </summary>
        </member>
        <member name="T:System.Xml.QueryOutputWriterV1">
             <summary>
             This writer wraps an XmlWriter that was not build using the XmlRawWriter architecture (such as XmlTextWriter or a custom XmlWriter)
             for use in the XslCompilerTransform. Depending on the Xsl stylesheet output settings (which gets transferred to this writer via the
             internal properties of XmlWriterSettings) this writer will inserts additional lexical information into the resulting Xml 1.0 document:
            
               1. CData sections
               2. DocType declaration
               3. Standalone attribute
            
             It also calls WriteStateDocument if standalone="yes" and/or a DocType declaration is written out in order to enforce document conformance
             checking.
             </summary>
        </member>
        <member name="M:System.Xml.QueryOutputWriterV1.WriteDocType(System.String,System.String,System.String,System.String)">
            <summary>
            Suppress this explicit call to WriteDocType if information was provided by XmlWriterSettings.
            </summary>
        </member>
        <member name="M:System.Xml.QueryOutputWriterV1.WriteStartElement(System.String,System.String,System.String)">
            <summary>
            Output doc-type-decl on the first element, and determine whether this element is a
            CData section element.
            </summary>
        </member>
        <member name="M:System.Xml.QueryOutputWriterV1.StartCDataSection">
            <summary>
            Write CData text if element is a CData element.  Return true if text should be written
            within a CData section.
            </summary>
        </member>
        <member name="M:System.Xml.QueryOutputWriterV1.EndCDataSection">
            <summary>
            No longer write CData text.
            </summary>
        </member>
        <member name="T:System.Xml.TernaryTreeReadOnly">
             TernaryTreeRO
             -------------
            
             Ternary tree implementation used to make fast dictionary lookups in pre-generated
             ternary trees.
            
             Note: Only strings composed of ASCII characters can exist in the tree.
        </member>
        <member name="T:System.Xml.XmlAutoDetectWriter">
            <summary>
            This writer implements XmlOutputMethod.AutoDetect.  If the first element is "html", then output will be
            directed to an Html writer.  Otherwise, output will be directed to an Xml writer.
            </summary>
        </member>
        <member name="P:System.Xml.XmlAutoDetectWriter.OnRemoveWriterEvent">
            <summary>
            This writer will raise this event once it has determined whether to replace itself with the Html or Xml writer.
            </summary>
        </member>
        <member name="M:System.Xml.XmlAutoDetectWriter.IsHtmlTag(System.String)">
            <summary>
            Return true if "tagName" == "html" (case-insensitive).
            </summary>
        </member>
        <member name="M:System.Xml.XmlAutoDetectWriter.EnsureWrappedWriter(System.Xml.XmlOutputMethod)">
            <summary>
            If a wrapped writer has not yet been created, create one.
            </summary>
        </member>
        <member name="M:System.Xml.XmlAutoDetectWriter.TextBlockCreatesWriter(System.String)">
            <summary>
            If the specified text consist only of whitespace, then cache the whitespace, as it is not enough to
            force the creation of a wrapped writer.  Otherwise, create a wrapped writer if one has not yet been
            created and return true.
            </summary>
        </member>
        <member name="M:System.Xml.XmlAutoDetectWriter.CreateWrappedWriter(System.Xml.XmlOutputMethod)">
            <summary>
            Create either the Html or Xml writer and send any cached events to it.
            </summary>
        </member>
        <member name="T:System.Xml.XmlEventCache">
            <summary>
            Caches sequence of XmlEvents so that they can be replayed later.
            </summary>
        </member>
        <member name="P:System.Xml.XmlEventCache.BaseUri">
            <summary>
            Return Base Uri of the document.
            </summary>
        </member>
        <member name="P:System.Xml.XmlEventCache.HasRootNode">
            <summary>
            Return true if the cached document has a root node, false if it's a fragment.
            </summary>
        </member>
        <member name="M:System.Xml.XmlEventCache.EventsToWriter(System.Xml.XmlWriter)">
            <summary>
            Replay all cached events to an XmlWriter.
            </summary>
        </member>
        <member name="M:System.Xml.XmlEventCache.EventsToString">
            <summary>
            Concatenate all element text and atomic value events and return the resulting string.
            </summary>
        </member>
        <member name="M:System.Xml.XmlEventCache.WriteValue(System.Object)">
            <summary>
            All other WriteValue methods are implemented by XmlWriter to delegate to WriteValue(object) or WriteValue(string), so
            only these two methods need to be implemented.
            </summary>
        </member>
        <member name="M:System.Xml.XmlEventCache.ToBytes(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Create a standalone buffer that doesn't need an index or count passed along with it.
            </summary>
        </member>
        <member name="T:System.Xml.XmlEventCache.XmlEvent">
            <summary>
            Caches information for XML events like BeginElement, String, and EndAttribute so that they can be replayed later.
            </summary>
        </member>
        <member name="T:System.Xml.XmlRawWriter">
             <summary>
             Implementations of XmlRawWriter are intended to be wrapped by the XmlWellFormedWriter.  The
             well-formed writer performs many checks in behalf of the raw writer, and keeps state that the
             raw writer otherwise would have to keep.  Therefore, the well-formed writer will call the
             XmlRawWriter using the following rules, in order to make raw writers easier to implement:
            
              1. The well-formed writer keeps a stack of element names, and always calls
                 WriteEndElement(string, string, string) instead of WriteEndElement().
              2. The well-formed writer tracks namespaces, and will pass himself in via the
                 WellformedWriter property. It is used in the XmlRawWriter's implementation of IXmlNamespaceResolver.
                 Thus, LookupPrefix does not have to be implemented.
              3. The well-formed writer tracks write states, so the raw writer doesn't need to.
              4. The well-formed writer will always call StartElementContent.
              5. The well-formed writer will always call WriteNamespaceDeclaration for namespace nodes,
                 rather than calling WriteStartAttribute(). If the writer is supporting namespace declarations in chunks
                 (SupportsNamespaceDeclarationInChunks is true), the XmlWellFormedWriter will call WriteStartNamespaceDeclaration,
                  then any method that can be used to write out a value of an attribute (WriteString, WriteChars, WriteRaw, WriteCharEntity...)
                  and then WriteEndNamespaceDeclaration - instead of just a single WriteNamespaceDeclaration call. This feature will be
                  supported by raw writers serializing to text that wish to preserve the attribute value escaping etc.
              6. The well-formed writer guarantees a well-formed document, including correct call sequences,
                 correct namespaces, and correct document rule enforcement.
              7. All element and attribute names will be fully resolved and validated.  Null will never be
                 passed for any of the name parts.
              8. The well-formed writer keeps track of xml:space and xml:lang.
              9. The well-formed writer verifies NmToken, Name, and QName values and calls WriteString().
             </summary>
             <summary>
             Implementations of XmlRawWriter are intended to be wrapped by the XmlWellFormedWriter.  The
             well-formed writer performs many checks in behalf of the raw writer, and keeps state that the
             raw writer otherwise would have to keep.  Therefore, the well-formed writer will call the
             XmlRawWriter using the following rules, in order to make raw writers easier to implement:
            
              1. The well-formed writer keeps a stack of element names, and always calls
                 WriteEndElement(string, string, string) instead of WriteEndElement().
              2. The well-formed writer tracks namespaces, and will pass himself in via the
                 WellformedWriter property. It is used in the XmlRawWriter's implementation of IXmlNamespaceResolver.
                 Thus, LookupPrefix does not have to be implemented.
              3. The well-formed writer tracks write states, so the raw writer doesn't need to.
              4. The well-formed writer will always call StartElementContent.
              5. The well-formed writer will always call WriteNamespaceDeclaration for namespace nodes,
                 rather than calling WriteStartAttribute(). If the writer is supporting namespace declarations in chunks
                 (SupportsNamespaceDeclarationInChunks is true), the XmlWellFormedWriter will call WriteStartNamespaceDeclaration,
                  then any method that can be used to write out a value of an attribute (WriteString, WriteChars, WriteRaw, WriteCharEntity...)
                  and then WriteEndNamespaceDeclaration - instead of just a single WriteNamespaceDeclaration call. This feature will be
                  supported by raw writers serializing to text that wish to preserve the attribute value escaping etc.
              6. The well-formed writer guarantees a well-formed document, including correct call sequences,
                 correct namespaces, and correct document rule enforcement.
              7. All element and attribute names will be fully resolved and validated.  Null will never be
                 passed for any of the name parts.
              8. The well-formed writer keeps track of xml:space and xml:lang.
              9. The well-formed writer verifies NmToken, Name, and QName values and calls WriteString().
             </summary>
        </member>
        <member name="M:System.Xml.XmlTextReaderImpl.RegisterConsumedCharacters(System.Int64,System.Boolean)">
            <summary>
            This method should be called every time the reader is about to consume some number of
              characters from the input. It will count it against the security counters and
              may throw if some of the security limits are exceeded.
            </summary>
            <param name="characters">Number of characters to be consumed.</param>
            <param name="inEntityReference">true if the characters are result of entity expansion.</param>
        </member>
        <member name="T:System.Xml.TriState">
            <summary>
            Three-state logic enumeration.
            </summary>
        </member>
        <member name="M:System.Xml.XmlWriterSettings.GetObjectData(System.Xml.Xsl.Runtime.XmlQueryDataWriter)">
            <summary>
            Serialize the object to BinaryWriter.
            </summary>
        </member>
        <member name="M:System.Xml.XmlWriterSettings.#ctor(System.Xml.Xsl.Runtime.XmlQueryDataReader)">
            <summary>
            Deserialize the object from BinaryReader.
            </summary>
        </member>
        <member name="P:System.Xml.XmlProcessingInstruction.Name">
            <inheritdoc />
        </member>
        <member name="P:System.Xml.XmlProcessingInstruction.LocalName">
            <inheritdoc />
        </member>
        <member name="P:System.Xml.XmlProcessingInstruction.Value">
            <inheritdoc />
        </member>
        <member name="P:System.Xml.XmlProcessingInstruction.InnerText">
            <inheritdoc />
        </member>
        <member name="P:System.Xml.XmlProcessingInstruction.NodeType">
            <inheritdoc />
        </member>
        <member name="M:System.Xml.XmlProcessingInstruction.CloneNode(System.Boolean)">
            <inheritdoc />
        </member>
        <member name="M:System.Xml.XmlProcessingInstruction.WriteTo(System.Xml.XmlWriter)">
            <inheritdoc />
        </member>
        <member name="M:System.Xml.XmlProcessingInstruction.WriteContentTo(System.Xml.XmlWriter)">
            <inheritdoc />
        </member>
        <member name="T:System.Xml.XPath.XPathDocument">
            <summary>
            XDocument follows the XPath/XQuery data model.  All nodes in the tree reference the document,
            and the document references the root node of the tree.  All namespaces are stored out-of-line,
            in an Element --> In-Scope-Namespaces map.
            </summary>
        </member>
        <member name="T:System.Xml.XPath.XPathDocument.LoadFlags">
            <summary>
            Flags that control Load behavior.
            </summary>
        </member>
        <member name="M:System.Xml.XPath.XPathDocument.#ctor">
            <summary>
            Create a new empty document.
            </summary>
        </member>
        <member name="M:System.Xml.XPath.XPathDocument.#ctor(System.Xml.XmlNameTable)">
            <summary>
            Create a new empty document.  All names should be atomized using "nameTable".
            </summary>
        </member>
        <member name="M:System.Xml.XPath.XPathDocument.#ctor(System.Xml.XmlReader)">
            <summary>
            Create a new document and load the content from the reader.
            </summary>
        </member>
        <member name="M:System.Xml.XPath.XPathDocument.#ctor(System.Xml.XmlReader,System.Xml.XmlSpace)">
            <summary>
            Create a new document from "reader", with whitespace handling controlled according to "space".
            </summary>
        </member>
        <member name="M:System.Xml.XPath.XPathDocument.#ctor(System.IO.TextReader)">
            <summary>
            Create a new document and load the content from the text reader.
            </summary>
        </member>
        <member name="M:System.Xml.XPath.XPathDocument.#ctor(System.IO.Stream)">
            <summary>
            Create a new document and load the content from the stream.
            </summary>
        </member>
        <member name="M:System.Xml.XPath.XPathDocument.#ctor(System.String)">
            <summary>
            Create a new document and load the content from the Uri.
            </summary>
        </member>
        <member name="M:System.Xml.XPath.XPathDocument.#ctor(System.String,System.Xml.XmlSpace)">
            <summary>
            Create a new document and load the content from the Uri, with whitespace handling controlled according to "space".
            </summary>
        </member>
        <member name="M:System.Xml.XPath.XPathDocument.LoadFromWriter(System.Xml.XPath.XPathDocument.LoadFlags,System.String)">
            <summary>
            Create a writer that can be used to create nodes in this document.  The root node will be assigned "baseUri", and flags
            can be passed to indicate that names should be atomized by the builder and/or a fragment should be created.
            </summary>
        </member>
        <member name="M:System.Xml.XPath.XPathDocument.LoadFromReader(System.Xml.XmlReader,System.Xml.XmlSpace)">
            <summary>
            Create a writer that can be used to create nodes in this document.  The root node will be assigned "baseUri", and flags
            can be passed to indicate that names should be atomized by the builder and/or a fragment should be created.
            </summary>
        </member>
        <member name="M:System.Xml.XPath.XPathDocument.CreateNavigator">
            <summary>
            Create a navigator positioned on the root node of the document.
            </summary>
        </member>
        <member name="P:System.Xml.XPath.XPathDocument.NameTable">
            <summary>
            Return the name table used to atomize all name parts (local name, namespace uri, prefix).
            </summary>
        </member>
        <member name="P:System.Xml.XPath.XPathDocument.HasLineInfo">
            <summary>
            Return true if line number information is recorded in the cache.
            </summary>
        </member>
        <member name="M:System.Xml.XPath.XPathDocument.GetCollapsedTextNode(MS.Internal.Xml.Cache.XPathNode[]@)">
            <summary>
            Return the singleton collapsed text node associated with the document.  One physical text node
            represents each logical text node in the document that is the only content-typed child of its
            element parent.
            </summary>
        </member>
        <member name="M:System.Xml.XPath.XPathDocument.SetCollapsedTextNode(MS.Internal.Xml.Cache.XPathNode[],System.Int32)">
            <summary>
            Set the page and index where the singleton collapsed text node is stored.
            </summary>
        </member>
        <member name="M:System.Xml.XPath.XPathDocument.GetRootNode(MS.Internal.Xml.Cache.XPathNode[]@)">
            <summary>
            Return the root node of the document.  This may not be a node of type XPathNodeType.Root if this
            is a document fragment.
            </summary>
        </member>
        <member name="M:System.Xml.XPath.XPathDocument.SetRootNode(MS.Internal.Xml.Cache.XPathNode[],System.Int32)">
            <summary>
            Set the page and index where the root node is stored.
            </summary>
        </member>
        <member name="M:System.Xml.XPath.XPathDocument.GetXmlNamespaceNode(MS.Internal.Xml.Cache.XPathNode[]@)">
            <summary>
            Every document has an implicit xmlns:xml namespace node.
            </summary>
        </member>
        <member name="M:System.Xml.XPath.XPathDocument.SetXmlNamespaceNode(MS.Internal.Xml.Cache.XPathNode[],System.Int32)">
            <summary>
            Set the page and index where the implicit xmlns:xml node is stored.
            </summary>
        </member>
        <member name="M:System.Xml.XPath.XPathDocument.AddNamespace(MS.Internal.Xml.Cache.XPathNode[],System.Int32,MS.Internal.Xml.Cache.XPathNode[],System.Int32)">
            <summary>
            Associate a namespace node with an element.
            </summary>
        </member>
        <member name="M:System.Xml.XPath.XPathDocument.LookupNamespaces(MS.Internal.Xml.Cache.XPathNode[],System.Int32,MS.Internal.Xml.Cache.XPathNode[]@)">
            <summary>
            Lookup the namespace nodes associated with an element.
            </summary>
        </member>
        <member name="M:System.Xml.XPath.XPathDocument.AddIdElement(System.String,MS.Internal.Xml.Cache.XPathNode[],System.Int32)">
            <summary>
            Add an element indexed by ID value.
            </summary>
        </member>
        <member name="M:System.Xml.XPath.XPathDocument.LookupIdElement(System.String,MS.Internal.Xml.Cache.XPathNode[]@)">
            <summary>
            Lookup the element node associated with the specified ID value.
            </summary>
        </member>
        <member name="M:System.Xml.XPath.XPathDocument.SetupReader(System.Xml.XmlTextReaderImpl)">
            <summary>
            Set properties on the reader so that it is backwards-compatible with V1.
            </summary>
        </member>
        <member name="T:System.Xml.XPath.XPathItem">
            <summary>
            Base class for XPathNavigator and XmlAtomicValue.
            </summary>
        </member>
        <member name="P:System.Xml.XPath.XPathItem.IsNode">
            <summary>
            True if this item is a node, and not an atomic value.
            </summary>
        </member>
        <member name="P:System.Xml.XPath.XPathItem.XmlType">
            <summary>
            Returns Xsd type of atomic value, or of node's content.
            </summary>
        </member>
        <member name="P:System.Xml.XPath.XPathItem.Value">
            <summary>
            Typed and untyped value accessors.
            </summary>
        </member>
        <member name="P:System.Xml.XPath.XPathNavigator.IndexInParent">
            <summary>
            Returns ordinal number of attribute, namespace or child node within its parent.
            Order is reversed for attributes and child nodes to avoid O(N**2) running time.
            This property is useful for debugging, and also used in UniqueId implementation.
            </summary>
        </member>
        <member name="T:System.Xml.XPath.XPathNavigatorReader">
            <summary>
            Reader that traverses the subtree rooted at the current position of the specified navigator.
            </summary>
        </member>
        <member name="M:System.Xml.XPath.XPathNavigatorReader.ToXmlNodeType(System.Xml.XPath.XPathNodeType)">
            <summary>
            Translates an XPathNodeType value into the corresponding XmlNodeType value.
            XPathNodeType.Whitespace and XPathNodeType.SignificantWhitespace are mapped into XmlNodeType.Text.
            </summary>
        </member>
        <member name="P:System.Xml.XPath.XPathNavigatorReader.Depth">
            <summary>
            Current depth in subtree.
            </summary>
        </member>
        <member name="M:System.Xml.XPath.XPathNavigatorReader.Read">
            <summary>
            Move to the next reader state.  Return false if that is ReaderState.Closed.
            </summary>
        </member>
        <member name="M:System.Xml.XPath.XPathNavigatorReader.Close">
            <summary>
            End reading by transitioning into the Closed state.
            </summary>
        </member>
        <member name="M:System.Xml.XPath.XPathNavigatorReader.SetEOF">
            <summary>
            set reader to EOF state
            </summary>
        </member>
        <member name="T:System.Xml.XPath.XmlEmptyNavigator">
            <summary>
            The XmlEmptyNavigator exposes a document node with no children.
            Only one XmlEmptyNavigator exists per AppDomain (Singleton).  That's why the constructor is private.
            Use the Singleton property to get the EmptyNavigator.
            </summary>
        </member>
        <member name="T:System.Xml.XPath.XPathNodeIterator.Enumerator">
            <summary>
            Implementation of a resettable enumerator that is linked to the XPathNodeIterator used to create it.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.XslCompiledTransform.Reset">
            <summary>
            This function is called on every recompilation to discard all previous results
            </summary>
        </member>
        <member name="P:System.Xml.Xsl.XslCompiledTransform.OutputSettings">
            <summary>
            Writer settings specified in the stylesheet
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.XslCompiledTransform.GetFirstError">
            <summary>
            Returns the first compiler error except warnings
            </summary>
        </member>
        <member name="T:System.Xml.Xsl.IlGen.XmlILStorageMethods">
            <summary>
            List of all XmlIL runtime constructors.
            </summary>
        </member>
        <member name="T:System.Xml.Xsl.IlGen.XmlILConstructors">
            <summary>
            List of all XmlIL runtime constructors.
            </summary>
        </member>
        <member name="T:System.Xml.Xsl.IlGen.XmlILMethods">
            <summary>
            List of all XmlIL runtime methods.
            </summary>
        </member>
        <member name="T:System.Xml.Xsl.IlGen.GenerateNameType">
            <summary>
            When named nodes are constructed, there are several possible ways for their names to be created.
            </summary>
        </member>
        <member name="T:System.Xml.Xsl.IlGen.GenerateHelper">
            <summary>
            Contains helper methods used during the code generation phase.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.IlGen.GenerateHelper.#ctor(System.Xml.Xsl.IlGen.XmlILModule,System.Boolean)">
            <summary>
            Cache metadata used during code-generation phase.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.IlGen.GenerateHelper.MethodBegin(System.Reflection.MethodBase,System.Xml.Xsl.ISourceLineInfo,System.Boolean)">
            <summary>
            Begin generating code within a new method.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.IlGen.GenerateHelper.MethodEnd">
            <summary>
            Generate "ret" instruction and branch fixup jump table.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.IlGen.GenerateHelper.CallSyncToNavigator">
            <summary>
            Call a static method which attempts to reuse a navigator.
            </summary>
        </member>
        <member name="P:System.Xml.Xsl.IlGen.GenerateHelper.StaticData">
            <summary>
            This internal class manages literal names, literal types, and storage for global variables.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.IlGen.GenerateHelper.LoadInteger(System.Int32)">
            <summary>
            Generate the optimal Ldc_I4 instruction based on intVal.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.IlGen.GenerateHelper.DeclareLocal(System.String,System.Type)">
            <summary>
            Generate a new local variable.  Add a numeric suffix to name that ensures that all
            local variable names will be unique (for readability).
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.IlGen.GenerateHelper.BranchAndMark(System.Reflection.Emit.Label,System.Reflection.Emit.Label)">
            <summary>
            Branch to lblBranch and anchor lblMark.  If lblBranch = lblMark, then no need
            to generate a "br" to the next instruction.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.IlGen.GenerateHelper.TestAndBranch(System.Int32,System.Reflection.Emit.Label,System.Reflection.Emit.OpCode)">
            <summary>
            Compare the top value on the stack with the specified i4 using the specified relational
            comparison opcode, and branch to lblBranch if the result is true.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.IlGen.GenerateHelper.ConvBranchToBool(System.Reflection.Emit.Label,System.Boolean)">
            <summary>
            Assume a branch instruction has already been issued.  If isTrueBranch is true, then the
            true path is linked to lblBranch.  Otherwise, the false path is linked to lblBranch.
            Convert this "branching" boolean logic into an explicit push of 1 or 0 onto the stack.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.IlGen.GenerateHelper.TreatAs(System.Type,System.Type)">
            <summary>
            Assume that an object reference is on the IL stack.  Change the static Clr type from "clrTypeSrc" to "clrTypeDst"
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.IlGen.GenerateHelper.DebugStartScope">
            <summary>
            Begin a new variable debugging scope.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.IlGen.GenerateHelper.DebugEndScope">
            <summary>
            End a new debugging scope.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.IlGen.GenerateHelper.DebugSequencePoint(System.Xml.Xsl.ISourceLineInfo)">
            <summary>
            Correlate the current IL generation position with the current source position.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.IlGen.GenerateHelper.EmitUnconditionalBranch(System.Reflection.Emit.OpCode,System.Reflection.Emit.Label)">
             <summary>
             Unconditional branch opcodes (OpCode.Br, OpCode.Br_S) can lead to unverifiable code in the following cases:
            
               # DEAD CODE CASE
                 ldc_i4  1       # Stack depth == 1
                 br      Label2
               Label1:
                 nop             # Dead code, so IL rules assume stack depth == 0.  This causes a verification error,
                                 # since next instruction has depth == 1
               Label2:
                 pop             # Stack depth == 1
                 ret
            
               # LATE BRANCH CASE
                 ldc_i4  1       # Stack depth == 1
                 br      Label2
               Label1:
                 nop             # Not dead code, but since branch comes from below, IL rules assume stack depth = 0.
                                 # This causes a verification error, since next instruction has depth == 1
               Label2:
                 pop             # Stack depth == 1
                 ret
               Label3:
                 br      Label1  # Stack depth == 1
            
             This method works around the above limitations by using Brtrue or Brfalse in the following way:
            
                 ldc_i4  1       # Since this test is always true, this is a way of creating a path to the code that
                 brtrue  Label   # follows the brtrue instruction.
            
                 ldc_i4  1       # Since this test is always false, this is a way of creating a path to the code that
                 brfalse Label   # starts at Label.
            
             1. If opcode == Brtrue or Brtrue_S, then 1 will be pushed and brtrue instruction will be generated.
             2. If opcode == Brfalse or Brfalse_S, then 1 will be pushed and brfalse instruction will be generated.
             3. If opcode == Br or Br_S, then a br instruction will be generated.
             </summary>
        </member>
        <member name="T:System.Xml.Xsl.IlGen.ItemLocation">
            <summary>
            Type of location in which iterator items are stored.
            </summary>
        </member>
        <member name="T:System.Xml.Xsl.IlGen.BranchingContext">
            <summary>
            None--Not in a branching context
            True--Branch if boolean expression evaluates to true
            False--Branch if boolean expression evaluates to false
            </summary>
        </member>
        <member name="T:System.Xml.Xsl.IlGen.StorageDescriptor">
            <summary>
            Describes the Clr type and location of items returned by an iterator.
            This struct is meant to be immutable.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.IlGen.StorageDescriptor.None">
            <summary>
            Create default, empty StorageDescriptor.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.IlGen.StorageDescriptor.Stack(System.Type,System.Boolean)">
            <summary>
            Create a StorageDescriptor for an item located on the stack.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.IlGen.StorageDescriptor.Parameter(System.Int32,System.Type,System.Boolean)">
            <summary>
            Create a StorageDescriptor for an item which is a parameter to the current method.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.IlGen.StorageDescriptor.Local(System.Reflection.Emit.LocalBuilder,System.Type,System.Boolean)">
            <summary>
            Create a StorageDescriptor for an item located in a local variable.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.IlGen.StorageDescriptor.Current(System.Reflection.Emit.LocalBuilder,System.Reflection.MethodInfo,System.Type)">
            <summary>
            Create a StorageDescriptor for an item which is the Current item in an iterator.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.IlGen.StorageDescriptor.Global(System.Reflection.MethodInfo,System.Type,System.Boolean)">
            <summary>
            Create a StorageDescriptor for an item located in a global variable.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.IlGen.StorageDescriptor.ToStack">
            <summary>
            Return copy of current descriptor, but change item's location to the stack.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.IlGen.StorageDescriptor.ToLocal(System.Reflection.Emit.LocalBuilder)">
            <summary>
            Create a StorageDescriptor for an item located in a local variable.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.IlGen.StorageDescriptor.ToStorageType(System.Type)">
            <summary>
            Create a StorageDescriptor which is the same as this one, except for the item storage type.
            </summary>
        </member>
        <member name="P:System.Xml.Xsl.IlGen.StorageDescriptor.Location">
            <summary>
            Return an enumeration specifying where the value is located.
            </summary>
        </member>
        <member name="P:System.Xml.Xsl.IlGen.StorageDescriptor.ParameterLocation">
            <summary>
            Return the index of the parameter that stores this iterator's values.
            </summary>
        </member>
        <member name="P:System.Xml.Xsl.IlGen.StorageDescriptor.LocalLocation">
            <summary>
            Return the LocalBuilder that stores this iterator's values.
            </summary>
        </member>
        <member name="P:System.Xml.Xsl.IlGen.StorageDescriptor.CurrentLocation">
            <summary>
            Return the "Current" location information (LocalBuilder and Current MethodInfo) that will store
            this iterator's helper class. The Current property on this iterator can be accessed to get the CurrentMethod.
            </summary>
        </member>
        <member name="P:System.Xml.Xsl.IlGen.StorageDescriptor.GlobalLocation">
            <summary>
            Return the MethodInfo for the method that computes this global value.
            </summary>
        </member>
        <member name="P:System.Xml.Xsl.IlGen.StorageDescriptor.IsCached">
            <summary>
            Return true if this iterator's values are cached.
            </summary>
        </member>
        <member name="P:System.Xml.Xsl.IlGen.StorageDescriptor.ItemStorageType">
            <summary>
            Return the Clr type of an individual item in the storage location (never an IList{T} type).
            </summary>
        </member>
        <member name="T:System.Xml.Xsl.IlGen.CurrentContext">
            <summary>
            A data class to hold information for a "Current" StorageLocation.
            </summary>
        </member>
        <member name="T:System.Xml.Xsl.IlGen.IteratorDescriptor">
            <summary>
            Iterators are joined together, are nested within each other, and reference each other.  This internal class
            contains detailed information about iteration next labels, caching, iterator item location, etc.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.IlGen.IteratorDescriptor.#ctor(System.Xml.Xsl.IlGen.GenerateHelper)">
            <summary>
            Create a "root" IteratorDescriptor which has no parent iterator.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.IlGen.IteratorDescriptor.#ctor(System.Xml.Xsl.IlGen.IteratorDescriptor)">
            <summary>
            Create an IteratorDescriptor that is nested in a parent iterator.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.IlGen.IteratorDescriptor.Init(System.Xml.Xsl.IlGen.IteratorDescriptor,System.Xml.Xsl.IlGen.GenerateHelper)">
            <summary>
            Internal helper initializor.
            </summary>
        </member>
        <member name="P:System.Xml.Xsl.IlGen.IteratorDescriptor.ParentIterator">
            <summary>
            Return the iterator in which this iterator is nested.
            </summary>
        </member>
        <member name="P:System.Xml.Xsl.IlGen.IteratorDescriptor.HasLabelNext">
            <summary>
            Returns true if LabelNext is currently defined.  If not, then this iterator will return
            exactly one result (iterator is cardinality one).
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.IlGen.IteratorDescriptor.GetLabelNext">
            <summary>
            Return the label that is anchored to this code iterator's MoveNext code.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.IlGen.IteratorDescriptor.SetIterator(System.Reflection.Emit.Label,System.Xml.Xsl.IlGen.StorageDescriptor)">
            <summary>
            Set this iterator's next label and storage.  This iterator will range over a set of values located in
            "storage".  To get the next value, jump to "lblNext".
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.IlGen.IteratorDescriptor.SetIterator(System.Xml.Xsl.IlGen.IteratorDescriptor)">
            <summary>
            Set this iterator to be the same as the specified iterator.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.IlGen.IteratorDescriptor.LoopToEnd(System.Reflection.Emit.Label)">
            <summary>
            Continue iteration until it is complete.  Branch to "lblOnEnd" when iteration is complete.
            </summary>
            <remarks>
            goto LabelNextCtxt;
            LabelOnEnd:
            </remarks>
        </member>
        <member name="P:System.Xml.Xsl.IlGen.IteratorDescriptor.LocalPosition">
            <summary>
            Storage location containing the position of the current item as an integer.
            This location is only defined on iterators, and then only if they might be
            referenced by a PositionOf operator.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.IlGen.IteratorDescriptor.CacheCount">
            <summary>
            Push the count of items in the cache onto the stack.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.IlGen.IteratorDescriptor.EnsureNoCache">
            <summary>
            If the iterator has been fully cached, then iterate the values one-by-one.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.IlGen.IteratorDescriptor.SetBranching(System.Xml.Xsl.IlGen.BranchingContext,System.Reflection.Emit.Label)">
            <summary>
            Setup a branching context.  All nested iterators compiled in this context must evaluate
            to a single boolean value.  However, these expressions must not push the result as a boolean
            onto the stack.  Instead, if brctxt is BranchType.True, then the expression should
            jump to lblBranch if it evaluates to true.  If brctxt is BranchType.False, then the
            branch should happen if the evaluation result is false.
            </summary>
        </member>
        <member name="P:System.Xml.Xsl.IlGen.IteratorDescriptor.IsBranching">
            <summary>
            True if within a branching context.
            </summary>
        </member>
        <member name="P:System.Xml.Xsl.IlGen.IteratorDescriptor.LabelBranch">
            <summary>
            Returns the label to which conditionals should branch.
            </summary>
        </member>
        <member name="P:System.Xml.Xsl.IlGen.IteratorDescriptor.CurrentBranchingContext">
            <summary>
            If BranchingContext.OnTrue, branch on true.  Otherwise, branch on false.
            </summary>
        </member>
        <member name="P:System.Xml.Xsl.IlGen.IteratorDescriptor.Storage">
            <summary>
            Returns information about how and where iterator values are stored.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.IlGen.IteratorDescriptor.PushValue">
            <summary>
            Push current item onto the stack without affecting Location.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.IlGen.IteratorDescriptor.EnsureStack">
            <summary>
            Ensure that the current item is pushed onto the stack.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.IlGen.IteratorDescriptor.EnsureNoStack(System.String)">
            <summary>
            If the current item is on the stack, move it to a local variable.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.IlGen.IteratorDescriptor.EnsureLocal(System.String)">
            <summary>
            If current item is not already in a local variable, then move it to a local variable of the specified name.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.IlGen.IteratorDescriptor.EnsureLocal(System.Reflection.Emit.LocalBuilder)">
            <summary>
            Ensure that current item is saved to the specified local variable.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.IlGen.IteratorDescriptor.DiscardStack">
            <summary>
            Discard the current item if it is pushed onto the stack.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.IlGen.IteratorDescriptor.EnsureStackNoCache">
            <summary>
            Ensure that the iterator's items are not cached, and that the current item is pushed onto the stack.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.IlGen.IteratorDescriptor.EnsureNoStackNoCache(System.String)">
            <summary>
            Ensure that the iterator's items are not cached, and that if the current item is pushed onto the stack,
            that it is moved to a local variable.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.IlGen.IteratorDescriptor.EnsureLocalNoCache(System.String)">
            <summary>
            Ensure that the iterator's items are not cached, and that if the current item is not already in a local,
            variable, that it is moved to a local variable of the specified name.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.IlGen.IteratorDescriptor.EnsureLocalNoCache(System.Reflection.Emit.LocalBuilder)">
            <summary>
            Ensure that the iterator's items are not cached and that the current item is saved to the specified local variable.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.IlGen.IteratorDescriptor.EnsureItemStorageType(System.Xml.Xsl.XmlQueryType,System.Type)">
            <summary>
            Each XmlQueryType has multiple legal CLR representations.  Ensure that all items returned by this iterator are in
            the Clr representation specified by "storageTypeDest".
            </summary>
        </member>
        <member name="T:System.Xml.Xsl.IlGen.OptimizerPatterns">
            <summary>
            As the Qil graph is traversed, patterns are identified.  Subtrees that match these patterns are
            annotated with this class, which identifies the matching patterns and their arguments.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.IlGen.OptimizerPatterns.Read(System.Xml.Xsl.Qil.QilNode)">
            <summary>
            Get OptimizerPatterns annotation for the specified node.  Lazily create if necessary.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.IlGen.OptimizerPatterns.Write(System.Xml.Xsl.Qil.QilNode)">
            <summary>
            Create and initialize OptimizerPatterns annotation for the specified node.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.IlGen.OptimizerPatterns.Inherit(System.Xml.Xsl.Qil.QilNode,System.Xml.Xsl.Qil.QilNode,System.Xml.Xsl.IlGen.OptimizerPatternName)">
            <summary>
            Create and initialize OptimizerPatterns annotation for the specified node.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.IlGen.OptimizerPatterns.AddArgument(System.Xml.Xsl.IlGen.OptimizerPatternArgument,System.Object)">
            <summary>
            Add an argument to one of the matching patterns.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.IlGen.OptimizerPatterns.GetArgument(System.Xml.Xsl.IlGen.OptimizerPatternArgument)">
            <summary>
            Get an argument of one of the matching patterns.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.IlGen.OptimizerPatterns.AddPattern(System.Xml.Xsl.IlGen.OptimizerPatternName)">
            <summary>
            Add a pattern to the list of patterns that the annotated node matches.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.IlGen.OptimizerPatterns.MatchesPattern(System.Xml.Xsl.IlGen.OptimizerPatternName)">
            <summary>
            Return true if the annotated node matches the specified pattern.
            </summary>
        </member>
        <member name="P:System.Xml.Xsl.IlGen.OptimizerPatterns.Name">
            <summary>
            Return name of this annotation.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.IlGen.OptimizerPatterns.ToString">
            <summary>
            Return string representation of this annotation.
            </summary>
        </member>
        <member name="T:System.Xml.Xsl.IlGen.UniqueList`1">
            <summary>
            This internal class maintains a list of unique values.  Each unique value is assigned a unique ID, which can
            be used to quickly access the value, since it corresponds to the value's position in the list.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.IlGen.UniqueList`1.Add(`0)">
            <summary>
            If "value" is already in the list, do not add it.  Return the unique ID of the value in the list.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.IlGen.UniqueList`1.ToArray">
            <summary>
            Return an array of the unique values.
            </summary>
        </member>
        <member name="T:System.Xml.Xsl.IlGen.StaticDataManager">
            <summary>
            Manages all static data that is used by the runtime.  This includes:
              1. All NCName and QName atoms that will be used at run-time
              2. All QName filters that will be used at run-time
              3. All Xml types that will be used at run-time
              4. All global variables and parameters
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.IlGen.StaticDataManager.DeclareName(System.String)">
            <summary>
            Add "name" to the list of unique names that are used by this query.  Return the index of
            the unique name in the list.
            </summary>
        </member>
        <member name="P:System.Xml.Xsl.IlGen.StaticDataManager.Names">
            <summary>
            Return an array of all names that are used by the query (null if no names).
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.IlGen.StaticDataManager.DeclareNameFilter(System.String,System.String)">
            <summary>
            Add a name filter to the list of unique filters that are used by this query.  Return the index of
            the unique filter in the list.
            </summary>
        </member>
        <member name="P:System.Xml.Xsl.IlGen.StaticDataManager.NameFilters">
            <summary>
            Return an array of all name filters, where each name filter is represented as a pair of integer offsets (localName, namespaceUri)
            into the Names array (null if no name filters).
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.IlGen.StaticDataManager.DeclarePrefixMappings(System.Collections.Generic.IList{System.Xml.Xsl.Qil.QilNode})">
            <summary>
            Add a list of QilExpression NamespaceDeclarations to an array of strings (prefix followed by namespace URI).
            Return index of the prefix mappings within this array.
            </summary>
        </member>
        <member name="P:System.Xml.Xsl.IlGen.StaticDataManager.PrefixMappingsList">
            <summary>
            Return an array of all prefix mappings that are used by the query to compute names (null if no mappings).
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.IlGen.StaticDataManager.DeclareGlobalValue(System.String)">
            <summary>
            Declare a new global variable or parameter.
            </summary>
        </member>
        <member name="P:System.Xml.Xsl.IlGen.StaticDataManager.GlobalNames">
            <summary>
            Return an array containing the names of all global variables and parameters.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.IlGen.StaticDataManager.DeclareEarlyBound(System.String,System.Type)">
            <summary>
            Add early bound information to a list that is used by this query.  Return the index of
            the early bound information in the list.
            </summary>
        </member>
        <member name="P:System.Xml.Xsl.IlGen.StaticDataManager.EarlyBound">
            <summary>
            Return an array of all early bound information that is used by the query (null if none is used).
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.IlGen.StaticDataManager.DeclareXmlType(System.Xml.Xsl.XmlQueryType)">
            <summary>
            Add "type" to the list of unique types that are used by this query.  Return the index of
            the unique type in the list.
            </summary>
        </member>
        <member name="P:System.Xml.Xsl.IlGen.StaticDataManager.XmlTypes">
            <summary>
            Return an array of all types that are used by the query (null if no names).
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.IlGen.StaticDataManager.DeclareCollation(System.String)">
            <summary>
            Add "collation" to the list of unique collations that are used by this query.  Return the index of
            the unique collation in the list.
            </summary>
        </member>
        <member name="P:System.Xml.Xsl.IlGen.StaticDataManager.Collations">
            <summary>
            Return an array of all collations that are used by the query (null if no names).
            </summary>
        </member>
        <member name="T:System.Xml.Xsl.IlGen.TailCallAnalyzer">
            <summary>
            This analyzer walks each function in the graph and annotates Invoke nodes which can
            be compiled using the IL .tailcall instruction.  This instruction will discard the
            current stack frame before calling the new function.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.IlGen.TailCallAnalyzer.Analyze(System.Xml.Xsl.Qil.QilExpression)">
            <summary>
            Perform tail-call analysis on the functions in the specified QilExpression.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.IlGen.TailCallAnalyzer.AnalyzeDefinition(System.Xml.Xsl.Qil.QilNode)">
            <summary>
            Recursively analyze the definition of a function.
            </summary>
        </member>
        <member name="T:System.Xml.Xsl.IlGen.XmlILAnnotation">
            <summary>
            Several annotations are created and attached to Qil nodes during the optimization and code generation phase.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.IlGen.XmlILAnnotation.Write(System.Xml.Xsl.Qil.QilNode)">
            <summary>
            Create and initialize XmlILAnnotation for the specified node.
            </summary>
        </member>
        <member name="P:System.Xml.Xsl.IlGen.XmlILAnnotation.FunctionBinding">
            <summary>
            User-defined functions and global variables and parameters are bound to Clr MethodInfo objects.
            Attached to Function, global Let, and global Parameter nodes.
            </summary>
        </member>
        <member name="P:System.Xml.Xsl.IlGen.XmlILAnnotation.ArgumentPosition">
            <summary>
            Function arguments are tracked by position.
            Attached to function Parameter nodes.
            </summary>
        </member>
        <member name="P:System.Xml.Xsl.IlGen.XmlILAnnotation.CachedIteratorDescriptor">
            <summary>
            The IteratorDescriptor that is derived for Qil For and Let nodes is cached so that it can be used when the
            For/Let node is referenced.
            Attached to For and Let nodes.
            </summary>
        </member>
        <member name="P:System.Xml.Xsl.IlGen.XmlILAnnotation.ConstructInfo">
            <summary>
            Contains information about how this expression will be constructed by ILGen.
            Attached to any kind of Qil node.
            </summary>
        </member>
        <member name="P:System.Xml.Xsl.IlGen.XmlILAnnotation.Patterns">
            <summary>
            Contains patterns that the subtree rooted at this node matches.
            Attached to any kind of Qil node.
            </summary>
        </member>
        <member name="P:System.Xml.Xsl.IlGen.XmlILAnnotation.Count">
            <summary>
            Return the count of sub-annotations maintained by this annotation.
            </summary>
        </member>
        <member name="P:System.Xml.Xsl.IlGen.XmlILAnnotation.Item(System.Int32)">
            <summary>
            Return the annotation at the specified index.
            </summary>
        </member>
        <member name="T:System.Xml.Xsl.IlGen.PossibleXmlStates">
            <summary>
            Until run-time, the exact xml state cannot always be determined.  However, the construction analyzer
            keeps track of the set of possible xml states at each node in order to reduce run-time state management.
            </summary>
        </member>
        <member name="T:System.Xml.Xsl.IlGen.XmlILConstructMethod">
            <summary>
            1. Some expressions are lazily materialized by creating an iterator over the results (ex. LiteralString, Content).
            2. Some expressions are incrementally constructed by a Writer (ex. ElementCtor, XsltCopy).
            3. Some expressions can be iterated or written (ex. List).
            </summary>
        </member>
        <member name="T:System.Xml.Xsl.IlGen.XmlILConstructInfo">
            <summary>
            Every node is annotated with information about how it will be constructed by ILGen.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.IlGen.XmlILConstructInfo.Read(System.Xml.Xsl.Qil.QilNode)">
            <summary>
            Get ConstructInfo annotation for the specified node.  Lazily create if necessary.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.IlGen.XmlILConstructInfo.Write(System.Xml.Xsl.Qil.QilNode)">
            <summary>
            Create and initialize XmlILConstructInfo annotation for the specified node.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.IlGen.XmlILConstructInfo.#ctor(System.Xml.Xsl.Qil.QilNodeType)">
            <summary>
            Default to worst possible construction information.
            </summary>
        </member>
        <member name="P:System.Xml.Xsl.IlGen.XmlILConstructInfo.InitialStates">
            <summary>
            Xml states that are possible as construction of the annotated expression begins.
            </summary>
        </member>
        <member name="P:System.Xml.Xsl.IlGen.XmlILConstructInfo.FinalStates">
            <summary>
            Xml states that are possible as construction of the annotated expression ends.
            </summary>
        </member>
        <member name="P:System.Xml.Xsl.IlGen.XmlILConstructInfo.BeginLoopStates">
            <summary>
            Xml states that are possible as looping begins.  This is None if the annotated expression does not loop.
            </summary>
        </member>
        <member name="P:System.Xml.Xsl.IlGen.XmlILConstructInfo.EndLoopStates">
            <summary>
            Xml states that are possible as looping ends.  This is None if the annotated expression does not loop.
            </summary>
        </member>
        <member name="P:System.Xml.Xsl.IlGen.XmlILConstructInfo.ConstructMethod">
            <summary>
            Return the method that will be used to construct the annotated node.
            </summary>
        </member>
        <member name="P:System.Xml.Xsl.IlGen.XmlILConstructInfo.PushToWriterFirst">
            <summary>
            Returns true if construction method is Writer or WriterThenIterator.
            </summary>
        </member>
        <member name="P:System.Xml.Xsl.IlGen.XmlILConstructInfo.PushToWriterLast">
            <summary>
            Returns true if construction method is Writer or IteratorThenWriter.
            </summary>
        </member>
        <member name="P:System.Xml.Xsl.IlGen.XmlILConstructInfo.PullFromIteratorFirst">
            <summary>
            Returns true if construction method is IteratorThenWriter or Iterator.
            </summary>
        </member>
        <member name="P:System.Xml.Xsl.IlGen.XmlILConstructInfo.ParentInfo">
            <summary>
            If the annotated expression will be constructed as the content of another constructor, and this can be
            guaranteed at compile-time, then this property will be the non-null XmlILConstructInfo of that constructor.
            </summary>
        </member>
        <member name="P:System.Xml.Xsl.IlGen.XmlILConstructInfo.ParentElementInfo">
            <summary>
            If the annotated expression will be constructed as the content of an ElementCtor, and this can be
            guaranteed at compile-time, then this property will be the non-null XmlILConstructInfo of that constructor.
            </summary>
        </member>
        <member name="P:System.Xml.Xsl.IlGen.XmlILConstructInfo.IsNamespaceInScope">
            <summary>
            This annotation is only applicable to NamespaceDecl nodes and to ElementCtor and AttributeCtor nodes with
            literal names.  If the namespace is already guaranteed to be constructed, then this property will be true.
            </summary>
        </member>
        <member name="P:System.Xml.Xsl.IlGen.XmlILConstructInfo.MightHaveNamespaces">
            <summary>
            This annotation is only applicable to ElementCtor nodes.  If the element might have local namespaces
            added to it at runtime, then this property will be true.
            </summary>
        </member>
        <member name="P:System.Xml.Xsl.IlGen.XmlILConstructInfo.MightHaveNamespacesAfterAttributes">
            <summary>
            This annotation is only applicable to ElementCtor nodes.  If the element might have namespaces added to it after
            attributes have already been added, then this property will be true.
            </summary>
        </member>
        <member name="P:System.Xml.Xsl.IlGen.XmlILConstructInfo.MightHaveAttributes">
            <summary>
            This annotation is only applicable to ElementCtor nodes.  If the element might have attributes added to it at
            runtime, then this property will be true.
            </summary>
        </member>
        <member name="P:System.Xml.Xsl.IlGen.XmlILConstructInfo.MightHaveDuplicateAttributes">
            <summary>
            This annotation is only applicable to ElementCtor nodes.  If the element might have multiple attributes added to
            it with the same name, then this property will be true.
            </summary>
        </member>
        <member name="P:System.Xml.Xsl.IlGen.XmlILConstructInfo.CallersInfo">
            <summary>
            This annotation is only applicable to Function nodes.  It contains a list of XmlILConstructInfo annotations
            for all QilInvoke nodes which call the annotated function.
            </summary>
        </member>
        <member name="P:System.Xml.Xsl.IlGen.XmlILConstructInfo.Name">
            <summary>
            Return name of this annotation.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.IlGen.XmlILConstructInfo.ToString">
            <summary>
            Return string representation of this annotation.
            </summary>
        </member>
        <member name="T:System.Xml.Xsl.IlGen.XmlILStateAnalyzer">
            <summary>
            Scans the content of an constructor and tries to minimize the number of well-formed checks that will have
            to be made at runtime when constructing content.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.IlGen.XmlILStateAnalyzer.#ctor(System.Xml.Xsl.Qil.QilFactory)">
            <summary>
            Constructor.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.IlGen.XmlILStateAnalyzer.Analyze(System.Xml.Xsl.Qil.QilNode,System.Xml.Xsl.Qil.QilNode)">
            <summary>
            Perform analysis on the specified constructor and its content.  Return the ndContent that was passed in,
            or a replacement.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.IlGen.XmlILStateAnalyzer.AnalyzeContent(System.Xml.Xsl.Qil.QilNode)">
            <summary>
            Recursively analyze content.  Return "nd" or a replacement for it.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.IlGen.XmlILStateAnalyzer.AnalyzeLoop(System.Xml.Xsl.Qil.QilLoop,System.Xml.Xsl.IlGen.XmlILConstructInfo)">
            <summary>
            Analyze loop.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.IlGen.XmlILStateAnalyzer.AnalyzeSequence(System.Xml.Xsl.Qil.QilList,System.Xml.Xsl.IlGen.XmlILConstructInfo)">
            <summary>
            Analyze list.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.IlGen.XmlILStateAnalyzer.AnalyzeConditional(System.Xml.Xsl.Qil.QilTernary,System.Xml.Xsl.IlGen.XmlILConstructInfo)">
            <summary>
            Analyze conditional.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.IlGen.XmlILStateAnalyzer.AnalyzeChoice(System.Xml.Xsl.Qil.QilChoice,System.Xml.Xsl.IlGen.XmlILConstructInfo)">
            <summary>
            Analyze choice.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.IlGen.XmlILStateAnalyzer.AnalyzeCopy(System.Xml.Xsl.Qil.QilNode,System.Xml.Xsl.IlGen.XmlILConstructInfo)">
            <summary>
            Analyze copying items.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.IlGen.XmlILStateAnalyzer.StartLoop(System.Xml.Xsl.XmlQueryType,System.Xml.Xsl.IlGen.XmlILConstructInfo)">
            <summary>
            Calculate starting xml states that will result when iterating over and constructing an expression of the specified type.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.IlGen.XmlILStateAnalyzer.EndLoop(System.Xml.Xsl.XmlQueryType,System.Xml.Xsl.IlGen.XmlILConstructInfo)">
            <summary>
            Calculate ending xml states that will result when iterating over and constructing an expression of the specified type.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.IlGen.XmlILStateAnalyzer.MaybeAttrNmsp(System.Xml.Xsl.XmlQueryType)">
            <summary>
            Return true if an instance of the specified type might be an attribute or a namespace node.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.IlGen.XmlILStateAnalyzer.MaybeContent(System.Xml.Xsl.XmlQueryType)">
            <summary>
            Return true if an instance of the specified type might be a non-empty content type (attr/nsmp don't count).
            </summary>
        </member>
        <member name="T:System.Xml.Xsl.IlGen.XmlILElementAnalyzer">
            <summary>
            Scans the content of an ElementCtor and tries to minimize the number of well-formed checks that will have
            to be made at runtime when constructing content.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.IlGen.XmlILElementAnalyzer.#ctor(System.Xml.Xsl.Qil.QilFactory)">
            <summary>
            Constructor.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.IlGen.XmlILElementAnalyzer.Analyze(System.Xml.Xsl.Qil.QilNode,System.Xml.Xsl.Qil.QilNode)">
            <summary>
            Analyze the content argument of the ElementCtor.  Try to eliminate as many runtime checks as possible,
            both for the ElementCtor and for content constructors.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.IlGen.XmlILElementAnalyzer.AnalyzeLoop(System.Xml.Xsl.Qil.QilLoop,System.Xml.Xsl.IlGen.XmlILConstructInfo)">
            <summary>
            Analyze loop.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.IlGen.XmlILElementAnalyzer.AnalyzeCopy(System.Xml.Xsl.Qil.QilNode,System.Xml.Xsl.IlGen.XmlILConstructInfo)">
            <summary>
            Analyze copying items.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.IlGen.XmlILElementAnalyzer.AnalyzeAttributeCtor(System.Xml.Xsl.Qil.QilBinary,System.Xml.Xsl.IlGen.XmlILConstructInfo)">
            <summary>
            Analyze attribute constructor.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.IlGen.XmlILElementAnalyzer.CheckAttributeNamespaceConstruct(System.Xml.Xsl.XmlQueryType)">
            <summary>
            If type might contain attributes or namespaces, set appropriate parent element flags.
            </summary>
        </member>
        <member name="T:System.Xml.Xsl.IlGen.XmlILNamespaceAnalyzer">
            <summary>
            Scans constructed content, looking for redundant namespace declarations.  If any are found, then they are marked
            and removed later.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.IlGen.XmlILNamespaceAnalyzer.Analyze(System.Xml.Xsl.Qil.QilNode,System.Boolean)">
            <summary>
            Perform scan.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.IlGen.XmlILNamespaceAnalyzer.AnalyzeContent(System.Xml.Xsl.Qil.QilNode)">
            <summary>
            Recursively analyze content.  Return "nd" or a replacement for it.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.IlGen.XmlILNamespaceAnalyzer.CheckNamespaceInScope(System.Xml.Xsl.Qil.QilBinary)">
            <summary>
            Determine whether an ElementCtor, AttributeCtor, or NamespaceDecl's namespace is already declared.  If it is,
            set the IsNamespaceInScope property to True.  Otherwise, add the namespace to the set of in-scope namespaces if
            addInScopeNmsp is True.  Return false if the name is computed or is invalid.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.IlGen.XmlILModule.DefineMethod(System.String,System.Type,System.Type[],System.String[],System.Xml.Xsl.IlGen.XmlILMethodAttributes)">
            <summary>
            Define a method in this module with the specified name and parameters.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.IlGen.XmlILModule.DefineMethodBody(System.Reflection.MethodBase)">
            <summary>
            Get an XmlILGenerator that can be used to generate the body of the specified method.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.IlGen.XmlILModule.FindMethod(System.String)">
            <summary>
            Find a MethodInfo of the specified name and return it.  Return null if no such method exists.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.IlGen.XmlILModule.DefineInitializedData(System.String,System.Byte[])">
            <summary>
            Define ginitialized data field with the specified name and value.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.IlGen.XmlILModule.DefineField(System.String,System.Type)">
            <summary>
            Define private static field with the specified name and value.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.IlGen.XmlILModule.DefineTypeInitializer">
            <summary>
            Define static constructor for this type.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.IlGen.XmlILModule.BakeMethods">
            <summary>
            Once all methods have been defined, CreateModule must be called in order to "bake" the methods within
            this module.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.IlGen.XmlILModule.CreateDelegate(System.String,System.Type)">
            <summary>
            Wrap a delegate around a MethodInfo of the specified name and type and return it.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.IlGen.XmlILModule.CreateAssemblyName">
            <summary>
            Define unique assembly name (within AppDomain).
            </summary>
        </member>
        <member name="T:System.Xml.Xsl.IlGen.XmlILOptimization">
            <summary>
            Xml IL patterns.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.IlGen.XmlILOptimizerVisitor.Optimize">
            <summary>
            Perform normalization and annotation.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.IlGen.XmlILOptimizerVisitor.Visit(System.Xml.Xsl.Qil.QilNode)">
            <summary>
            Override the Visit method in order to scan for redundant namespaces and compute side-effect bit.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.IlGen.XmlILOptimizerVisitor.VisitReference(System.Xml.Xsl.Qil.QilNode)">
            <summary>
            Override the VisitReference method in order to possibly substitute.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.IlGen.XmlILOptimizerVisitor.AllowReplace(System.Xml.Xsl.IlGen.XmlILOptimization,System.Xml.Xsl.Qil.QilNode)">
            <summary>
            Strongly-typed AllowReplace.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.IlGen.XmlILOptimizerVisitor.Replace(System.Xml.Xsl.IlGen.XmlILOptimization,System.Xml.Xsl.Qil.QilNode,System.Xml.Xsl.Qil.QilNode)">
            <summary>
            Strongly-typed Replace.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.IlGen.XmlILOptimizerVisitor.NoReplace(System.Xml.Xsl.Qil.QilNode)">
            <summary>
            Called when all replacements have already been made and all annotations are complete.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.IlGen.XmlILOptimizerVisitor.RecalculateType(System.Xml.Xsl.Qil.QilNode,System.Xml.Xsl.XmlQueryType)">
            <summary>
            Override the RecalculateType method so that global variable type is not recalculated.
            </summary>
        </member>
        <member name="P:System.Xml.Xsl.IlGen.XmlILOptimizerVisitor.Item(System.Xml.Xsl.IlGen.XmlILOptimization)">
            <summary>
            Selectively enable/disable optimizations
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.IlGen.XmlILOptimizerVisitor.NodeCounter.Count(System.Xml.Xsl.Qil.QilNode,System.Xml.Xsl.Qil.QilNode)">
            <summary>
            Returns number of occurrences of "target" node within the subtree of "expr".
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.IlGen.XmlILOptimizerVisitor.NodeFinder.Find(System.Xml.Xsl.Qil.QilNode,System.Xml.Xsl.Qil.QilNode)">
            <summary>
            Returns true if "target" node exists within the subtree of "expr".
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.IlGen.XmlILOptimizerVisitor.NodeFinder.Visit(System.Xml.Xsl.Qil.QilNode)">
            <summary>
            Recursively visit, searching for target.  If/when found, call OnFound() method.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.IlGen.XmlILOptimizerVisitor.NodeFinder.VisitReference(System.Xml.Xsl.Qil.QilNode)">
            <summary>
            Determine whether target is a reference.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.IlGen.XmlILOptimizerVisitor.NodeFinder.OnFound(System.Xml.Xsl.Qil.QilNode)">
            <summary>
            By default, just return true.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.IlGen.XmlILOptimizerVisitor.PositionOfFinder.OnFound(System.Xml.Xsl.Qil.QilNode)">
            <summary>
            Return true only if parent node type is PositionOf.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.IlGen.XmlILOptimizerVisitor.EqualityIndexVisitor.Scan(System.Xml.Xsl.Qil.QilNode,System.Xml.Xsl.Qil.QilNode,System.Xml.Xsl.Qil.QilNode)">
            <summary>
            Returns true if the subtree of "expr" meets the following requirements:
              1. Does not contain a reference to "key"
              2. Every reference to "ctxt" is wrapped by a QilNodeType.Root node
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.IlGen.XmlILOptimizerVisitor.EqualityIndexVisitor.VisitReference(System.Xml.Xsl.Qil.QilNode)">
            <summary>
            Recursively visit, looking for references to "key" and "ctxt".
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.IlGen.XmlILOptimizerVisitor.EqualityIndexVisitor.VisitRoot(System.Xml.Xsl.Qil.QilUnary)">
            <summary>
            If Root wraps a reference to "ctxt", then don't visit "ctxt" and continue scan.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.IlGen.XmlILOptimizerVisitor.DependsOn(System.Xml.Xsl.Qil.QilNode,System.Xml.Xsl.Qil.QilNode)">
            <summary>
            Returns true if any operator within the "expr" subtree references "target".
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.IlGen.XmlILOptimizerVisitor.NonPositional(System.Xml.Xsl.Qil.QilNode,System.Xml.Xsl.Qil.QilNode)">
            <summary>
            Returns true if there is no PositionOf operator within the "expr" subtree that references iterator "iter".
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.IlGen.XmlILOptimizerVisitor.Subs(System.Xml.Xsl.Qil.QilNode,System.Xml.Xsl.Qil.QilNode,System.Xml.Xsl.Qil.QilNode)">
            <summary>
            Scans "expr" subtree, looking for "refOld" references and replacing them with "refNew" references.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.IlGen.XmlILOptimizerVisitor.IsGlobalVariable(System.Xml.Xsl.Qil.QilIterator)">
            <summary>
            True if the specified iterator is a global variable Let iterator.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.IlGen.XmlILOptimizerVisitor.IsGlobalValue(System.Xml.Xsl.Qil.QilNode)">
            <summary>
            True if the specified node is a global variable or parameter.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.IlGen.XmlILOptimizerVisitor.IsPrimitiveNumeric(System.Xml.Xsl.XmlQueryType)">
            <summary>
            Return true if "typ" is xs:decimal=, xs:integer=, xs:int=, xs:double=, or xs:float=.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.IlGen.XmlILOptimizerVisitor.MatchesContentTest(System.Xml.Xsl.XmlQueryType)">
            <summary>
            Returns true if "typ" matches one of the XPath content node tests: *, text(), comment(), pi(), or node().
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.IlGen.XmlILOptimizerVisitor.IsConstructedExpression(System.Xml.Xsl.Qil.QilNode)">
            <summary>
            True if the specified expression constructs one or more nodes using QilExpression constructor operators.
            This information is used to determine whether the results of a function should be streamed to a writer
            rather than cached.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.IlGen.XmlILOptimizerVisitor.IsLiteral(System.Xml.Xsl.Qil.QilNode)">
            <summary>
            True if the specified expression is a literal value.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.IlGen.XmlILOptimizerVisitor.AreLiteralArgs(System.Xml.Xsl.Qil.QilNode)">
            <summary>
            Return true if all children of "nd" are constant.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.IlGen.XmlILOptimizerVisitor.ExtractLiteralValue(System.Xml.Xsl.Qil.QilNode)">
            <summary>
            Extract the value of a literal.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.IlGen.XmlILOptimizerVisitor.HasNestedSequence(System.Xml.Xsl.Qil.QilNode)">
            <summary>
            Return true if "nd" has a child of type Sequence.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.IlGen.XmlILOptimizerVisitor.AllowJoinAndDod(System.Xml.Xsl.Qil.QilNode)">
            <summary>
            True if the JoinAndDod pattern is allowed to match the specified node.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.IlGen.XmlILOptimizerVisitor.AllowDodReverse(System.Xml.Xsl.Qil.QilNode)">
            <summary>
            True if the DodReverse pattern is allowed to match the specified node.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.IlGen.XmlILOptimizerVisitor.CanFoldXsltConvert(System.Xml.Xsl.Qil.QilNode,System.Xml.Xsl.XmlQueryType)">
            <summary>
            Return true if XsltConvert applied to a Literal can be folded (i.e. the XsltConvert eliminated).
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.IlGen.XmlILOptimizerVisitor.CanFoldXsltConvertNonLossy(System.Xml.Xsl.Qil.QilNode,System.Xml.Xsl.XmlQueryType)">
            <summary>
            Return true if XsltConvert applied to a Literal can be folded (i.e. the XsltConvert eliminated), without
            any loss of information.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.IlGen.XmlILOptimizerVisitor.FoldXsltConvert(System.Xml.Xsl.Qil.QilNode,System.Xml.Xsl.XmlQueryType)">
            <summary>
            Fold a XsltConvert applied to a Literal into another Literal.  If the fold results in some kind of
            conversion error, or if the QilExpression cannot represent the result as a Literal, return an unfolded
            XsltConvert expression.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.IlGen.XmlILOptimizerVisitor.FoldComparison(System.Xml.Xsl.Qil.QilNodeType,System.Xml.Xsl.Qil.QilNode,System.Xml.Xsl.Qil.QilNode)">
            <summary>
            Compute the arithmetic operation "opType" over two literal operands and return the result as a QilLiteral.
            In the case of an overflow or divide by zero exception, return the unfolded result.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.IlGen.XmlILOptimizerVisitor.CanFoldArithmetic(System.Xml.Xsl.Qil.QilNodeType,System.Xml.Xsl.Qil.QilLiteral,System.Xml.Xsl.Qil.QilLiteral)">
            <summary>
            Return true if arithmetic operation "opType" can be computed over two literal operands without causing
            an overflow or divide by zero exception.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.IlGen.XmlILOptimizerVisitor.FoldArithmetic(System.Xml.Xsl.Qil.QilNodeType,System.Xml.Xsl.Qil.QilLiteral,System.Xml.Xsl.Qil.QilLiteral)">
            <summary>
            Compute the arithmetic operation "opType" over two literal operands and return the result as a QilLiteral.
            Arithmetic operations are always checked; in the case of an overflow or divide by zero exception, return
            the unfolded result.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.IlGen.XmlILOptimizerVisitor.AddStepPattern(System.Xml.Xsl.Qil.QilNode,System.Xml.Xsl.Qil.QilNode)">
            <summary>
            Mark the specified node as matching the Step pattern and set the step node and step input arguments.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.IlGen.XmlILOptimizerVisitor.IsDocOrderDistinct(System.Xml.Xsl.Qil.QilNode)">
            <summary>
            Return true if "nd" matches the Step pattern and the StepType argument is equal to "stepType".
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.IlGen.XmlILOptimizerVisitor.IsStepPattern(System.Xml.Xsl.Qil.QilNode,System.Xml.Xsl.Qil.QilNodeType)">
            <summary>
            Return true if "nd" matches the Step pattern and the StepType argument is equal to "stepType".
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.IlGen.XmlILOptimizerVisitor.IsStepPattern(System.Xml.Xsl.IlGen.OptimizerPatterns,System.Xml.Xsl.Qil.QilNodeType)">
            <summary>
            Return true if "patt" matches the Step pattern and the StepType argument is equal to "stepType".
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.IlGen.XmlILOptimizerVisitor.EliminateUnusedGlobals(System.Xml.Xsl.Qil.QilList)">
            <summary>
            Remove unused global functions, variables, or parameters from the list.
            </summary>
        </member>
        <member name="T:System.Xml.Xsl.IlGen.XmlILTrace">
            <summary>
            Helper class that facilitates tracing of ILGen.
            </summary>
        </member>
        <member name="F:System.Xml.Xsl.IlGen.XmlILTrace.s_dirName">
            <summary>
            Check environment variable in order to determine whether to write out trace files.  This really should be a
            check of the configuration file, but System.Xml does not yet have a good tracing story.
            </summary>
        </member>
        <member name="P:System.Xml.Xsl.IlGen.XmlILTrace.IsEnabled">
            <summary>
            True if tracing has been enabled (environment variable set).
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.IlGen.XmlILTrace.PrepareTraceWriter(System.String)">
            <summary>
            If tracing is enabled, this method will delete the contents of "filename" in preparation for append
            operations.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.IlGen.XmlILTrace.GetTraceWriter(System.String)">
            <summary>
            If tracing is enabled, this method will open a TextWriter over "fileName" and return it.  Otherwise,
            null will be returned.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.IlGen.XmlILTrace.WriteQil(System.Xml.Xsl.Qil.QilExpression,System.String)">
            <summary>
            Serialize Qil tree to "fileName", in the directory identified by "dirName".
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.IlGen.XmlILTrace.TraceOptimizations(System.Xml.Xsl.Qil.QilExpression,System.String)">
            <summary>
            Trace ILGen optimizations and log them to "fileName".
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.IlGen.XmlILTrace.WriteQil(System.Xml.Xsl.Qil.QilExpression,System.Xml.XmlWriter)">
            <summary>
            Serialize Qil tree to writer "w".
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.IlGen.XmlILTrace.WriteQilRewrite(System.Xml.Xsl.Qil.QilExpression,System.Xml.XmlWriter,System.String)">
            <summary>
            Serialize rewritten Qil tree to writer "w".
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.IlGen.XmlILTrace.OptimizationToString(System.Int32)">
            <summary>
            Get friendly string description of an ILGen optimization.
            </summary>
        </member>
        <member name="T:System.Xml.Xsl.IlGen.XmlILTypeHelper">
            <summary>
            Static QilExpression type helper methods.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.IlGen.XmlILTypeHelper.GetStorageType(System.Xml.Xsl.XmlQueryType)">
            <summary>
            Return the default Clr data type that will be used to store instances of the QilNode's type.
            </summary>
        </member>
        <member name="T:System.Xml.Xsl.IlGen.XmlILVisitor">
            <summary>
            Creates Msil code for an entire QilExpression graph.  Code is generated in one of two modes: push or
            pull.  In push mode, code is generated to push the values in an iterator to the XmlWriter
            interface.  In pull mode, the values in an iterator are stored in a physical location such as
            the stack or a local variable by an iterator.  The iterator is passive, and will just wait for
            a caller to pull the data and/or instruct the iterator to enumerate the next value.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.IlGen.XmlILVisitor.Visit(System.Xml.Xsl.Qil.QilExpression,System.Xml.Xsl.IlGen.GenerateHelper,System.Reflection.MethodInfo)">
            <summary>
            Visits the specified QilExpression graph and generates MSIL code.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.IlGen.XmlILVisitor.PrepareGlobalValues(System.Xml.Xsl.Qil.QilList)">
            <summary>
            Create IteratorDescriptor for each global value.  This pre-visit is necessary because a global early
            in the list may reference a global later in the list and therefore expect its IteratorDescriptor to already
            be initialized.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.IlGen.XmlILVisitor.VisitGlobalValues(System.Xml.Xsl.Qil.QilList)">
            <summary>
            Visit each global variable or parameter.  Create a IteratorDescriptor for each global value.  Generate code for
            default values.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.IlGen.XmlILVisitor.Function(System.Xml.Xsl.Qil.QilFunction)">
            <summary>
            Generate code for the specified function.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.IlGen.XmlILVisitor.Visit(System.Xml.Xsl.Qil.QilNode)">
            <summary>
            Generate a query plan for the QilExpression subgraph.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.IlGen.XmlILVisitor.VisitChildren(System.Xml.Xsl.Qil.QilNode)">
            <summary>
            VisitChildren should never be called.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.IlGen.XmlILVisitor.NestedConstruction(System.Xml.Xsl.Qil.QilNode)">
            <summary>
            Generate code to cache a sequence of items that are pushed to output.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.IlGen.XmlILVisitor.CopySequence(System.Xml.Xsl.Qil.QilNode)">
            <summary>
            Iterate over items produced by the "nd" expression and copy each item to output.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.IlGen.XmlILVisitor.VisitDataSource(System.Xml.Xsl.Qil.QilDataSource)">
            <summary>
            Generate code for QilNodeType.DataSource.
            </summary>
            <remarks>
            Generates code to retrieve a document using the XmlResolver.
            </remarks>
        </member>
        <member name="M:System.Xml.Xsl.IlGen.XmlILVisitor.VisitNop(System.Xml.Xsl.Qil.QilUnary)">
            <summary>
            Generate code for QilNodeType.Nop.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.IlGen.XmlILVisitor.VisitOptimizeBarrier(System.Xml.Xsl.Qil.QilUnary)">
            <summary>
            Generate code for QilNodeType.OptimizeBarrier.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.IlGen.XmlILVisitor.VisitError(System.Xml.Xsl.Qil.QilUnary)">
            <summary>
            Generate code for QilNodeType.Error.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.IlGen.XmlILVisitor.VisitWarning(System.Xml.Xsl.Qil.QilUnary)">
            <summary>
            Generate code for QilNodeType.Warning.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.IlGen.XmlILVisitor.VisitTrue(System.Xml.Xsl.Qil.QilNode)">
            <summary>
            Generate code for QilNodeType.True.
            </summary>
            <remarks>
            BranchingContext.OnFalse context: [nothing]
            BranchingContext.OnTrue context:  goto LabelParent;
            BranchingContext.None context:  push true();
            </remarks>
        </member>
        <member name="M:System.Xml.Xsl.IlGen.XmlILVisitor.VisitFalse(System.Xml.Xsl.Qil.QilNode)">
            <summary>
            Generate code for QilNodeType.False.
            </summary>
            <remarks>
            BranchingContext.OnFalse context: goto LabelParent;
            BranchingContext.OnTrue context:  [nothing]
            BranchingContext.None context:  push false();
            </remarks>
        </member>
        <member name="M:System.Xml.Xsl.IlGen.XmlILVisitor.VisitLiteralString(System.Xml.Xsl.Qil.QilLiteral)">
            <summary>
            Generate code for QilNodeType.LiteralString.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.IlGen.XmlILVisitor.VisitLiteralInt32(System.Xml.Xsl.Qil.QilLiteral)">
            <summary>
            Generate code for QilNodeType.LiteralInt32.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.IlGen.XmlILVisitor.VisitLiteralInt64(System.Xml.Xsl.Qil.QilLiteral)">
            <summary>
            Generate code for QilNodeType.LiteralInt64.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.IlGen.XmlILVisitor.VisitLiteralDouble(System.Xml.Xsl.Qil.QilLiteral)">
            <summary>
            Generate code for QilNodeType.LiteralDouble.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.IlGen.XmlILVisitor.VisitLiteralDecimal(System.Xml.Xsl.Qil.QilLiteral)">
            <summary>
            Generate code for QilNodeType.LiteralDecimal.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.IlGen.XmlILVisitor.VisitLiteralQName(System.Xml.Xsl.Qil.QilName)">
            <summary>
            Generate code for QilNodeType.LiteralQName.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.IlGen.XmlILVisitor.VisitAnd(System.Xml.Xsl.Qil.QilBinary)">
             <summary>
             Generate code for QilNodeType.And.
             </summary>
             <remarks>
             BranchingContext.OnFalse context: (expr1) and (expr2)
             ==> if (!expr1) goto LabelParent;
                 if (!expr2) goto LabelParent;
            
             BranchingContext.OnTrue context: (expr1) and (expr2)
             ==> if (!expr1) goto LabelTemp;
                 if (expr1) goto LabelParent;
                 LabelTemp:
            
             BranchingContext.None context: (expr1) and (expr2)
             ==> if (!expr1) goto LabelTemp;
                 if (!expr1) goto LabelTemp;
                 push true();
                 goto LabelSkip;
                 LabelTemp:
                 push false();
                 LabelSkip:
            
             </remarks>
        </member>
        <member name="M:System.Xml.Xsl.IlGen.XmlILVisitor.StartConjunctiveTests(System.Xml.Xsl.IlGen.BranchingContext,System.Reflection.Emit.Label)">
            <summary>
            Fixup branching context for all but the last test in a conjunctive (Logical And) expression.
            Return a temporary label which will be passed to StartLastAndBranch() and EndAndBranch().
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.IlGen.XmlILVisitor.StartLastConjunctiveTest(System.Xml.Xsl.IlGen.BranchingContext,System.Reflection.Emit.Label,System.Reflection.Emit.Label)">
            <summary>
            Fixup branching context for the last test in a conjunctive (Logical And) expression.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.IlGen.XmlILVisitor.EndConjunctiveTests(System.Xml.Xsl.IlGen.BranchingContext,System.Reflection.Emit.Label)">
            <summary>
            Anchor any remaining labels.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.IlGen.XmlILVisitor.VisitOr(System.Xml.Xsl.Qil.QilBinary)">
             <summary>
             Generate code for QilNodeType.Or.
             </summary>
             <remarks>
             BranchingContext.OnFalse context: (expr1) or (expr2)
             ==> if (expr1) goto LabelTemp;
                 if (!expr2) goto LabelParent;
                 LabelTemp:
            
             BranchingContext.OnTrue context: (expr1) or (expr2)
             ==> if (expr1) goto LabelParent;
                 if (expr1) goto LabelParent;
            
             BranchingContext.None context: (expr1) or (expr2)
             ==> if (expr1) goto LabelTemp;
                 if (expr1) goto LabelTemp;
                 push false();
                 goto LabelSkip;
                 LabelTemp:
                 push true();
                 LabelSkip:
            
             </remarks>
        </member>
        <member name="M:System.Xml.Xsl.IlGen.XmlILVisitor.VisitNot(System.Xml.Xsl.Qil.QilUnary)">
             <summary>
             Generate code for QilNodeType.Not.
             </summary>
             <remarks>
             BranchingContext.OnFalse context: not(expr1)
             ==> if (expr1) goto LabelParent;
            
             BranchingContext.OnTrue context: not(expr1)
             ==> if (!expr1) goto LabelParent;
            
             BranchingContext.None context: not(expr1)
             ==> if (expr1) goto LabelTemp;
                 push false();
                 goto LabelSkip;
                 LabelTemp:
                 push true();
                 LabelSkip:
            
             </remarks>
        </member>
        <member name="M:System.Xml.Xsl.IlGen.XmlILVisitor.VisitConditional(System.Xml.Xsl.Qil.QilTernary)">
            <summary>
            Generate code for QilNodeType.Conditional.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.IlGen.XmlILVisitor.ConditionalBranch(System.Xml.Xsl.Qil.QilNode,System.Type,System.Reflection.Emit.LocalBuilder)">
            <summary>
            Generate code for one of the branches of QilNodeType.Conditional.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.IlGen.XmlILVisitor.VisitChoice(System.Xml.Xsl.Qil.QilChoice)">
            <summary>
            Generate code for QilNodeType.Choice.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.IlGen.XmlILVisitor.VisitLength(System.Xml.Xsl.Qil.QilUnary)">
            <summary>
            Generate code for QilNodeType.Length.
            </summary>
            <remarks>
            int length = 0;
            foreach (item in expr)
              length++;
            </remarks>
        </member>
        <member name="M:System.Xml.Xsl.IlGen.XmlILVisitor.VisitSequence(System.Xml.Xsl.Qil.QilList)">
            <summary>
            Find physical query plan for QilNodeType.Sequence.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.IlGen.XmlILVisitor.VisitEmpty(System.Xml.Xsl.Qil.QilNode)">
            <summary>
            Generate code for the empty sequence.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.IlGen.XmlILVisitor.Sequence(System.Xml.Xsl.Qil.QilList)">
            <summary>
            Generate code for QilNodeType.Sequence, when sort-merging to retain document order is not necessary.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.IlGen.XmlILVisitor.VisitUnion(System.Xml.Xsl.Qil.QilBinary)">
            <summary>
            Generate code for QilNodeType.Union.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.IlGen.XmlILVisitor.VisitIntersection(System.Xml.Xsl.Qil.QilBinary)">
            <summary>
            Generate code for QilNodeType.Intersection.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.IlGen.XmlILVisitor.VisitDifference(System.Xml.Xsl.Qil.QilBinary)">
            <summary>
            Generate code for QilNodeType.Difference.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.IlGen.XmlILVisitor.CreateSetIterator(System.Xml.Xsl.Qil.QilBinary,System.String,System.Type,System.Reflection.MethodInfo,System.Reflection.MethodInfo,System.Reflection.MethodInfo)">
            <summary>
            Generate code to combine nodes from two nested iterators using Union, Intersection, or Difference semantics.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.IlGen.XmlILVisitor.VisitAverage(System.Xml.Xsl.Qil.QilUnary)">
            <summary>
            Generate code for QilNodeType.Average.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.IlGen.XmlILVisitor.VisitSum(System.Xml.Xsl.Qil.QilUnary)">
            <summary>
            Generate code for QilNodeType.Sum.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.IlGen.XmlILVisitor.VisitMinimum(System.Xml.Xsl.Qil.QilUnary)">
            <summary>
            Generate code for QilNodeType.Minimum.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.IlGen.XmlILVisitor.VisitMaximum(System.Xml.Xsl.Qil.QilUnary)">
            <summary>
            Generate code for QilNodeType.Maximum.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.IlGen.XmlILVisitor.CreateAggregator(System.Xml.Xsl.Qil.QilUnary,System.String,System.Xml.Xsl.IlGen.XmlILStorageMethods,System.Reflection.MethodInfo,System.Reflection.MethodInfo)">
            <summary>
            Generate code for QilNodeType.Sum, QilNodeType.Average, QilNodeType.Minimum, and QilNodeType.Maximum.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.IlGen.XmlILVisitor.VisitNegate(System.Xml.Xsl.Qil.QilUnary)">
            <summary>
            Generate code for QilNodeType.Negate.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.IlGen.XmlILVisitor.VisitAdd(System.Xml.Xsl.Qil.QilBinary)">
            <summary>
            Generate code for QilNodeType.Add.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.IlGen.XmlILVisitor.VisitSubtract(System.Xml.Xsl.Qil.QilBinary)">
            <summary>
            Generate code for QilNodeType.Subtract.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.IlGen.XmlILVisitor.VisitMultiply(System.Xml.Xsl.Qil.QilBinary)">
            <summary>
            Generate code for QilNodeType.Multiply.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.IlGen.XmlILVisitor.VisitDivide(System.Xml.Xsl.Qil.QilBinary)">
            <summary>
            Generate code for QilNodeType.Divide.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.IlGen.XmlILVisitor.VisitModulo(System.Xml.Xsl.Qil.QilBinary)">
            <summary>
            Generate code for QilNodeType.Modulo.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.IlGen.XmlILVisitor.ArithmeticOp(System.Xml.Xsl.Qil.QilBinary)">
            <summary>
            Generate code for two-argument arithmetic operations.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.IlGen.XmlILVisitor.VisitStrLength(System.Xml.Xsl.Qil.QilUnary)">
            <summary>
            Generate code for QilNodeType.StrLength.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.IlGen.XmlILVisitor.VisitStrConcat(System.Xml.Xsl.Qil.QilStrConcat)">
            <summary>
            Generate code for QilNodeType.StrConcat.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.IlGen.XmlILVisitor.GenerateConcat(System.Xml.Xsl.Qil.QilNode,System.Reflection.Emit.LocalBuilder)">
            <summary>
            Generate code to concatenate string values returned by expression "ndStr" using the StringConcat helper class.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.IlGen.XmlILVisitor.VisitStrParseQName(System.Xml.Xsl.Qil.QilBinary)">
            <summary>
            Generate code for QilNodeType.StrParseQName.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.IlGen.XmlILVisitor.VisitStrParseQName(System.Xml.Xsl.Qil.QilBinary,System.Boolean)">
            <summary>
            Generate code for QilNodeType.StrParseQName.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.IlGen.XmlILVisitor.VisitNe(System.Xml.Xsl.Qil.QilBinary)">
            <summary>
            Generate code for QilNodeType.Ne.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.IlGen.XmlILVisitor.VisitEq(System.Xml.Xsl.Qil.QilBinary)">
            <summary>
            Generate code for QilNodeType.Eq.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.IlGen.XmlILVisitor.VisitGt(System.Xml.Xsl.Qil.QilBinary)">
            <summary>
            Generate code for QilNodeType.Gt.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.IlGen.XmlILVisitor.VisitGe(System.Xml.Xsl.Qil.QilBinary)">
            <summary>
            Generate code for QilNodeType.Ne.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.IlGen.XmlILVisitor.VisitLt(System.Xml.Xsl.Qil.QilBinary)">
            <summary>
            Generate code for QilNodeType.Lt.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.IlGen.XmlILVisitor.VisitLe(System.Xml.Xsl.Qil.QilBinary)">
            <summary>
            Generate code for QilNodeType.Le.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.IlGen.XmlILVisitor.Compare(System.Xml.Xsl.Qil.QilBinary)">
            <summary>
            Generate code for comparison operations.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.IlGen.XmlILVisitor.VisitIs(System.Xml.Xsl.Qil.QilBinary)">
            <summary>
            Generate code for QilNodeType.VisitIs.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.IlGen.XmlILVisitor.VisitBefore(System.Xml.Xsl.Qil.QilBinary)">
            <summary>
            Generate code for QilNodeType.VisitBefore.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.IlGen.XmlILVisitor.VisitAfter(System.Xml.Xsl.Qil.QilBinary)">
            <summary>
            Generate code for QilNodeType.VisitAfter.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.IlGen.XmlILVisitor.ComparePosition(System.Xml.Xsl.Qil.QilBinary)">
            <summary>
            Generate code for QilNodeType.VisitBefore and QilNodeType.VisitAfter.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.IlGen.XmlILVisitor.VisitFor(System.Xml.Xsl.Qil.QilIterator)">
            <summary>
            Generate code for a QilNodeType.For.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.IlGen.XmlILVisitor.VisitLet(System.Xml.Xsl.Qil.QilIterator)">
            <summary>
            Generate code for a QilNodeType.Let.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.IlGen.XmlILVisitor.VisitParameter(System.Xml.Xsl.Qil.QilParameter)">
            <summary>
            Generate code for a QilNodeType.Parameter.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.IlGen.XmlILVisitor.VisitLoop(System.Xml.Xsl.Qil.QilLoop)">
            <summary>
            Generate code for a QilNodeType.Loop.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.IlGen.XmlILVisitor.VisitFilter(System.Xml.Xsl.Qil.QilLoop)">
            <summary>
            Generate code for a QilNodeType.Filter.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.IlGen.XmlILVisitor.HandleFilterPatterns(System.Xml.Xsl.Qil.QilLoop)">
            <summary>
            There are a number of path patterns that can be rooted at Filter nodes.  Determine whether one of these patterns
            has been previously matched on "ndFilter".  If so, generate code for the pattern and return true.  Otherwise, just
            return false.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.IlGen.XmlILVisitor.StartBinding(System.Xml.Xsl.Qil.QilIterator)">
            <summary>
            Generate code for a Let, For, or Parameter iterator.  Bind iterated value to a variable.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.IlGen.XmlILVisitor.StartForBinding(System.Xml.Xsl.Qil.QilIterator,System.Xml.Xsl.IlGen.OptimizerPatterns)">
            <summary>
            Bind values produced by the "ndFor" expression to a non-stack location that can later
            be referenced.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.IlGen.XmlILVisitor.StartLetBinding(System.Xml.Xsl.Qil.QilIterator)">
            <summary>
            Bind values in the "ndLet" expression to a non-stack location that can later be referenced.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.IlGen.XmlILVisitor.EndBinding(System.Xml.Xsl.Qil.QilIterator)">
            <summary>
            Mark iterator variables as out-of-scope.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.IlGen.XmlILVisitor.VisitPositionOf(System.Xml.Xsl.Qil.QilUnary)">
            <summary>
            Generate code for QilNodeType.PositionOf.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.IlGen.XmlILVisitor.VisitSort(System.Xml.Xsl.Qil.QilLoop)">
            <summary>
            Generate code for QilNodeType.Sort.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.IlGen.XmlILVisitor.VisitSortKey(System.Xml.Xsl.Qil.QilSortKey,System.Reflection.Emit.LocalBuilder)">
            <summary>
            Generate code to add a (value, collation) sort key to the XmlSortKeyAccumulator.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.IlGen.XmlILVisitor.VisitDocOrderDistinct(System.Xml.Xsl.Qil.QilUnary)">
            <summary>
            Generate code for QilNodeType.DocOrderDistinct.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.IlGen.XmlILVisitor.HandleDodPatterns(System.Xml.Xsl.Qil.QilUnary)">
            <summary>
            There are a number of path patterns that can be rooted at DocOrderDistinct nodes.  Determine whether one of these
            patterns has been previously matched on "ndDod".  If so, generate code for the pattern and return true.  Otherwise,
            just return false.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.IlGen.XmlILVisitor.VisitInvoke(System.Xml.Xsl.Qil.QilInvoke)">
            <summary>
            Generate code for QilNodeType.Invoke.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.IlGen.XmlILVisitor.VisitContent(System.Xml.Xsl.Qil.QilUnary)">
            <summary>
            Generate code for QilNodeType.Content.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.IlGen.XmlILVisitor.VisitAttribute(System.Xml.Xsl.Qil.QilBinary)">
            <summary>
            Generate code for QilNodeType.Attribute.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.IlGen.XmlILVisitor.VisitParent(System.Xml.Xsl.Qil.QilUnary)">
            <summary>
            Generate code for QilNodeType.Parent.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.IlGen.XmlILVisitor.VisitRoot(System.Xml.Xsl.Qil.QilUnary)">
            <summary>
            Generate code for QilNodeType.Root.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.IlGen.XmlILVisitor.VisitXmlContext(System.Xml.Xsl.Qil.QilNode)">
            <summary>
            Generate code for QilNodeType.XmlContext.
            </summary>
            <remarks>
            Generates code to retrieve the default document using the XmlResolver.
            </remarks>
        </member>
        <member name="M:System.Xml.Xsl.IlGen.XmlILVisitor.VisitDescendant(System.Xml.Xsl.Qil.QilUnary)">
            <summary>
            Find physical query plan for QilNodeType.Descendant.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.IlGen.XmlILVisitor.VisitDescendantOrSelf(System.Xml.Xsl.Qil.QilUnary)">
            <summary>
            Generate code for QilNodeType.DescendantOrSelf.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.IlGen.XmlILVisitor.VisitAncestor(System.Xml.Xsl.Qil.QilUnary)">
            <summary>
            Find physical query plan for QilNodeType.Ancestor.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.IlGen.XmlILVisitor.VisitAncestorOrSelf(System.Xml.Xsl.Qil.QilUnary)">
            <summary>
            Find physical query plan for QilNodeType.AncestorOrSelf.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.IlGen.XmlILVisitor.VisitPreceding(System.Xml.Xsl.Qil.QilUnary)">
            <summary>
            Find physical query plan for QilNodeType.Preceding.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.IlGen.XmlILVisitor.VisitFollowingSibling(System.Xml.Xsl.Qil.QilUnary)">
            <summary>
            Find physical query plan for QilNodeType.FollowingSibling.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.IlGen.XmlILVisitor.VisitPrecedingSibling(System.Xml.Xsl.Qil.QilUnary)">
            <summary>
            Find physical query plan for QilNodeType.PrecedingSibling.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.IlGen.XmlILVisitor.VisitNodeRange(System.Xml.Xsl.Qil.QilBinary)">
            <summary>
            Find physical query plan for QilNodeType.NodeRange.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.IlGen.XmlILVisitor.VisitDeref(System.Xml.Xsl.Qil.QilBinary)">
            <summary>
            Generate code for QilNodeType.Deref.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.IlGen.XmlILVisitor.VisitElementCtor(System.Xml.Xsl.Qil.QilBinary)">
            <summary>
            Generate code for QilNodeType.ElementCtor.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.IlGen.XmlILVisitor.VisitAttributeCtor(System.Xml.Xsl.Qil.QilBinary)">
            <summary>
            Generate code for QilNodeType.AttributeCtor.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.IlGen.XmlILVisitor.VisitCommentCtor(System.Xml.Xsl.Qil.QilUnary)">
            <summary>
            Generate code for QilNodeType.CommentCtor.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.IlGen.XmlILVisitor.VisitPICtor(System.Xml.Xsl.Qil.QilBinary)">
            <summary>
            Generate code for QilNodeType.PICtor.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.IlGen.XmlILVisitor.VisitTextCtor(System.Xml.Xsl.Qil.QilUnary)">
            <summary>
            Generate code for QilNodeType.TextCtor.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.IlGen.XmlILVisitor.VisitRawTextCtor(System.Xml.Xsl.Qil.QilUnary)">
            <summary>
            Generate code for QilNodeType.RawTextCtor.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.IlGen.XmlILVisitor.VisitTextCtor(System.Xml.Xsl.Qil.QilUnary,System.Boolean)">
            <summary>
            Generate code for QilNodeType.TextCtor and QilNodeType.RawTextCtor.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.IlGen.XmlILVisitor.VisitDocumentCtor(System.Xml.Xsl.Qil.QilUnary)">
            <summary>
            Generate code for QilNodeType.DocumentCtor.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.IlGen.XmlILVisitor.VisitNamespaceDecl(System.Xml.Xsl.Qil.QilBinary)">
            <summary>
            Generate code for QilNodeType.NamespaceDecl.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.IlGen.XmlILVisitor.VisitRtfCtor(System.Xml.Xsl.Qil.QilBinary)">
            <summary>
            Generate code for QilNodeType.RtfCtor.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.IlGen.XmlILVisitor.VisitNameOf(System.Xml.Xsl.Qil.QilUnary)">
            <summary>
            Generate code for QilNodeType.NameOf.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.IlGen.XmlILVisitor.VisitLocalNameOf(System.Xml.Xsl.Qil.QilUnary)">
            <summary>
            Generate code for QilNodeType.LocalNameOf.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.IlGen.XmlILVisitor.VisitNamespaceUriOf(System.Xml.Xsl.Qil.QilUnary)">
            <summary>
            Generate code for QilNodeType.NamespaceUriOf.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.IlGen.XmlILVisitor.VisitPrefixOf(System.Xml.Xsl.Qil.QilUnary)">
            <summary>
            Generate code for QilNodeType.PrefixOf.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.IlGen.XmlILVisitor.VisitNodeProperty(System.Xml.Xsl.Qil.QilUnary)">
            <summary>
            Generate code to push the local name, namespace uri, or qname of the context navigator.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.IlGen.XmlILVisitor.VisitTypeAssert(System.Xml.Xsl.Qil.QilTargetType)">
            <summary>
            Find physical query plan for QilNodeType.TypeAssert.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.IlGen.XmlILVisitor.VisitIsType(System.Xml.Xsl.Qil.QilTargetType)">
            <summary>
            Generate code for QilNodeType.IsType.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.IlGen.XmlILVisitor.MatchesNodeKinds(System.Xml.Xsl.Qil.QilTargetType,System.Xml.Xsl.XmlQueryType,System.Xml.Xsl.XmlQueryType)">
            <summary>
            Faster code can be generated if type test is just a node kind test.  If this special case is detected, then generate code and return true.
            Otherwise, return false, and a call to MatchesXmlType will be generated instead.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.IlGen.XmlILVisitor.VisitIsEmpty(System.Xml.Xsl.Qil.QilUnary)">
             <summary>
             Generate code for QilNodeType.IsEmpty.
             </summary>
             <remarks>
             BranchingContext.OnFalse context: is-empty(expr)
             ==> foreach (item in expr)
                     goto LabelBranch;
            
             BranchingContext.OnTrue context: is-empty(expr)
             ==> foreach (item in expr)
                     break;
                 ...
                 LabelOnEnd: (called if foreach is empty)
                 goto LabelBranch;
            
             BranchingContext.None context: is-empty(expr)
             ==> foreach (item in expr)
                     break;
                 push true();
                 ...
                 LabelOnEnd: (called if foreach is empty)
                 push false();
             </remarks>
        </member>
        <member name="M:System.Xml.Xsl.IlGen.XmlILVisitor.VisitXPathNodeValue(System.Xml.Xsl.Qil.QilUnary)">
            <summary>
            Generate code for QilNodeType.XPathNodeValue.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.IlGen.XmlILVisitor.VisitXPathFollowing(System.Xml.Xsl.Qil.QilUnary)">
            <summary>
            Find physical query plan for QilNodeType.XPathFollowing.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.IlGen.XmlILVisitor.VisitXPathPreceding(System.Xml.Xsl.Qil.QilUnary)">
            <summary>
            Find physical query plan for QilNodeType.XPathPreceding.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.IlGen.XmlILVisitor.VisitXPathNamespace(System.Xml.Xsl.Qil.QilUnary)">
            <summary>
            Find physical query plan for QilNodeType.XPathNamespace.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.IlGen.XmlILVisitor.VisitXsltGenerateId(System.Xml.Xsl.Qil.QilUnary)">
            <summary>
            Generate code for QilNodeType.XsltGenerateId.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.IlGen.XmlILVisitor.VisitXsltInvokeLateBound(System.Xml.Xsl.Qil.QilInvokeLateBound)">
            <summary>
            Generate code for QilNodeType.XsltInvokeLateBound.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.IlGen.XmlILVisitor.VisitXsltInvokeEarlyBound(System.Xml.Xsl.Qil.QilInvokeEarlyBound)">
            <summary>
            Generate code for QilNodeType.XsltInvokeEarlyBound.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.IlGen.XmlILVisitor.VisitXsltCopy(System.Xml.Xsl.Qil.QilBinary)">
            <summary>
            Generate code for QilNodeType.XsltCopy.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.IlGen.XmlILVisitor.VisitXsltCopyOf(System.Xml.Xsl.Qil.QilUnary)">
            <summary>
            Generate code for QilNodeType.XsltCopyOf.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.IlGen.XmlILVisitor.VisitXsltConvert(System.Xml.Xsl.Qil.QilTargetType)">
            <summary>
            Generate code for QilNodeType.XsltConvert.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.IlGen.XmlILVisitor.GetXsltConvertMethod(System.Xml.Xsl.XmlQueryType,System.Xml.Xsl.XmlQueryType,System.Reflection.MethodInfo@)">
            <summary>
            Get the XsltConvert method that converts from "typSrc" to "typDst".  Return false if no
            such method exists.  This conversion matrix should match the one in XsltConvert.ExternalValueToExternalValue.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.IlGen.XmlILVisitor.SyncToNavigator(System.Reflection.Emit.LocalBuilder,System.Xml.Xsl.Qil.QilNode)">
            <summary>
            Ensure that the "locNav" navigator is positioned to the context node "ndCtxt".
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.IlGen.XmlILVisitor.CreateSimpleIterator(System.Xml.Xsl.Qil.QilNode,System.String,System.Type,System.Reflection.MethodInfo,System.Reflection.MethodInfo,System.Reflection.MethodInfo)">
            <summary>
            Generate boiler-plate code to create a simple Xml iterator.
            </summary>
            <remarks>
                Iterator iter;
                iter.Create(navCtxt);
            LabelNext:
                if (!iter.MoveNext())
                    goto LabelNextCtxt;
            </remarks>
        </member>
        <member name="M:System.Xml.Xsl.IlGen.XmlILVisitor.CreateFilteredIterator(System.Xml.Xsl.Qil.QilNode,System.String,System.Type,System.Reflection.MethodInfo,System.Reflection.MethodInfo,System.Reflection.MethodInfo,System.Xml.Xsl.XmlNodeKindFlags,System.Xml.Xsl.Qil.QilName,System.Xml.TriState,System.Xml.Xsl.Qil.QilNode)">
            <summary>
            Generate boiler-plate code to create an Xml iterator that uses an XmlNavigatorFilter to filter items.
            </summary>
            <remarks>
                Iterator iter;
                iter.Create(navCtxt, filter [, orSelf] [, navEnd]);
            LabelNext:
                if (!iter.MoveNext())
                    goto LabelNextCtxt;
            </remarks>
        </member>
        <member name="M:System.Xml.Xsl.IlGen.XmlILVisitor.CreateContainerIterator(System.Xml.Xsl.Qil.QilUnary,System.String,System.Type,System.Reflection.MethodInfo,System.Reflection.MethodInfo,System.Reflection.MethodInfo,System.Xml.Xsl.XmlNodeKindFlags,System.Xml.Xsl.Qil.QilName,System.Xml.TriState)">
            <summary>
            Generate boiler-plate code to create an Xml iterator that controls a nested iterator.
            </summary>
            <remarks>
                Iterator iter;
                iter.Create(filter [, orSelf]);
                    ...nested iterator...
                navInput = nestedNested;
                goto LabelCall;
            LabelNext:
                navInput = null;
            LabelCall:
                switch (iter.MoveNext(navInput)) {
                    case IteratorState.NoMoreNodes: goto LabelNextCtxt;
                    case IteratorState.NextInputNode: goto LabelNextNested;
                }
            </remarks>
        </member>
        <member name="M:System.Xml.Xsl.IlGen.XmlILVisitor.GenerateSimpleIterator(System.Type,System.Reflection.Emit.LocalBuilder,System.Reflection.MethodInfo,System.Reflection.MethodInfo)">
            <summary>
            Generate boiler-plate code that calls MoveNext on a simple Xml iterator.  Iterator should have already been
            created by calling code.
            </summary>
            <remarks>
                ...
            LabelNext:
                if (!iter.MoveNext())
                    goto LabelNextCtxt;
            </remarks>
        </member>
        <member name="M:System.Xml.Xsl.IlGen.XmlILVisitor.GenerateContainerIterator(System.Xml.Xsl.Qil.QilNode,System.Reflection.Emit.LocalBuilder,System.Reflection.Emit.Label,System.Reflection.MethodInfo,System.Reflection.MethodInfo,System.Type)">
            <summary>
            Generate boiler-plate code that calls MoveNext on an Xml iterator that controls a nested iterator.  Iterator should
            have already been created by calling code.
            </summary>
            <remarks>
                ...
                goto LabelCall;
            LabelNext:
                navCtxt = null;
            LabelCall:
                switch (iter.MoveNext(navCtxt)) {
                    case IteratorState.NoMoreNodes: goto LabelNextCtxt;
                    case IteratorState.NextInputNode: goto LabelNextNested;
                }
            </remarks>
        </member>
        <member name="M:System.Xml.Xsl.IlGen.XmlILVisitor.LoadNameAndType(System.Xml.XPath.XPathNodeType,System.Xml.Xsl.Qil.QilNode,System.Boolean,System.Boolean)">
            <summary>
            Load XmlQueryOutput, load a name (computed or literal) and load an index to an Xml schema type.
            Return an enumeration that specifies what kind of name was loaded.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.IlGen.XmlILVisitor.TryZeroCompare(System.Xml.Xsl.Qil.QilNodeType,System.Xml.Xsl.Qil.QilNode,System.Xml.Xsl.Qil.QilNode)">
            <summary>
            If the first argument is a constant value that evaluates to zero, then a more optimal instruction sequence
            can be generated that does not have to push the zero onto the stack.  Instead, a Brfalse or Brtrue instruction
            can be used.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.IlGen.XmlILVisitor.TryNameCompare(System.Xml.Xsl.Qil.QilNodeType,System.Xml.Xsl.Qil.QilNode,System.Xml.Xsl.Qil.QilNode)">
            <summary>
            If the comparison involves a qname, then perform comparison using atoms and return true.
            Otherwise, return false (caller will perform comparison).
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.IlGen.XmlILVisitor.ClrCompare(System.Xml.Xsl.Qil.QilNodeType,System.Xml.Schema.XmlTypeCode)">
            <summary>
            For QilExpression types that map directly to CLR primitive types, the built-in CLR comparison operators can
            be used to perform the specified relational operation.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.IlGen.XmlILVisitor.ZeroCompare(System.Xml.Xsl.Qil.QilNodeType,System.Boolean)">
            <summary>
            Generate code to compare the top stack value to 0 by using the Brfalse or Brtrue instructions,
            which avoid pushing zero onto the stack.  Both of these instructions test for null/zero/false.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.IlGen.XmlILVisitor.StartWriterLoop(System.Xml.Xsl.Qil.QilNode,System.Boolean@,System.Reflection.Emit.Label@)">
            <summary>
            Construction within a loop is starting.  If transition from non-Any to Any state occurs, then ensure
            that runtime state will be set.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.IlGen.XmlILVisitor.EndWriterLoop(System.Xml.Xsl.Qil.QilNode,System.Boolean,System.Reflection.Emit.Label)">
            <summary>
            Construction within a loop is ending.  If transition from non-Any to Any state occurs, then ensure that
            runtime state will be set.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.IlGen.XmlILVisitor.MightHaveNamespacesAfterAttributes(System.Xml.Xsl.IlGen.XmlILConstructInfo)">
            <summary>
            Returns true if the specified node's owner element might have local namespaces added to it
            after attributes have already been added.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.IlGen.XmlILVisitor.ElementCachesAttributes(System.Xml.Xsl.IlGen.XmlILConstructInfo)">
            <summary>
            Returns true if the specified element should cache attributes.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.IlGen.XmlILVisitor.BeforeStartChecks(System.Xml.Xsl.Qil.QilNode)">
            <summary>
            This method is called before calling any WriteEnd??? method.  It generates code to perform runtime
            construction checks separately.  This should only be called if the XmlQueryOutput::StartElementChk
            method will *not* be called.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.IlGen.XmlILVisitor.AfterEndChecks(System.Xml.Xsl.Qil.QilNode)">
            <summary>
            This method is called after calling any WriteEnd??? method.  It generates code to perform runtime
            construction checks separately.  This should only be called if the XmlQueryOutput::EndElementChk
            method will *not* be called.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.IlGen.XmlILVisitor.CheckWithinContent(System.Xml.Xsl.IlGen.XmlILConstructInfo)">
            <summary>
            Return true if a runtime check needs to be made in order to transition into the WithinContent state.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.IlGen.XmlILVisitor.CheckEnumAttrs(System.Xml.Xsl.IlGen.XmlILConstructInfo)">
            <summary>
            Return true if a runtime check needs to be made in order to transition into the EnumAttrs state.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.IlGen.XmlILVisitor.QilXmlToXPathNodeType(System.Xml.Xsl.XmlNodeKindFlags)">
            <summary>
            Map the XmlNodeKindFlags enumeration into the XPathNodeType enumeration.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.IlGen.XmlILVisitor.QilConstructorToNodeType(System.Xml.Xsl.Qil.QilNodeType)">
            <summary>
            Map a QilExpression constructor type into the XPathNodeType enumeration.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.IlGen.XmlILVisitor.LoadSelectFilter(System.Xml.Xsl.XmlNodeKindFlags,System.Xml.Xsl.Qil.QilName)">
            <summary>
            Load an XmlNavigatorFilter that matches only the specified name and types onto the stack.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.IlGen.XmlILVisitor.IsNodeTypeUnion(System.Xml.Xsl.XmlNodeKindFlags)">
            <summary>
            Return true if more than one node type is set.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.IlGen.XmlILVisitor.StartNestedIterator">
            <summary>
            Start construction of a new nested iterator.  If this.iterCurr == null, then the new iterator
            is a top-level, or root iterator.  Otherwise, the new iterator will be nested within the
            current iterator.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.IlGen.XmlILVisitor.StartNestedIterator(System.Reflection.Emit.Label)">
            <summary>
            Calls StartNestedIterator(nd) and also sets up the nested iterator to branch to "lblOnEnd" when iteration
            is complete.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.IlGen.XmlILVisitor.EndNestedIterator(System.Xml.Xsl.Qil.QilNode)">
            <summary>
            End construction of the current iterator.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.IlGen.XmlILVisitor.NestedVisit(System.Xml.Xsl.Qil.QilNode,System.Type,System.Boolean)">
            <summary>
            Recursively generate code to iterate over the results of the "nd" expression.  If "nd" is pushed
            to the writer, then there are no results.  If "nd" is a singleton expression and isCached is false,
            then generate code to construct the singleton.  Otherwise, cache the sequence in an XmlQuerySequence
            object.  Ensure that all items are converted to the specified "itemStorageType".
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.IlGen.XmlILVisitor.NestedVisit(System.Xml.Xsl.Qil.QilNode)">
            <summary>
            Calls NestedVisit(QilNode, Type, bool), storing result in the default storage type for "nd".
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.IlGen.XmlILVisitor.NestedVisit(System.Xml.Xsl.Qil.QilNode,System.Reflection.Emit.Label)">
            <summary>
            Recursively generate code to iterate over the results of the "nd" expression.  When the expression
            has been fully iterated, it will jump to "lblOnEnd".
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.IlGen.XmlILVisitor.NestedVisitEnsureStack(System.Xml.Xsl.Qil.QilNode)">
            <summary>
            Call NestedVisit(QilNode) and ensure that result is pushed onto the IL stack.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.IlGen.XmlILVisitor.NestedVisitEnsureStack(System.Xml.Xsl.Qil.QilNode,System.Xml.Xsl.Qil.QilNode)">
            <summary>
            Generate code for both QilExpression nodes and ensure that each result is pushed onto the IL stack.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.IlGen.XmlILVisitor.NestedVisitEnsureStack(System.Xml.Xsl.Qil.QilNode,System.Type,System.Boolean)">
            <summary>
            Call NestedVisit(QilNode, Type, bool) and ensure that result is pushed onto the IL stack.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.IlGen.XmlILVisitor.NestedVisitEnsureLocal(System.Xml.Xsl.Qil.QilNode,System.Reflection.Emit.LocalBuilder)">
            <summary>
            Call NestedVisit(QilNode) and ensure that result is stored in local variable "loc".
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.IlGen.XmlILVisitor.NestedVisitWithBranch(System.Xml.Xsl.Qil.QilNode,System.Xml.Xsl.IlGen.BranchingContext,System.Reflection.Emit.Label)">
            <summary>
            Start a nested iterator in a branching context and recursively generate code for the specified QilExpression node.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.IlGen.XmlILVisitor.NestedVisitEnsureCache(System.Xml.Xsl.Qil.QilNode,System.Type)">
            <summary>
            Generate code for the QilExpression node and ensure that results are fully cached as an XmlQuerySequence.  All results
            should be converted to "itemStorageType" before being added to the cache.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.IlGen.XmlILVisitor.CachesResult(System.Xml.Xsl.Qil.QilNode)">
            <summary>
            Returns true if the specified QilExpression node type is *guaranteed* to cache its results in an XmlQuerySequence,
            where items in the cache are stored using the default storage type.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.IlGen.XmlILVisitor.GetStorageType(System.Xml.Xsl.Qil.QilNode)">
            <summary>
            Shortcut call to XmlILTypeHelper.GetStorageType.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.IlGen.XmlILVisitor.GetStorageType(System.Xml.Xsl.XmlQueryType)">
            <summary>
            Shortcut call to XmlILTypeHelper.GetStorageType.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.IlGen.XmlILVisitor.GetItemStorageType(System.Xml.Xsl.Qil.QilNode)">
            <summary>
            Shortcut call to XmlILTypeHelper.GetStorageType, using an expression's prime type.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.IlGen.XmlILVisitor.GetItemStorageType(System.Xml.Xsl.XmlQueryType)">
            <summary>
            Shortcut call to XmlILTypeHelper.GetStorageType, using the prime type.
            </summary>
        </member>
        <member name="T:System.Xml.Xsl.XmlILGenerator">
             <summary>
             This internal class is the entry point for creating Msil assemblies from QilExpression.
             </summary>
             <remarks>
             Generate will return an AssemblyBuilder with the following setup:
             Assembly Name = "MS.Internal.Xml.CompiledQuery"
             Module Dll Name = "MS.Internal.Xml.CompiledQuery.dll"
             public class MS.Internal.Xml.CompiledQuery.Test {
                 public static void Execute(XmlQueryRuntime runtime);
                 public static void Root(XmlQueryRuntime runtime);
                 private static ... UserMethod1(XmlQueryRuntime runtime, ...);
                 ...
                 private static ... UserMethodN(XmlQueryRuntime runtime, ...);
             }
            
             XmlILGenerator incorporates a number of different technologies in order to generate efficient code that avoids caching
             large result sets in memory:
            
             1. Code Iterators - Query results are computed using a set of composable, interlocking iterators that alone perform a
             simple task, but together execute complex queries.  The iterators are actually little blocks of code
             that are connected to each other using a series of jumps.  Because each iterator is not instantiated
             as a separate object, the number of objects and number of function calls is kept to a minimum during
             execution.  Also, large result sets are often computed incrementally, with each iterator performing one step in a
             pipeline of sequence items.
            
             2. Analyzers - During code generation, QilToMsil traverses the semantic tree representation of the query (QIL) several times.
             As visits to each node in the tree start and end, various Analyzers are invoked.  These Analyzers incrementally
             collect and store information that is later used to generate faster and smaller code.
             </remarks>
        </member>
        <member name="M:System.Xml.Xsl.XmlILGenerator.#ctor">
            <summary>
            Always output debug information in debug mode.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.XmlILGenerator.Generate(System.Xml.Xsl.Qil.QilExpression,System.Reflection.Emit.TypeBuilder)">
            <summary>
            Given the logical query plan (QilExpression) generate a physical query plan (MSIL) that can be executed.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.XmlILGenerator.CreateFunctionMetadata(System.Collections.Generic.IList{System.Xml.Xsl.Qil.QilNode})">
            <summary>
            Create MethodBuilder metadata for the specified QilExpression function.  Annotate ndFunc with the
            MethodBuilder.  Also, each QilExpression argument type should be converted to a corresponding Clr type.
            Each argument QilExpression node should be annotated with the resulting ParameterBuilder.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.XmlILGenerator.CreateGlobalValueMetadata(System.Collections.Generic.IList{System.Xml.Xsl.Qil.QilNode})">
            <summary>
            Generate metadata for a method that calculates a global value.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.XmlILGenerator.GenerateExecuteFunction(System.Reflection.MethodInfo,System.Reflection.MethodInfo)">
            <summary>
            Generate the "Execute" method, which is the entry point to the query.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.XmlILGenerator.CreateHelperFunctions">
            <summary>
            Create and generate various helper methods, which are called by the generated code.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.XmlILGenerator.EvaluateGlobalValues(System.Collections.Generic.IList{System.Xml.Xsl.Qil.QilNode})">
            <summary>
            Generate code to force evaluation of some or all global variables and/or parameters.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.XmlILGenerator.CreateTypeInitializer(System.Xml.Xsl.Runtime.XmlQueryStaticData)">
            <summary>
            Create static constructor that initializes XmlQueryStaticData instance at runtime.
            </summary>
        </member>
        <member name="T:System.Xml.Xsl.XmlILCommand">
            <summary>
            This is the executable command generated by the XmlILGenerator.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.XmlILCommand.#ctor(System.Xml.Xsl.ExecuteDelegate,System.Xml.Xsl.Runtime.XmlQueryStaticData)">
            <summary>
            Constructor.
            </summary>
        </member>
        <member name="P:System.Xml.Xsl.XmlILCommand.StaticData">
            <summary>
            Return query static data required by the runtime.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.XmlILCommand.Execute(System.Object,System.Xml.XmlResolver,System.Xml.Xsl.XsltArgumentList,System.Xml.XmlWriter)">
            <summary>
            Execute the dynamic assembly generated by the XmlILGenerator.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.XmlILCommand.Execute(System.Object,System.Xml.XmlResolver,System.Xml.Xsl.XsltArgumentList,System.Xml.Xsl.Runtime.XmlSequenceWriter)">
            <summary>
            Execute the dynamic assembly generated by the XmlILGenerator.
            </summary>
        </member>
        <member name="T:System.Xml.Xsl.ListBase`1">
            <summary>
            Implementation of read-only IList and IList{T} interfaces.  Derived classes can inherit from
            this class and implement only two methods, Count and Item, rather than the entire IList interface.
            </summary>
        </member>
        <member name="T:System.Xml.Xsl.IListEnumerator`1">
            <summary>
            Implementation of IEnumerator{T} and IEnumerator over an IList{T}.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.IListEnumerator`1.#ctor(System.Collections.Generic.IList{`0})">
            <summary>
            Constructor.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.IListEnumerator`1.Dispose">
            <summary>
            No-op.
            </summary>
        </member>
        <member name="P:System.Xml.Xsl.IListEnumerator`1.Current">
            <summary>
            Return current item.  Return default value if before first item or after last item in the list.
            </summary>
        </member>
        <member name="P:System.Xml.Xsl.IListEnumerator`1.System#Collections#IEnumerator#Current">
            <summary>
            Return current item.  Throw exception if before first item or after last item in the list.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.IListEnumerator`1.MoveNext">
            <summary>
            Advance enumerator to next item in list.  Return false if there are no more items.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.IListEnumerator`1.System#Collections#IEnumerator#Reset">
            <summary>
            Set the enumerator to its initial position, which is before the first item in the list.
            </summary>
        </member>
        <member name="T:System.Xml.Xsl.Qil.QilBinary">
            <summary>
            View over a Qil operator having two children.
            </summary>
            <remarks>
            Don't construct QIL nodes directly; instead, use the <see cref="T:System.Xml.Xsl.Qil.QilFactory">QilFactory</see>.
            </remarks>
        </member>
        <member name="M:System.Xml.Xsl.Qil.QilBinary.#ctor(System.Xml.Xsl.Qil.QilNodeType,System.Xml.Xsl.Qil.QilNode,System.Xml.Xsl.Qil.QilNode)">
            <summary>
            Construct a new node
            </summary>
        </member>
        <member name="T:System.Xml.Xsl.Qil.QilChoice">
            <summary>
            View over a Qil choice operator.
            </summary>
            <remarks>
            Don't construct QIL nodes directly; instead, use the <see cref="T:System.Xml.Xsl.Qil.QilFactory">QilFactory</see>.
            </remarks>
        </member>
        <member name="M:System.Xml.Xsl.Qil.QilChoice.#ctor(System.Xml.Xsl.Qil.QilNodeType,System.Xml.Xsl.Qil.QilNode,System.Xml.Xsl.Qil.QilNode)">
            <summary>
            Construct a new node
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Qil.QilCloneVisitor.Visit(System.Xml.Xsl.Qil.QilNode)">
            <summary>
            Visit all children of "parent", replacing each child with a copy of each child.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Qil.QilCloneVisitor.VisitChildren(System.Xml.Xsl.Qil.QilNode)">
            <summary>
            Visit all children of "parent", replacing each child with a copy of each child.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Qil.QilCloneVisitor.VisitReference(System.Xml.Xsl.Qil.QilNode)">
            <summary>
            If a cloned reference is in scope, replace "oldNode".  Otherwise, return "oldNode".
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Qil.QilCloneVisitor.BeginScope(System.Xml.Xsl.Qil.QilNode)">
            <summary>
            Push node and its shallow clone onto the substitution list.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Qil.QilCloneVisitor.EndScope(System.Xml.Xsl.Qil.QilNode)">
            <summary>
            Pop entry from substitution list.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Qil.QilCloneVisitor.FindClonedReference(System.Xml.Xsl.Qil.QilNode)">
            <summary>
            Find the clone of an in-scope reference.
            </summary>
        </member>
        <member name="T:System.Xml.Xsl.Qil.QilDataSource">
            <summary>
            View over a Qil DataSource operator.
            </summary>
            <remarks>
            Don't construct QIL nodes directly; instead, use the <see cref="T:System.Xml.Xsl.Qil.QilFactory">QilFactory</see>.
            </remarks>
        </member>
        <member name="M:System.Xml.Xsl.Qil.QilDataSource.#ctor(System.Xml.Xsl.Qil.QilNodeType,System.Xml.Xsl.Qil.QilNode,System.Xml.Xsl.Qil.QilNode)">
            <summary>
            Construct a new node
            </summary>
        </member>
        <member name="T:System.Xml.Xsl.Qil.QilExpression">
            <summary>
            The CQR implementation of QilExpression.
            </summary>
            <remarks>
               <p>QilExpression is the XML Query Intermediate Language invented by Michael Brundage and Chris Suver.
               QilExpression is an intermediate representation (IR) for all XML query and view languages.  QilExpression is
               designed for optimization, composition with virtual XML views, translation into other forms,
               and direct execution.  See also <a href="http://dynamo/qil/qil.xml">the QIL specification</a>.</p>
            </remarks>
        </member>
        <member name="M:System.Xml.Xsl.Qil.QilExpression.#ctor(System.Xml.Xsl.Qil.QilNodeType,System.Xml.Xsl.Qil.QilNode,System.Xml.Xsl.Qil.QilFactory)">
            <summary>
            Construct QIL from a rooted graph of QilNodes with a specific factory.
            </summary>
        </member>
        <member name="P:System.Xml.Xsl.Qil.QilExpression.Factory">
            <summary>
            QilFactory to be used in constructing nodes in this graph.
            </summary>
        </member>
        <member name="P:System.Xml.Xsl.Qil.QilExpression.IsDebug">
            <summary>
            True if this expression contains debugging information.
            </summary>
        </member>
        <member name="P:System.Xml.Xsl.Qil.QilExpression.DefaultWriterSettings">
            <summary>
            Default serialization options that will be used if the user does not supply a writer at execution time.
            </summary>
        </member>
        <member name="P:System.Xml.Xsl.Qil.QilExpression.WhitespaceRules">
            <summary>
            Xslt whitespace strip/preserve rules.
            </summary>
        </member>
        <member name="P:System.Xml.Xsl.Qil.QilExpression.GlobalParameterList">
            <summary>
            External parameters.
            </summary>
        </member>
        <member name="P:System.Xml.Xsl.Qil.QilExpression.GlobalVariableList">
            <summary>
            Global variables.
            </summary>
        </member>
        <member name="P:System.Xml.Xsl.Qil.QilExpression.EarlyBoundTypes">
            <summary>
            Early bound function objects.
            </summary>
        </member>
        <member name="P:System.Xml.Xsl.Qil.QilExpression.FunctionList">
            <summary>
            Function definitions.
            </summary>
        </member>
        <member name="P:System.Xml.Xsl.Qil.QilExpression.Root">
            <summary>
            The root node of the QilExpression graph
            </summary>
        </member>
        <member name="T:System.Xml.Xsl.Qil.QilFactory">
            <summary>
            Factory methods for constructing QilExpression nodes.
            </summary>
            <remarks>
            See <see href="http://dynamo/qil/qil.xml">the QIL functional specification</see> for documentation.
            </remarks>
        </member>
        <member name="T:System.Xml.Xsl.Qil.QilFunction">
            <summary>
            An anonymous QilExpression function node.
            </summary>
            <remarks>
            <para>Function is a block, so it may introduce assignments (scoped to the function body).
            Additionally, it has an argument list, which will be assigned values
            when the function is invoked.</para>
            <para>The XmlType property defines the expected return type of this function.
            Normally, this should be the same as its definition's types, so setting the function
            definition changes the function's types.  In some rare cases, a compiler may wish to
            override the types after setting the function's definition (for example, an XQuery
            might define a function's return type to be wider than its definition would imply.)</para>
            </remarks>
        </member>
        <member name="M:System.Xml.Xsl.Qil.QilFunction.#ctor(System.Xml.Xsl.Qil.QilNodeType,System.Xml.Xsl.Qil.QilNode,System.Xml.Xsl.Qil.QilNode,System.Xml.Xsl.Qil.QilNode,System.Xml.Xsl.XmlQueryType)">
            <summary>
            Construct a node
            </summary>
        </member>
        <member name="P:System.Xml.Xsl.Qil.QilFunction.Arguments">
            <summary>
            Formal arguments of this function.
            </summary>
        </member>
        <member name="P:System.Xml.Xsl.Qil.QilFunction.Definition">
            <summary>
            Body of this function.
            </summary>
        </member>
        <member name="P:System.Xml.Xsl.Qil.QilFunction.MaybeSideEffects">
            <summary>
            QilNodeType.True if this function might have side-effects.
            </summary>
        </member>
        <member name="T:System.Xml.Xsl.Qil.QilInvoke">
            <summary>
            A function invocation node which represents a call to a Qil functions.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Qil.QilInvoke.#ctor(System.Xml.Xsl.Qil.QilNodeType,System.Xml.Xsl.Qil.QilNode,System.Xml.Xsl.Qil.QilNode)">
            <summary>
            Construct a new node
            </summary>
        </member>
        <member name="T:System.Xml.Xsl.Qil.QilInvokeEarlyBound">
            <summary>
            A function invocation node which represents a call to an early bound Clr function.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Qil.QilInvokeEarlyBound.#ctor(System.Xml.Xsl.Qil.QilNodeType,System.Xml.Xsl.Qil.QilNode,System.Xml.Xsl.Qil.QilNode,System.Xml.Xsl.Qil.QilNode,System.Xml.Xsl.XmlQueryType)">
            <summary>
            Construct a new node
            </summary>
        </member>
        <member name="T:System.Xml.Xsl.Qil.QilInvokeLateBound">
            <summary>
            A function invocation node which represents a call to an late bound function.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Qil.QilInvokeLateBound.#ctor(System.Xml.Xsl.Qil.QilNodeType,System.Xml.Xsl.Qil.QilNode,System.Xml.Xsl.Qil.QilNode)">
            <summary>
            Construct a new node
            </summary>
        </member>
        <member name="T:System.Xml.Xsl.Qil.QilIterator">
            <summary>
            View over a Qil iterator node (For or Let).
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Qil.QilIterator.#ctor(System.Xml.Xsl.Qil.QilNodeType,System.Xml.Xsl.Qil.QilNode)">
            <summary>
            Construct an iterator
            </summary>
        </member>
        <member name="P:System.Xml.Xsl.Qil.QilIterator.Binding">
            <summary>
            Expression which is bound to the iterator.
            </summary>
        </member>
        <member name="T:System.Xml.Xsl.Qil.QilList">
            <summary>
            View over a Qil operator having N children.
            </summary>
            <remarks>
            Don't construct QIL nodes directly; instead, use the <see cref="T:System.Xml.Xsl.Qil.QilFactory">QilFactory</see>.
            </remarks>
        </member>
        <member name="M:System.Xml.Xsl.Qil.QilList.#ctor(System.Xml.Xsl.Qil.QilNodeType)">
            <summary>
            Construct a new (empty) QilList
            </summary>
        </member>
        <member name="P:System.Xml.Xsl.Qil.QilList.XmlType">
            <summary>
            Lazily create the XmlQueryType.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Qil.QilList.ShallowClone(System.Xml.Xsl.Qil.QilFactory)">
            <summary>
            Override in order to clone the "members" array.
            </summary>
        </member>
        <member name="T:System.Xml.Xsl.Qil.QilLiteral">
            <summary>
            View over a Qil atomic value literal (of any type).
            </summary>
            <remarks>
            Don't construct QIL nodes directly; instead, use the <see cref="T:System.Xml.Xsl.Qil.QilFactory">QilFactory</see>.
            </remarks>
        </member>
        <member name="M:System.Xml.Xsl.Qil.QilLiteral.#ctor(System.Xml.Xsl.Qil.QilNodeType,System.Object)">
            <summary>
            Construct a new node
            </summary>
        </member>
        <member name="T:System.Xml.Xsl.Qil.QilLoop">
            <summary>
            View over a Qil operators that introduce iterators (Loop, Filter, etc.).
            </summary>
            <remarks>
            Don't construct QIL nodes directly; instead, use the <see cref="T:System.Xml.Xsl.Qil.QilFactory">QilFactory</see>.
            </remarks>
        </member>
        <member name="M:System.Xml.Xsl.Qil.QilLoop.#ctor(System.Xml.Xsl.Qil.QilNodeType,System.Xml.Xsl.Qil.QilNode,System.Xml.Xsl.Qil.QilNode)">
            <summary>
            Construct a new node
            </summary>
        </member>
        <member name="T:System.Xml.Xsl.Qil.QilName">
            <summary>
            View over a Qil name literal.
            </summary>
            <remarks>
            Don't construct QIL nodes directly; instead, use the <see cref="T:System.Xml.Xsl.Qil.QilFactory">QilFactory</see>.
            </remarks>
        </member>
        <member name="M:System.Xml.Xsl.Qil.QilName.#ctor(System.Xml.Xsl.Qil.QilNodeType,System.String,System.String,System.String)">
            <summary>
            Construct a new node
            </summary>
        </member>
        <member name="P:System.Xml.Xsl.Qil.QilName.QualifiedName">
            <summary>
            Build the qualified name in the form prefix:local
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Qil.QilName.GetHashCode">
            <summary>
            Override GetHashCode() so that the QilName can be used as a key in the hashtable.
            </summary>
            <remarks>Does not compare their prefixes (if any).</remarks>
        </member>
        <member name="M:System.Xml.Xsl.Qil.QilName.Equals(System.Object)">
            <summary>
            Override Equals() so that the QilName can be used as a key in the hashtable.
            </summary>
            <remarks>Does not compare their prefixes (if any).</remarks>
        </member>
        <member name="M:System.Xml.Xsl.Qil.QilName.op_Equality(System.Xml.Xsl.Qil.QilName,System.Xml.Xsl.Qil.QilName)">
            <summary>
            Implement operator == to prevent accidental referential comparison
            </summary>
            <remarks>Does not compare their prefixes (if any).</remarks>
        </member>
        <member name="M:System.Xml.Xsl.Qil.QilName.op_Inequality(System.Xml.Xsl.Qil.QilName,System.Xml.Xsl.Qil.QilName)">
            <summary>
            Implement operator != to prevent accidental referential comparison
            </summary>
            <remarks>Does not compare their prefixes (if any).</remarks>
        </member>
        <member name="M:System.Xml.Xsl.Qil.QilName.ToString">
            <summary>
            Return the QilName in this format: "{namespace}prefix:local-name".
            If the namespace is empty, return the QilName in this truncated format: "local-name".
            If the prefix is empty, return the QilName in this truncated format: "{namespace}local-name".
            </summary>
        </member>
        <member name="T:System.Xml.Xsl.Qil.QilNode">
            <summary>
            A node in the QIL tree.
            </summary>
            <remarks>
            Don't construct QIL nodes directly; instead, use the <see cref="T:System.Xml.Xsl.Qil.QilFactory">QilFactory</see>.
            This base internal class is not abstract and may be instantiated in some cases (for example, true/false boolean literals).
            </remarks>
        </member>
        <member name="M:System.Xml.Xsl.Qil.QilNode.#ctor(System.Xml.Xsl.Qil.QilNodeType)">
            <summary>
            Construct a new node
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Qil.QilNode.#ctor(System.Xml.Xsl.Qil.QilNodeType,System.Xml.Xsl.XmlQueryType)">
            <summary>
            Construct a new node
            </summary>
        </member>
        <member name="P:System.Xml.Xsl.Qil.QilNode.NodeType">
            <summary>
            Access the QIL node type.
            </summary>
        </member>
        <member name="P:System.Xml.Xsl.Qil.QilNode.XmlType">
            <summary>
            Access the QIL type.
            </summary>
        </member>
        <member name="P:System.Xml.Xsl.Qil.QilNode.SourceLine">
            <summary>
            Line info information for tools support.
            </summary>
        </member>
        <member name="P:System.Xml.Xsl.Qil.QilNode.Annotation">
            <summary>
            Access an annotation which may have been attached to this node.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Qil.QilNode.DeepClone(System.Xml.Xsl.Qil.QilFactory)">
            <summary>
            Create a new deep copy of this node.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Qil.QilNode.ShallowClone(System.Xml.Xsl.Qil.QilFactory)">
            <summary>
            Create a shallow copy of this node, copying all the fields.
            </summary>
        </member>
        <member name="T:System.Xml.Xsl.Qil.QilNodeType">
            <summary>An enumeration of all the possible QilExpression node types.</summary>
            <remarks>See <see href="http://dynamo/qil/qil.xml">the QIL functional specification</see> for documentation.</remarks>
        </member>
        <member name="T:System.Xml.Xsl.Qil.QilParameter">
            <summary>
            View over a Qil parameter node.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Qil.QilParameter.#ctor(System.Xml.Xsl.Qil.QilNodeType,System.Xml.Xsl.Qil.QilNode,System.Xml.Xsl.Qil.QilNode,System.Xml.Xsl.XmlQueryType)">
            <summary>
            Construct a parameter
            </summary>
        </member>
        <member name="P:System.Xml.Xsl.Qil.QilParameter.DefaultValue">
            <summary>
            Default value expression of this parameter (may be null).
            </summary>
        </member>
        <member name="P:System.Xml.Xsl.Qil.QilParameter.Name">
            <summary>
            Name of this parameter (may be null).
            </summary>
        </member>
        <member name="T:System.Xml.Xsl.Qil.QilPatternFactory">
            <summary>
            Additional factory methods for constructing common QIL patterns.
            </summary>
            <remarks>
            Some of the methods here are exactly like the ones in QilFactory except
            that they perform constant-folding and other normalization.  Others are
            "macro patterns" that simplify the task of constructing otherwise complex patterns.
            </remarks>
        </member>
        <member name="T:System.Xml.Xsl.Qil.QilPatternVisitor">
            <summary>
            Pattern visitor base internal class
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Qil.QilPatternVisitor.#ctor(System.Xml.Xsl.Qil.QilPatternVisitor.QilPatterns,System.Xml.Xsl.Qil.QilFactory)">
            <summary>
            Constructor.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Qil.QilPatternVisitor.AllowReplace(System.Int32,System.Xml.Xsl.Qil.QilNode)">
            <summary>
            Called when a pattern has matched, but before the replacement code is executed.  If this
            method returns false, then the replacement code is skipped.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Qil.QilPatternVisitor.Replace(System.Int32,System.Xml.Xsl.Qil.QilNode,System.Xml.Xsl.Qil.QilNode)">
            <summary>
            Called when a pattern has matched and after replacement code is executed.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Qil.QilPatternVisitor.NoReplace(System.Xml.Xsl.Qil.QilNode)">
            <summary>
            Called when all replacements have already been made and all annotations are complete.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Qil.QilPatternVisitor.Visit(System.Xml.Xsl.Qil.QilNode)">
            <summary>
            Visit children of this node first, then pattern match on the node itself.
            </summary>
        </member>
        <member name="T:System.Xml.Xsl.Qil.QilPatternVisitor.QilPatterns">
            <summary>
            A bit vector holding a set of rewrites.
            </summary>
        </member>
        <member name="T:System.Xml.Xsl.Qil.QilReference">
            <summary>
            View over a Qil node which is the target of a reference (functions, variables, parameters).
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Qil.QilReference.#ctor(System.Xml.Xsl.Qil.QilNodeType)">
            <summary>
            Construct a reference
            </summary>
        </member>
        <member name="P:System.Xml.Xsl.Qil.QilReference.DebugName">
            <summary>
            Name of this reference, preserved for debugging (may be null).
            </summary>
        </member>
        <member name="T:System.Xml.Xsl.Qil.QilReplaceVisitor">
            <summary>
            Base internal class for visitors that replace the graph as they visit it.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Qil.QilReplaceVisitor.VisitChildren(System.Xml.Xsl.Qil.QilNode)">
            <summary>
            Visit all children of "parent", replacing each child with a copy of each child.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Qil.QilReplaceVisitor.RecalculateType(System.Xml.Xsl.Qil.QilNode,System.Xml.Xsl.XmlQueryType)">
            <summary>
            Once children have been replaced, the Xml type is recalculated.
            </summary>
        </member>
        <member name="T:System.Xml.Xsl.Qil.QilScopedVisitor">
            <summary>
            Adds iterator and function scoping to the QilVisitor implementation.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Qil.QilScopedVisitor.BeginScope(System.Xml.Xsl.Qil.QilNode)">
            <summary>
            Called when a variable, parameter, or function enters scope.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Qil.QilScopedVisitor.EndScope(System.Xml.Xsl.Qil.QilNode)">
            <summary>
            Called when a variable, parameter, or function exits scope.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Qil.QilScopedVisitor.BeforeVisit(System.Xml.Xsl.Qil.QilNode)">
            <summary>
            Called at the beginning of Visit().
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Qil.QilScopedVisitor.AfterVisit(System.Xml.Xsl.Qil.QilNode)">
            <summary>
            Called at the end of Visit().
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Qil.QilScopedVisitor.Visit(System.Xml.Xsl.Qil.QilNode)">
            <summary>
            Call BeforeVisit() and AfterVisit().
            </summary>
        </member>
        <member name="T:System.Xml.Xsl.Qil.QilSortKey">
            <summary>
            View over a Qil SortKey operator.
            </summary>
            <remarks>
            Don't construct QIL nodes directly; instead, use the <see cref="T:System.Xml.Xsl.Qil.QilFactory">QilFactory</see>.
            </remarks>
        </member>
        <member name="M:System.Xml.Xsl.Qil.QilSortKey.#ctor(System.Xml.Xsl.Qil.QilNodeType,System.Xml.Xsl.Qil.QilNode,System.Xml.Xsl.Qil.QilNode)">
            <summary>
            Construct a new node
            </summary>
        </member>
        <member name="T:System.Xml.Xsl.Qil.QilStrConcat">
            <summary>
            View over a Qil StrConcat operator.
            </summary>
            <remarks>
            Don't construct QIL nodes directly; instead, use the <see cref="T:System.Xml.Xsl.Qil.QilFactory">QilFactory</see>.
            </remarks>
        </member>
        <member name="M:System.Xml.Xsl.Qil.QilStrConcat.#ctor(System.Xml.Xsl.Qil.QilNodeType,System.Xml.Xsl.Qil.QilNode,System.Xml.Xsl.Qil.QilNode)">
            <summary>
            Construct a new node
            </summary>
        </member>
        <member name="P:System.Xml.Xsl.Qil.QilStrConcat.Delimiter">
            <summary>
            A string delimiter to insert between successive values of the concatenation
            </summary>
        </member>
        <member name="P:System.Xml.Xsl.Qil.QilStrConcat.Values">
            <summary>
            List of values to concatenate
            </summary>
        </member>
        <member name="T:System.Xml.Xsl.Qil.QilTargetType">
            <summary>
            View over a Qil operator having two children, the second of which is a literal type.
            </summary>
            <remarks>
            Don't construct QIL nodes directly; instead, use the <see cref="T:System.Xml.Xsl.Qil.QilFactory">QilFactory</see>.
            </remarks>
        </member>
        <member name="M:System.Xml.Xsl.Qil.QilTargetType.#ctor(System.Xml.Xsl.Qil.QilNodeType,System.Xml.Xsl.Qil.QilNode,System.Xml.Xsl.Qil.QilNode)">
            <summary>
            Construct a new node
            </summary>
        </member>
        <member name="T:System.Xml.Xsl.Qil.QilTernary">
            <summary>
            View over a Qil operator having three children.
            </summary>
            <remarks>
            Don't construct QIL nodes directly; instead, use the <see cref="T:System.Xml.Xsl.Qil.QilFactory">QilFactory</see>.
            </remarks>
        </member>
        <member name="M:System.Xml.Xsl.Qil.QilTernary.#ctor(System.Xml.Xsl.Qil.QilNodeType,System.Xml.Xsl.Qil.QilNode,System.Xml.Xsl.Qil.QilNode,System.Xml.Xsl.Qil.QilNode)">
            <summary>
            Construct a new node
            </summary>
        </member>
        <member name="T:System.Xml.Xsl.Qil.QilTypeChecker">
            <summary>
            This class performs two functions:
              1. Infer XmlQueryType of Qil nodes (constant, from arguments, etc)
              2. Validate the arguments of Qil nodes if DEBUG is defined
            </summary>
        </member>
        <member name="T:System.Xml.Xsl.Qil.QilUnary">
            <summary>
            View over a Qil operator having one child.
            </summary>
            <remarks>
            Don't construct QIL nodes directly; instead, use the <see cref="T:System.Xml.Xsl.Qil.QilFactory">QilFactory</see>.
            </remarks>
        </member>
        <member name="M:System.Xml.Xsl.Qil.QilUnary.#ctor(System.Xml.Xsl.Qil.QilNodeType,System.Xml.Xsl.Qil.QilNode)">
            <summary>
            Construct a new node
            </summary>
        </member>
        <member name="T:System.Xml.Xsl.Qil.QilValidationVisitor">
             <summary>An internal class that validates QilExpression graphs.</summary>
             <remarks>
             QilValidationVisitor traverses the QilExpression graph once to enforce the following constraints:
             <list type="bullet">
                 <item>No circular references</item>
                 <item>No duplicate nodes (except for references)</item>
                 <item>No out-of-scope references</item>
                 <item>Type constraints on operands</item>
                 <item>Type constraints on operators</item>
                 <item>No null objects (except where allowed)</item>
                 <item>No Unknown node types</item>
             </list>
             <p>When an error occurs, it marks the offending node with an annotation and continues checking,
             allowing the detection of multiple errors at once and printing the structure after validation.
             (In the case of circular references, it breaks the loop at the circular reference to allow the graph
             to print correctly.)</p>
             </remarks>
            
        </member>
        <member name="M:System.Xml.Xsl.Qil.QilValidationVisitor.VisitReference(System.Xml.Xsl.Qil.QilNode)">
            <summary>
            Ensure that the function or iterator reference is already in scope.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Qil.QilValidationVisitor.BeginScope(System.Xml.Xsl.Qil.QilNode)">
            <summary>
            Add an iterator or function to scope if it hasn't been added already.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Qil.QilValidationVisitor.EndScope(System.Xml.Xsl.Qil.QilNode)">
            <summary>
            Pop scope.
            </summary>
        </member>
        <member name="T:System.Xml.Xsl.Qil.QilVisitor">
            <summary>A base internal class for QIL visitors.</summary>
            <remarks>
            <p>QilVisitor is a base internal class for traversing QIL graphs.  Override individual Visit methods to change
            behavior for only certain node types; override Visit() to change behavior for all node types at once; override
            VisitChildren() to change the algorithm for iterating and visiting children.</p>
            <p>Subclasses may also find it useful to annotate the tree during visitation.</p>
            </remarks>
        </member>
        <member name="M:System.Xml.Xsl.Qil.QilVisitor.VisitAssumeReference(System.Xml.Xsl.Qil.QilNode)">
            <summary>
            If a reference is passed to the Visit() method, it is assumed to be the definition.
            This method assumes it is a reference to a definition.
            For example, if a Let node is visited, is it the Let definition or a reference to the
            the Let definition?  Without context, it is ambiguous.  This method allows a caller
            to disambiguate.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Qil.QilVisitor.VisitChildren(System.Xml.Xsl.Qil.QilNode)">
            <summary>
            Visit all children of "parent".  By default, take care to avoid circular visits.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Qil.QilVisitor.IsReference(System.Xml.Xsl.Qil.QilNode,System.Int32)">
            <summary>
            Visit all children of "parent".  Take care to avoid circular visits.
            </summary>
        </member>
        <member name="T:System.Xml.Xsl.Qil.IQilAnnotation">
            <summary>
            If an annotation implements this interface, then QilXmlWriter will call ToString() on the annotation
            and serialize the result (if non-empty).
            </summary>
        </member>
        <member name="T:System.Xml.Xsl.Qil.QilXmlWriter">
            <summary>
            An example of QilVisitor.  Prints the QilExpression tree as XML.
            </summary>
            <remarks>
            <para>The QilXmlWriter Visits every node in the tree, printing out an XML representation of
            each node.  Several formatting options are available, including whether or not to include annotations
            and type information.  When full information is printed out, the graph can be reloaded from
            its serialized form using QilXmlReader.</para>
            <para>The XML format essentially uses one XML element for each node in the QIL graph.
            Node properties such as type information are serialized as XML attributes.
            Annotations are serialized as processing-instructions in front of a node.</para>
            <para>Feel free to subclass this visitor to customize its behavior.</para>
            </remarks>
        </member>
        <member name="M:System.Xml.Xsl.Qil.QilXmlWriter.#ctor(System.Xml.XmlWriter)">
            <summary>
            Construct a QilXmlWriter.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Qil.QilXmlWriter.#ctor(System.Xml.XmlWriter,System.Xml.Xsl.Qil.QilXmlWriter.Options)">
            <summary>
            Construct a QilXmlWriter.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Qil.QilXmlWriter.ToXml(System.Xml.Xsl.Qil.QilNode)">
            <summary>
            Serialize a QilExpression graph as XML.
            </summary>
            <param name="node">the QilExpression graph</param>
        </member>
        <member name="M:System.Xml.Xsl.Qil.QilXmlWriter.WriteAnnotations(System.Object)">
            <summary>
            Write all annotations as comments:
                1. string -- <!-- (string) ann -->
                2. IQilAnnotation -- <!-- ann.Name = ann.ToString() -->
                3. IList{object} -- recursively call WriteAnnotations for each object in list
                4. otherwise, do not write the annotation
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Qil.QilXmlWriter.WriteLineInfo(System.Xml.Xsl.Qil.QilNode)">
            <summary>
            Called in order to write out source line information.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Qil.QilXmlWriter.WriteXmlType(System.Xml.Xsl.Qil.QilNode)">
            <summary>
            Called in order to write out the xml type of a node.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Qil.QilXmlWriter.VisitChildren(System.Xml.Xsl.Qil.QilNode)">
            <summary>
            Override certain node types in order to add additional attributes, suppress children, etc.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Qil.QilXmlWriter.VisitReference(System.Xml.Xsl.Qil.QilNode)">
            <summary>
            Write references to functions or iterators like this: <RefTo id="$a"/>.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Qil.QilXmlWriter.VisitQilExpression(System.Xml.Xsl.Qil.QilExpression)">
            <summary>
            Scan through the external parameters, global variables, and function list for forward references.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Qil.QilXmlWriter.VisitLiteralType(System.Xml.Xsl.Qil.QilLiteral)">
            <summary>
            Serialize literal types using either "S" or "G" formatting, depending on the option which has been set.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Qil.QilXmlWriter.VisitLiteralQName(System.Xml.Xsl.Qil.QilName)">
            <summary>
            Serialize literal QName as three separate attributes.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Qil.QilXmlWriter.BeginScope(System.Xml.Xsl.Qil.QilNode)">
            <summary>
            Annotate this iterator or function with a generated name.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Qil.QilXmlWriter.EndScope(System.Xml.Xsl.Qil.QilNode)">
            <summary>
            Clear the name annotation on this iterator or function.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Qil.QilXmlWriter.BeforeVisit(System.Xml.Xsl.Qil.QilNode)">
            <summary>
            By default, call WriteStartElement for every node type.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Qil.QilXmlWriter.AfterVisit(System.Xml.Xsl.Qil.QilNode)">
            <summary>
            By default, call WriteEndElement for every node type.
            </summary>
        </member>
        <member name="T:System.Xml.Xsl.Qil.QilXmlWriter.ForwardRefFinder">
            <summary>
            Find list of all iterators and functions which are referenced before they have been declared.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Qil.QilXmlWriter.ForwardRefFinder.Visit(System.Xml.Xsl.Qil.QilNode)">
            <summary>
            Add iterators and functions to backrefs list as they are visited.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Qil.QilXmlWriter.ForwardRefFinder.VisitReference(System.Xml.Xsl.Qil.QilNode)">
            <summary>
            If reference is not in scope, then it must be a forward reference.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Qil.QilXmlWriter.NameGenerator.#ctor">
            <summary>
            Construct a new name generator with prefix "$" and alphabetical mode.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Qil.QilXmlWriter.NameGenerator.NextName">
            <summary>
            Skolem function for names.
            </summary>
            <returns>a unique name beginning with the prefix</returns>
        </member>
        <member name="M:System.Xml.Xsl.Qil.QilXmlWriter.NameGenerator.NameOf(System.Xml.Xsl.Qil.QilNode)">
            <summary>
            Lookup or generate a name for a node.  Uses annotations to store the name on the node.
            </summary>
            <param name="n">the node</param>
            <returns>the node name (unique across nodes)</returns>
        </member>
        <member name="M:System.Xml.Xsl.Qil.QilXmlWriter.NameGenerator.ClearName(System.Xml.Xsl.Qil.QilNode)">
            <summary>
            Clear name annotation from a node.
            </summary>
            <param name="n">the node</param>
        </member>
        <member name="T:System.Xml.Xsl.Qil.QilXmlWriter.NameGenerator.NameAnnotation">
            <summary>
            Class used to hold our annotations on the graph
            </summary>
        </member>
        <member name="T:System.Xml.Xsl.Qil.SubstitutionList">
            <summary>
            Data structure for use in CloneAndReplace
            </summary>
            <remarks>Isolates the many QilNode classes from changes in
            the underlying data structure.</remarks>
        </member>
        <member name="M:System.Xml.Xsl.Qil.SubstitutionList.AddSubstitutionPair(System.Xml.Xsl.Qil.QilNode,System.Xml.Xsl.Qil.QilNode)">
            <summary>
            Add a substitution pair
            </summary>
            <param name="find">a node to be replaced</param>
            <param name="replace">its replacement</param>
        </member>
        <member name="M:System.Xml.Xsl.Qil.SubstitutionList.RemoveLastSubstitutionPair">
            <summary>
            Remove the last a substitution pair
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Qil.SubstitutionList.FindReplacement(System.Xml.Xsl.Qil.QilNode)">
            <summary>
            Find the replacement for a node
            </summary>
            <param name="n">the node to replace</param>
            <returns>null if no replacement is found</returns>
        </member>
        <member name="T:System.Xml.Xsl.Qil.WhitespaceRule">
            <summary>
            Data structure for storing whitespace rules generated by xsl:strip-space and xsl:preserve-space
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Qil.WhitespaceRule.#ctor">
            <summary>
            Allow derived classes to construct empty whitespace rule.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Qil.WhitespaceRule.#ctor(System.String,System.String,System.Boolean)">
            <summary>
            Construct new whitespace rule.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Qil.WhitespaceRule.Init(System.String,System.String,System.Boolean)">
            <summary>
            Initialize whitespace rule after it's been constructed.
            </summary>
        </member>
        <member name="P:System.Xml.Xsl.Qil.WhitespaceRule.LocalName">
            <summary>
            Local name of the element.
            </summary>
        </member>
        <member name="P:System.Xml.Xsl.Qil.WhitespaceRule.NamespaceName">
            <summary>
            Namespace name (uri) of the element.
            </summary>
        </member>
        <member name="P:System.Xml.Xsl.Qil.WhitespaceRule.PreserveSpace">
            <summary>
            True, if this element is whitespace-preserving.
            False, if this element is whitespace-stripping.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Qil.WhitespaceRule.GetObjectData(System.Xml.Xsl.Runtime.XmlQueryDataWriter)">
            <summary>
            Serialize the object to BinaryWriter.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Qil.WhitespaceRule.#ctor(System.Xml.Xsl.Runtime.XmlQueryDataReader)">
            <summary>
            Deserialize the object from BinaryReader.
            </summary>
        </member>
        <member name="T:System.Xml.Xsl.Runtime.ContentIterator">
            <summary>
            Iterate over all child content nodes (this is different from the QIL Content operator, which iterates over content + attributes).
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.ContentIterator.Create(System.Xml.XPath.XPathNavigator)">
            <summary>
            Initialize the ContentIterator.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.ContentIterator.MoveNext">
            <summary>
            Position the iterator on the next child content node.  Return true if such a child exists and
            set Current property.  Otherwise, return false (Current property is undefined).
            </summary>
        </member>
        <member name="P:System.Xml.Xsl.Runtime.ContentIterator.Current">
            <summary>
            Return the current result navigator.  This is only defined after MoveNext() has returned true.
            </summary>
        </member>
        <member name="T:System.Xml.Xsl.Runtime.ElementContentIterator">
            <summary>
            Iterate over all child elements with a matching name.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.ElementContentIterator.Create(System.Xml.XPath.XPathNavigator,System.String,System.String)">
            <summary>
            Initialize the ElementContentIterator.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.ElementContentIterator.MoveNext">
            <summary>
            Position the iterator on the next child element with a matching name.  Return true if such a child exists and
            set Current property.  Otherwise, return false (Current property is undefined).
            </summary>
        </member>
        <member name="P:System.Xml.Xsl.Runtime.ElementContentIterator.Current">
            <summary>
            Return the current result navigator.  This is only defined after MoveNext() has returned true.
            </summary>
        </member>
        <member name="T:System.Xml.Xsl.Runtime.NodeKindContentIterator">
            <summary>
            Iterate over all child content nodes with a matching node kind.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.NodeKindContentIterator.Create(System.Xml.XPath.XPathNavigator,System.Xml.XPath.XPathNodeType)">
            <summary>
            Initialize the NodeKindContentIterator.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.NodeKindContentIterator.MoveNext">
            <summary>
            Position the iterator on the next child content node with a matching node kind.  Return true if such a child
            exists and set Current property.  Otherwise, return false (Current property is undefined).
            </summary>
        </member>
        <member name="P:System.Xml.Xsl.Runtime.NodeKindContentIterator.Current">
            <summary>
            Return the current result navigator.  This is only defined after MoveNext() has returned true.
            </summary>
        </member>
        <member name="T:System.Xml.Xsl.Runtime.AttributeIterator">
            <summary>
            Iterate over all attributes.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.AttributeIterator.Create(System.Xml.XPath.XPathNavigator)">
            <summary>
            Initialize the AttributeIterator.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.AttributeIterator.MoveNext">
            <summary>
            Position the iterator on the attribute.  Return true if such a child exists and set Current
            property.  Otherwise, return false (Current property is undefined).
            </summary>
        </member>
        <member name="P:System.Xml.Xsl.Runtime.AttributeIterator.Current">
            <summary>
            Return the current result navigator.  This is only defined after MoveNext() has returned true.
            </summary>
        </member>
        <member name="T:System.Xml.Xsl.Runtime.NamespaceIterator">
            <summary>
            Iterate over all namespace nodes.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.NamespaceIterator.Create(System.Xml.XPath.XPathNavigator)">
            <summary>
            Initialize the NamespaceIterator.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.NamespaceIterator.MoveNext">
            <summary>
            Pop the top namespace from the stack and save it as navCurrent.  If there are no more namespaces, return false.
            </summary>
        </member>
        <member name="P:System.Xml.Xsl.Runtime.NamespaceIterator.Current">
            <summary>
            Return the current result navigator.  This is only defined after MoveNext() has returned true.
            </summary>
        </member>
        <member name="T:System.Xml.Xsl.Runtime.AttributeContentIterator">
            <summary>
            Iterate over all attribute and child content nodes.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.AttributeContentIterator.Create(System.Xml.XPath.XPathNavigator)">
            <summary>
            Initialize the AttributeContentIterator.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.AttributeContentIterator.MoveNext">
            <summary>
            Position the iterator on the next child content node with a matching node kind.  Return true if such a child
            exists and set Current property.  Otherwise, return false (Current property is undefined).
            </summary>
        </member>
        <member name="P:System.Xml.Xsl.Runtime.AttributeContentIterator.Current">
            <summary>
            Return the current result navigator.  This is only defined after MoveNext() has returned true.
            </summary>
        </member>
        <member name="T:System.Xml.Xsl.Runtime.ContentMergeIterator">
            <summary>
            Iterate over child content nodes or following-sibling nodes.  Maintain document order by using a stack.  Input
            nodes are assumed to be in document order, but can contain one another (ContentIterator doesn't allow this).
            </summary>
            <remarks>
            1. Assume that the list I of input nodes is in document order, with no duplicates.  There are N nodes in list I.
            2. For each node in list I, derive a list of nodes consisting of matching children or following-sibling nodes.
            Call these lists S(1)...S(N).
            3. Let F be the first node in any list S(X), where X &gt;= 1 and X &lt; N
            4. There exists exactly one contiguous sequence of lists S(Y)...S(Z), where Y &gt; X and Z &lt;= N, such that the lists
            S(X+1)...S(N) can be partitioned into these three groups:
            a. 1st group (S(X+1)...S(Y-1)) -- All nodes in these lists precede F in document order
            b. 2nd group (S(Y)...S(Z)) -- All nodes in these lists are duplicates of nodes in list S(X)
            c. 3rd group (&gt; S(Z)) -- All nodes in these lists succeed F in document order
            5. Given #4, node F can be returned once all nodes in the 1st group have been returned.  Lists S(Y)...S(Z) can be
            discarded.  And only a single node in the 3rd group need be generated in order to guarantee that all nodes in
            the 1st and 2nd groups have already been generated.
            </remarks>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.ContentMergeIterator.Create(System.Xml.Xsl.Runtime.XmlNavigatorFilter)">
            <summary>
            Initialize the ContentMergeIterator (merge multiple sets of content nodes in document order and remove duplicates).
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.ContentMergeIterator.MoveNext(System.Xml.XPath.XPathNavigator)">
            <summary>
            Position this iterator to the next content or sibling node.  Return IteratorResult.NoMoreNodes if there are
            no more content or sibling nodes.  Return IteratorResult.NeedInputNode if the next input node needs to be
            fetched first.  Return IteratorResult.HaveCurrent if the Current property is set to the next node in the
            iteration.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.ContentMergeIterator.MoveNext(System.Xml.XPath.XPathNavigator,System.Boolean)">
            <summary>
            Position this iterator to the next content or sibling node.  Return IteratorResult.NoMoreNodes if there are
            no more content or sibling nodes.  Return IteratorResult.NeedInputNode if the next input node needs to be
            fetched first.  Return IteratorResult.HaveCurrent if the Current property is set to the next node in the
            iteration.
            </summary>
        </member>
        <member name="P:System.Xml.Xsl.Runtime.ContentMergeIterator.Current">
            <summary>
            Return the current result navigator.  This is only defined after MoveNext() has returned IteratorResult.HaveCurrentNode.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.ContentMergeIterator.DocOrderMerge">
            <summary>
            If the context node-set returns a node that is contained in the subtree of the previous node,
            then returning children of each node in "natural" order may not correspond to document order.
            Therefore, in order to guarantee document order, keep a stack in order to push the sibling of
            ancestor nodes.  These siblings will not be returned until all of the descendants' children are
            returned first.
            </summary>
        </member>
        <member name="T:System.Xml.Xsl.Runtime.DocumentOrderComparer">
            <summary>
            IComparer implementation that orders navigators based on ComparePosition.  When ComparePosition returns
            XmlNodeOrder.Unknown, a stable order between documents is maintained by an ordered list mapping each root node
            to an ordering index.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.DocumentOrderComparer.Compare(System.Xml.XPath.XPathNavigator,System.Xml.XPath.XPathNavigator)">
            <summary>
            Return:
                -1 if navThis is positioned before navThat
                 0 if navThis has the same position as navThat
                 1 if navThis is positioned after navThat
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.DocumentOrderComparer.GetDocumentIndex(System.Xml.XPath.XPathNavigator)">
            <summary>
            Map navigator's document to a unique index.
            When consecutive calls are made to GetIndexOfNavigator for navThis and navThat, it is not possible
            for them to return the same index.  navThis compared to navThat is always XmlNodeOrder.Unknown.
            Therefore, no matter where navThis is inserted in the list, navThat will never be inserted just
            before navThis, and therefore will never have the same index.
            </summary>
        </member>
        <member name="T:System.Xml.Xsl.Runtime.DodSequenceMerge">
            <summary>
            Merges several doc-order-distinct sequences into a single doc-order-distinct sequence.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.DodSequenceMerge.Create(System.Xml.Xsl.Runtime.XmlQueryRuntime)">
            <summary>
            Initialize this instance of DodSequenceMerge.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.DodSequenceMerge.AddSequence(System.Collections.Generic.IList{System.Xml.XPath.XPathNavigator})">
            <summary>
            Add a new sequence to the list of sequences to merge.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.DodSequenceMerge.MergeSequences">
            <summary>
            Return the fully merged sequence.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.DodSequenceMerge.MoveAndInsertSequence(System.Collections.Generic.IEnumerator{System.Xml.XPath.XPathNavigator})">
            <summary>
            Move to the next item in the sequence.  If there is no next item, then do not
            insert the sequence.  Otherwise, call InsertSequence.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.DodSequenceMerge.InsertSequence(System.Collections.Generic.IEnumerator{System.Xml.XPath.XPathNavigator})">
            <summary>
            Insert the specified sequence into the list of sequences to be merged.
            Insert it in reverse document order with respect to the current nodes in other sequences.
            </summary>
        </member>
        <member name="T:System.Xml.Xsl.Runtime.EarlyBoundInfo">
            <summary>
            This class contains information about early bound function objects.
            </summary>
        </member>
        <member name="P:System.Xml.Xsl.Runtime.EarlyBoundInfo.NamespaceUri">
            <summary>
            Get the Namespace Uri mapped to these early bound functions.
            </summary>
        </member>
        <member name="P:System.Xml.Xsl.Runtime.EarlyBoundInfo.EarlyBoundType">
            <summary>
            Return the Clr Type of the early bound object.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.EarlyBoundInfo.CreateObject">
            <summary>
            Create an instance of the early bound object.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.EarlyBoundInfo.Equals(System.Object)">
            <summary>
            Override Equals method so that EarlyBoundInfo to implement value comparison.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.EarlyBoundInfo.GetHashCode">
            <summary>
            Override GetHashCode since Equals is overridden.
            </summary>
        </member>
        <member name="T:System.Xml.Xsl.Runtime.RtfNavigator">
            <summary>
            RtfNavigators store Xslt result-tree-fragments.  At runtime, the Xslt library tests to see if a Navigator
            is an RtfNavigator in order to enforce certain restrictions, such as prohibiting querying into Rtfs.
            Furthermore, Rtfs must store extra serialization information required in order to properly implement the
            Xslt disable-output-escaping flag.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.RtfNavigator.CopyToWriter(System.Xml.XmlWriter)">
            <summary>
            Preserve serialization hints when deep copying.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.RtfNavigator.ToNavigator">
            <summary>
            Discard serialization hints and return a navigator that actually allows navigation.
            </summary>
        </member>
        <member name="P:System.Xml.Xsl.Runtime.RtfNavigator.NodeType">
            <summary>
            Get the XPath node type of the current node.
            </summary>
        </member>
        <member name="P:System.Xml.Xsl.Runtime.RtfNavigator.LocalName">
            <summary>
            Get the local name portion of the current node's name.
            </summary>
        </member>
        <member name="P:System.Xml.Xsl.Runtime.RtfNavigator.NamespaceURI">
            <summary>
            Get the namespace portion of the current node's name.
            </summary>
        </member>
        <member name="P:System.Xml.Xsl.Runtime.RtfNavigator.Name">
            <summary>
            Get the name of the current node.
            </summary>
        </member>
        <member name="P:System.Xml.Xsl.Runtime.RtfNavigator.Prefix">
            <summary>
            Get the prefix portion of the current node's name.
            </summary>
        </member>
        <member name="P:System.Xml.Xsl.Runtime.RtfNavigator.IsEmptyElement">
            <summary>
            Return true if this is an element which used a shortcut tag in its Xml 1.0 serialized form.
            </summary>
        </member>
        <member name="P:System.Xml.Xsl.Runtime.RtfNavigator.NameTable">
            <summary>
            Return the xml name table which was used to atomize all prefixes, local-names, and
            namespace uris in the document.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.RtfNavigator.MoveToFirstAttribute">
            <summary>
            Position the navigator on the first attribute of the current node and return true.  If no attributes
            can be found, return false.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.RtfNavigator.MoveToNextAttribute">
            <summary>
            If positioned on an attribute, move to its next sibling attribute.  If no attributes can be found,
            return false.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.RtfNavigator.MoveToFirstNamespace(System.Xml.XPath.XPathNamespaceScope)">
            <summary>
            Position the navigator on the namespace within the specified scope.  If no matching namespace
            can be found, return false.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.RtfNavigator.MoveToNextNamespace(System.Xml.XPath.XPathNamespaceScope)">
            <summary>
            Position the navigator on the next namespace within the specified scope.  If no matching namespace
            can be found, return false.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.RtfNavigator.MoveToNext">
            <summary>
            If the current node is an attribute or namespace (not content), return false.  Otherwise,
            move to the next content node.  Return false if there are no more content nodes.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.RtfNavigator.MoveToPrevious">
            <summary>
            If the current node is an attribute or namespace (not content), return false.  Otherwise,
            move to the previous (sibling) content node.  Return false if there are no previous content nodes.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.RtfNavigator.MoveToFirstChild">
            <summary>
            Move to the first content-typed child of the current node.  Return false if the current
            node has no content children.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.RtfNavigator.MoveToParent">
            <summary>
            Position the navigator on the parent of the current node.  If the current node has no parent,
            return false.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.RtfNavigator.MoveToId(System.String)">
            <summary>
            Position to the navigator to the element whose id is equal to the specified "id" string.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.RtfNavigator.IsSamePosition(System.Xml.XPath.XPathNavigator)">
            <summary>
            Returns true if this navigator is positioned to the same node as the "other" navigator.  Returns false
            if not, or if the "other" navigator is not the same type as this navigator.
            </summary>
        </member>
        <member name="T:System.Xml.Xsl.Runtime.RtfTreeNavigator">
            <summary>
            This navigator is a cursor over a cache that stores Xslt disable-output-escaping flags.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.RtfTreeNavigator.#ctor(System.Xml.XmlEventCache,System.Xml.XmlNameTable)">
            <summary>
            Create a new navigator over the specified cache of Xml events.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.RtfTreeNavigator.#ctor(System.Xml.Xsl.Runtime.RtfTreeNavigator)">
            <summary>
            Copy constructor.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.RtfTreeNavigator.CopyToWriter(System.Xml.XmlWriter)">
            <summary>
            Preserve serialization hints when deep copying.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.RtfTreeNavigator.ToNavigator">
            <summary>
            Discard serialization hints and return a navigator that actually allows navigation.
            </summary>
        </member>
        <member name="P:System.Xml.Xsl.Runtime.RtfTreeNavigator.Value">
            <summary>
            Get the string value of the current node, computed using data model dm:string-value rules.
            If the node has a typed value, return the string representation of the value.  If the node
            is not a parent type (comment, text, pi, etc.), get its simple text value.  Otherwise,
            concatenate all text node descendants of the current node.
            </summary>
        </member>
        <member name="P:System.Xml.Xsl.Runtime.RtfTreeNavigator.BaseURI">
            <summary>
            Get the base URI of the Rtf.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.RtfTreeNavigator.Clone">
            <summary>
            Create a copy of this navigator, positioned to the same node in the tree.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.RtfTreeNavigator.MoveTo(System.Xml.XPath.XPathNavigator)">
            <summary>
            Position this navigator to the same position as the "other" navigator.  If the "other" navigator
            is not of the same type as this navigator, then return false.
            </summary>
        </member>
        <member name="T:System.Xml.Xsl.Runtime.RtfTextNavigator">
            <summary>
            This RtfNavigator specializes the case of a root node having a single text node child.  This is a very common
            case, such as in &lt;xsl:variable name="foo"&gt;bar&lt;/xsl:variable&gt;.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.RtfTextNavigator.#ctor(System.String,System.String)">
            <summary>
            Create a new navigator having a text node with value = "text" string.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.RtfTextNavigator.#ctor(System.Xml.Xsl.Runtime.RtfTextNavigator)">
            <summary>
            Copy constructor.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.RtfTextNavigator.CopyToWriter(System.Xml.XmlWriter)">
            <summary>
            Preserve serialization hints when deep copying.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.RtfTextNavigator.ToNavigator">
            <summary>
            Discard serialization hints and return a navigator that actually allows navigation.
            </summary>
        </member>
        <member name="P:System.Xml.Xsl.Runtime.RtfTextNavigator.Value">
            <summary>
            Get the string value of the current node, computed using data model dm:string-value rules.
            If the node has a typed value, return the string representation of the value.  If the node
            is not a parent type (comment, text, pi, etc.), get its simple text value.  Otherwise,
            concatenate all text node descendants of the current node.
            </summary>
        </member>
        <member name="P:System.Xml.Xsl.Runtime.RtfTextNavigator.BaseURI">
            <summary>
            Get the base URI of the Rtf.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.RtfTextNavigator.Clone">
            <summary>
            Create a copy of this navigator, positioned to the same node in the tree.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.RtfTextNavigator.MoveTo(System.Xml.XPath.XPathNavigator)">
            <summary>
            Position this navigator to the same position as the "other" navigator.  If the "other" navigator
            is not of the same type as this navigator, then return false.
            </summary>
        </member>
        <member name="T:System.Xml.Xsl.Runtime.NavigatorConstructor">
            <summary>
            This class creates a document on the first call to GetNavigator(), and returns a Navigator from it.  On
            subsequent calls, Navigators from the same document are returned (no new document is created).
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.NavigatorConstructor.GetNavigator(System.Xml.XmlEventCache,System.Xml.XmlNameTable)">
            <summary>
            Create a document from the cache of events.  If a document has already been created previously, return it.
            This method is thread-safe, and is always guaranteed to return the exact same document, no matter how many
            threads have called it concurrently.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.NavigatorConstructor.GetNavigator(System.String,System.String,System.Xml.XmlNameTable)">
            <summary>
            Create a document containing a root node and a single text node child with "text" as its text value.
            This method is thread-safe, and is always guaranteed to return the exact same document, no matter how many
            threads have called it concurrently.
            </summary>
        </member>
        <member name="T:System.Xml.Xsl.Runtime.SetIteratorResult">
            <summary>
            Set iterators (Union, Intersection, Difference) that use containment to control two nested iterators return
            one of the following values from MoveNext().
            </summary>
        </member>
        <member name="T:System.Xml.Xsl.Runtime.UnionIterator">
            <summary>
            This iterator manages two sets of nodes that are already in document order with no duplicates.
            Using a merge sort, this operator returns the union of these sets in document order with no duplicates.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.UnionIterator.Create(System.Xml.Xsl.Runtime.XmlQueryRuntime)">
            <summary>
            Create SetIterator.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.UnionIterator.MoveNext(System.Xml.XPath.XPathNavigator)">
            <summary>
            Position this iterator to the next node in the union.
            </summary>
        </member>
        <member name="P:System.Xml.Xsl.Runtime.UnionIterator.Current">
            <summary>
            Return the current result navigator.  This is only defined after MoveNext() has returned -1.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.UnionIterator.Swap">
            <summary>
            Swap navCurr with navOther and invert state to reflect the change.
            </summary>
        </member>
        <member name="T:System.Xml.Xsl.Runtime.IntersectIterator">
            <summary>
            This iterator manages two sets of nodes that are already in document order with no duplicates.
            This iterator returns the intersection of these sets in document order with no duplicates.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.IntersectIterator.Create(System.Xml.Xsl.Runtime.XmlQueryRuntime)">
            <summary>
            Create IntersectIterator.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.IntersectIterator.MoveNext(System.Xml.XPath.XPathNavigator)">
            <summary>
            Position this iterator to the next node in the union.
            </summary>
        </member>
        <member name="P:System.Xml.Xsl.Runtime.IntersectIterator.Current">
            <summary>
            Return the current result navigator.  This is only defined after MoveNext() has returned -1.
            </summary>
        </member>
        <member name="T:System.Xml.Xsl.Runtime.DifferenceIterator">
            <summary>
            This iterator manages two sets of nodes that are already in document order with no duplicates.
            This iterator returns the difference of these sets (Left - Right) in document order with no duplicates.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.DifferenceIterator.Create(System.Xml.Xsl.Runtime.XmlQueryRuntime)">
            <summary>
            Create DifferenceIterator.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.DifferenceIterator.MoveNext(System.Xml.XPath.XPathNavigator)">
            <summary>
            Position this iterator to the next node in the union.
            </summary>
        </member>
        <member name="P:System.Xml.Xsl.Runtime.DifferenceIterator.Current">
            <summary>
            Return the current result navigator.  This is only defined after MoveNext() has returned -1.
            </summary>
        </member>
        <member name="T:System.Xml.Xsl.Runtime.FollowingSiblingIterator">
            <summary>
            Iterate over all following-sibling content nodes.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.FollowingSiblingIterator.Create(System.Xml.XPath.XPathNavigator,System.Xml.Xsl.Runtime.XmlNavigatorFilter)">
            <summary>
            Initialize the FollowingSiblingIterator.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.FollowingSiblingIterator.MoveNext">
            <summary>
            Position the iterator on the next following-sibling node.  Return true if such a node exists and
            set Current property.  Otherwise, return false (Current property is undefined).
            </summary>
        </member>
        <member name="P:System.Xml.Xsl.Runtime.FollowingSiblingIterator.Current">
            <summary>
            Return the current result navigator.  This is only defined after MoveNext() has returned true.
            </summary>
        </member>
        <member name="T:System.Xml.Xsl.Runtime.FollowingSiblingMergeIterator">
            <summary>
            Iterate over child following-sibling nodes.  This is a simple variation on the ContentMergeIterator, so use containment
            to reuse its code (can't use inheritance with structures).
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.FollowingSiblingMergeIterator.Create(System.Xml.Xsl.Runtime.XmlNavigatorFilter)">
            <summary>
            Initialize the FollowingSiblingMergeIterator.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.FollowingSiblingMergeIterator.MoveNext(System.Xml.XPath.XPathNavigator)">
            <summary>
            Position this iterator to the next content or sibling node.  Return IteratorResult.NoMoreNodes if there are
            no more content or sibling nodes.  Return IteratorResult.NeedInputNode if the next input node needs to be
            fetched first.  Return IteratorResult.HaveCurrent if the Current property is set to the next node in the
            iteration.
            </summary>
        </member>
        <member name="P:System.Xml.Xsl.Runtime.FollowingSiblingMergeIterator.Current">
            <summary>
            Return the current result navigator.  This is only defined after MoveNext() has returned IteratorResult.HaveCurrent.
            </summary>
        </member>
        <member name="T:System.Xml.Xsl.Runtime.PrecedingSiblingIterator">
            <summary>
            Iterate over all preceding nodes according to XPath preceding axis rules, returning nodes in reverse
            document order.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.PrecedingSiblingIterator.Create(System.Xml.XPath.XPathNavigator,System.Xml.Xsl.Runtime.XmlNavigatorFilter)">
            <summary>
            Initialize the PrecedingSiblingIterator.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.PrecedingSiblingIterator.MoveNext">
            <summary>
            Return true if the Current property is set to the next Preceding node in reverse document order.
            </summary>
        </member>
        <member name="P:System.Xml.Xsl.Runtime.PrecedingSiblingIterator.Current">
            <summary>
            Return the current result navigator.  This is only defined after MoveNext() has returned true.
            </summary>
        </member>
        <member name="T:System.Xml.Xsl.Runtime.PrecedingSiblingDocOrderIterator">
            <summary>
            Iterate over all preceding-sibling content nodes in document order.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.PrecedingSiblingDocOrderIterator.Create(System.Xml.XPath.XPathNavigator,System.Xml.Xsl.Runtime.XmlNavigatorFilter)">
            <summary>
            Initialize the PrecedingSiblingDocOrderIterator.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.PrecedingSiblingDocOrderIterator.MoveNext">
            <summary>
            Position the iterator on the next preceding-sibling node.  Return true if such a node exists and
            set Current property.  Otherwise, return false (Current property is undefined).
            </summary>
        </member>
        <member name="P:System.Xml.Xsl.Runtime.PrecedingSiblingDocOrderIterator.Current">
            <summary>
            Return the current result navigator.  This is only defined after MoveNext() has returned true.
            </summary>
        </member>
        <member name="T:System.Xml.Xsl.Runtime.StringConcat">
            <summary>
            Efficiently concatenates strings when the number of string is not known beforehand, and
            yet it is common for only one string to be concatenated.  StringBuilder is not good for
            this purpose, since it *always* allocates objects, even if only one string is appended.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.StringConcat.Clear">
            <summary>
            Clear the result string.
            </summary>
        </member>
        <member name="P:System.Xml.Xsl.Runtime.StringConcat.Delimiter">
            <summary>
            Gets or sets the string that delimits concatenated strings.
            </summary>
        </member>
        <member name="P:System.Xml.Xsl.Runtime.StringConcat.Count">
            <summary>
            Return the number of concatenated strings, including delimiters.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.StringConcat.Concat(System.String)">
            <summary>
            Concatenate a new string to the result.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.StringConcat.GetResult">
            <summary>
            Get the result string.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.StringConcat.ConcatNoDelimiter(System.String)">
            <summary>
            Concatenate a new string to the result without adding a delimiter.
            </summary>
        </member>
        <member name="T:System.Xml.Xsl.Runtime.DescendantIterator">
            <summary>
            Iterate over all descendant content nodes according to XPath descendant axis rules.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.DescendantIterator.Create(System.Xml.XPath.XPathNavigator,System.Xml.Xsl.Runtime.XmlNavigatorFilter,System.Boolean)">
            <summary>
            Initialize the DescendantIterator (no possibility of duplicates).
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.DescendantIterator.MoveNext">
            <summary>
            Position this iterator to the next descendant node.  Return false if there are no more descendant nodes.
            Return true if the Current property is set to the next node in the iteration.
            </summary>
        </member>
        <member name="P:System.Xml.Xsl.Runtime.DescendantIterator.Current">
            <summary>
            Return the current result navigator.  This is only defined after MoveNext() has returned true.
            </summary>
        </member>
        <member name="T:System.Xml.Xsl.Runtime.DescendantMergeIterator">
            <summary>
            Iterate over all descendant content nodes according to XPath descendant axis rules.  Eliminate duplicates by not
            querying over nodes that are contained in the subtree of the previous node.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.DescendantMergeIterator.Create(System.Xml.Xsl.Runtime.XmlNavigatorFilter,System.Boolean)">
            <summary>
            Initialize the DescendantIterator (merge multiple sets of descendant nodes in document order and remove duplicates).
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.DescendantMergeIterator.MoveNext(System.Xml.XPath.XPathNavigator)">
            <summary>
            Position this iterator to the next descendant node.  Return IteratorResult.NoMoreNodes if there are no more
            descendant nodes.  Return IteratorResult.NeedInputNode if the next input node needs to be fetched.
            Return IteratorResult.HaveCurrent if the Current property is set to the next node in the iteration.
            </summary>
        </member>
        <member name="P:System.Xml.Xsl.Runtime.DescendantMergeIterator.Current">
            <summary>
            Return the current result navigator.  This is only defined after MoveNext() has returned true or IteratorResult.HaveCurrentNode.
            </summary>
        </member>
        <member name="T:System.Xml.Xsl.Runtime.ParentIterator">
            <summary>
            Iterate over matching parent node according to XPath parent axis rules.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.ParentIterator.Create(System.Xml.XPath.XPathNavigator,System.Xml.Xsl.Runtime.XmlNavigatorFilter)">
            <summary>
            Initialize the ParentIterator.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.ParentIterator.MoveNext">
            <summary>
            Return true if a matching parent node exists and set Current property.  Otherwise, return false
            (Current property is undefined).
            </summary>
        </member>
        <member name="P:System.Xml.Xsl.Runtime.ParentIterator.Current">
            <summary>
            Return the current result navigator.  This is only defined after MoveNext() has returned true.
            </summary>
        </member>
        <member name="T:System.Xml.Xsl.Runtime.AncestorIterator">
            <summary>
            Iterate over all ancestor nodes according to XPath ancestor axis rules, returning nodes in reverse
            document order.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.AncestorIterator.Create(System.Xml.XPath.XPathNavigator,System.Xml.Xsl.Runtime.XmlNavigatorFilter,System.Boolean)">
            <summary>
            Initialize the AncestorIterator.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.AncestorIterator.MoveNext">
            <summary>
            Position the iterator on the next matching ancestor node.  Return true if such a node exists and
            set Current property.  Otherwise, return false (Current property is undefined).
            </summary>
        </member>
        <member name="P:System.Xml.Xsl.Runtime.AncestorIterator.Current">
            <summary>
            Return the current result navigator.  This is only defined after MoveNext() has returned true.
            </summary>
        </member>
        <member name="T:System.Xml.Xsl.Runtime.AncestorDocOrderIterator">
            <summary>
            Iterate over all ancestor nodes according to XPath ancestor axis rules, but return the nodes in document order.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.AncestorDocOrderIterator.Create(System.Xml.XPath.XPathNavigator,System.Xml.Xsl.Runtime.XmlNavigatorFilter,System.Boolean)">
            <summary>
            Initialize the AncestorDocOrderIterator (return ancestor nodes in document order, no possibility of duplicates).
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.AncestorDocOrderIterator.MoveNext">
            <summary>
            Return true if the Current property is set to the next Ancestor node in document order.
            </summary>
        </member>
        <member name="P:System.Xml.Xsl.Runtime.AncestorDocOrderIterator.Current">
            <summary>
            Return the current result navigator.  This is only defined after MoveNext() has returned true.
            </summary>
        </member>
        <member name="T:System.Xml.Xsl.Runtime.XPathFollowingIterator">
            <summary>
            Iterate over all following nodes according to XPath following axis rules.  These rules specify that
            descendants are not included, even though they follow the starting node in document order.  For the
            "true" following axis, see FollowingIterator.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XPathFollowingIterator.Create(System.Xml.XPath.XPathNavigator,System.Xml.Xsl.Runtime.XmlNavigatorFilter)">
            <summary>
            Initialize the XPathFollowingIterator (no possibility of duplicates).
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XPathFollowingIterator.MoveNext">
            <summary>
            Position this iterator to the next following node.  Return false if there are no more following nodes.
            Return true if the Current property is set to the next node in the iteration.
            </summary>
        </member>
        <member name="P:System.Xml.Xsl.Runtime.XPathFollowingIterator.Current">
            <summary>
            Return the current result navigator.  This is only defined after MoveNext() has returned true.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XPathFollowingIterator.MoveFirst(System.Xml.Xsl.Runtime.XmlNavigatorFilter,System.Xml.XPath.XPathNavigator)">
            <summary>
            Position "nav" to the matching node which follows it in document order but is not a descendant node.
            Return false if this is no such matching node.
            </summary>
        </member>
        <member name="T:System.Xml.Xsl.Runtime.XPathFollowingMergeIterator">
            <summary>
            Iterate over all following nodes according to XPath following axis rules.  Merge multiple sets of following nodes
            in document order and remove duplicates.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XPathFollowingMergeIterator.Create(System.Xml.Xsl.Runtime.XmlNavigatorFilter)">
            <summary>
            Initialize the XPathFollowingMergeIterator (merge multiple sets of following nodes in document order and remove duplicates).
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XPathFollowingMergeIterator.MoveNext(System.Xml.XPath.XPathNavigator)">
            <summary>
            Position this iterator to the next following node.  Prune by finding the first input node in
            document order that has no other input nodes in its subtree.  All other input nodes should be
            discarded.  Return IteratorResult.NeedInputNode if the next input node needs to be fetched
            first.  Return IteratorResult.HaveCurrent if the Current property is set to the next node in the
            iteration.
            </summary>
        </member>
        <member name="P:System.Xml.Xsl.Runtime.XPathFollowingMergeIterator.Current">
            <summary>
            Return the current result navigator.  This is only defined after MoveNext() has returned true or IteratorResult.HaveCurrentNode.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XPathFollowingMergeIterator.MoveFailed">
            <summary>
            Called when an attempt to move to a following node failed.  If a Next node exists, then make that the new
            candidate current node.  Otherwise, iteration is complete.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XPathFollowingMergeIterator.MoveFirst">
            <summary>
            Position this.navCurrent to the node which follows it in document order but is not a descendant node.
            </summary>
        </member>
        <member name="T:System.Xml.Xsl.Runtime.PrecedingIterator">
            <summary>
            Iterate over all content-typed nodes which precede the starting node in document order.  Return nodes
            in reverse document order.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.PrecedingIterator.Create(System.Xml.XPath.XPathNavigator,System.Xml.Xsl.Runtime.XmlNavigatorFilter)">
            <summary>
            Initialize the PrecedingIterator (no possibility of duplicates).
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.PrecedingIterator.MoveNext">
            <summary>
            Return true if the Current property is set to the next Preceding node in reverse document order.
            </summary>
        </member>
        <member name="P:System.Xml.Xsl.Runtime.PrecedingIterator.Current">
            <summary>
            Return the current result navigator.  This is only defined after MoveNext() has returned true.
            </summary>
        </member>
        <member name="T:System.Xml.Xsl.Runtime.XPathPrecedingIterator">
            <summary>
            Iterate over all preceding nodes according to XPath preceding axis rules, returning nodes in reverse
            document order.  These rules specify that ancestors are not included, even though they precede the
            starting node in document order.  For the "true" preceding axis, see PrecedingIterator.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XPathPrecedingIterator.Create(System.Xml.XPath.XPathNavigator,System.Xml.Xsl.Runtime.XmlNavigatorFilter)">
            <summary>
            Initialize the XPathPrecedingIterator (no possibility of duplicates).
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XPathPrecedingIterator.MoveNext">
            <summary>
            Return true if the Current property is set to the next Preceding node in reverse document order.
            </summary>
        </member>
        <member name="P:System.Xml.Xsl.Runtime.XPathPrecedingIterator.Current">
            <summary>
            Return the current result navigator.  This is only defined after MoveNext() has returned true.
            </summary>
        </member>
        <member name="T:System.Xml.Xsl.Runtime.XPathPrecedingDocOrderIterator">
            <summary>
            Iterate over all preceding nodes according to XPath preceding axis rules, returning nodes in document order.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XPathPrecedingDocOrderIterator.Create(System.Xml.XPath.XPathNavigator,System.Xml.Xsl.Runtime.XmlNavigatorFilter)">
            <summary>
            Initialize the XPathPrecedingDocOrderIterator (return preceding nodes in document order, no possibility of duplicates).
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XPathPrecedingDocOrderIterator.MoveNext">
            <summary>
            Position this iterator to the next preceding node.  Return false if there are no more preceding nodes.
            Return true if the Current property is set to the next node in the iteration.
            </summary>
        </member>
        <member name="P:System.Xml.Xsl.Runtime.XPathPrecedingDocOrderIterator.Current">
            <summary>
            Return the current result navigator.  This is only defined after MoveNext() has returned true or
            IteratorResult.HaveCurrentNode.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XPathPrecedingDocOrderIterator.PushAncestors">
            <summary>
            Push all ancestors of this.navCurrent onto a stack.  The set of preceding nodes should not contain any of these
            ancestors.
            </summary>
        </member>
        <member name="T:System.Xml.Xsl.Runtime.XPathPrecedingMergeIterator">
            <summary>
            Iterate over all preceding nodes according to XPath preceding axis rules, except that nodes are always
            returned in document order.  Merge multiple sets of preceding nodes in document order and remove duplicates.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XPathPrecedingMergeIterator.Create(System.Xml.Xsl.Runtime.XmlNavigatorFilter)">
            <summary>
            Initialize the XPathPrecedingMergeIterator (merge multiple sets of preceding nodes in document order and remove duplicates).
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XPathPrecedingMergeIterator.MoveNext(System.Xml.XPath.XPathNavigator)">
            <summary>
            Position this iterator to the next preceding node in document order.  Discard all input nodes
            that are followed by another input node in the same document.  This leaves one node per document from
            which the complete set of preceding nodes can be derived without possibility of duplicates.
            Return IteratorResult.NeedInputNode if the next input node needs to be fetched first.  Return
            IteratorResult.HaveCurrent if the Current property is set to the next node in the iteration.
            </summary>
        </member>
        <member name="P:System.Xml.Xsl.Runtime.XPathPrecedingMergeIterator.Current">
            <summary>
            Return the current result navigator.  This is only defined after MoveNext() has returned true or
            IteratorResult.HaveCurrentNode.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XPathPrecedingMergeIterator.PushAncestors">
            <summary>
            Push all ancestors of this.navCurrent onto a stack.  The set of preceding nodes should not contain any of these
            ancestors.
            </summary>
        </member>
        <member name="T:System.Xml.Xsl.Runtime.NodeRangeIterator">
             <summary>
             Iterate over these nodes in document order (filtering out those that do not match the filter test):
               1. Starting node
               2. All content-typed nodes which follow the starting node until the ending node is reached
               3. Ending node
            
             If the starting node is the same node as the ending node, iterate over the singleton node.
             If the starting node is after the ending node, or is in a different document, iterate to the
             end of the document.
             </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.NodeRangeIterator.Create(System.Xml.XPath.XPathNavigator,System.Xml.Xsl.Runtime.XmlNavigatorFilter,System.Xml.XPath.XPathNavigator)">
            <summary>
            Initialize the NodeRangeIterator (no possibility of duplicates).
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.NodeRangeIterator.MoveNext">
            <summary>
            Position this iterator to the next following node.  Return false if there are no more following nodes,
            or if the end node has been reached.  Return true if the Current property is set to the next node in
            the iteration.
            </summary>
        </member>
        <member name="P:System.Xml.Xsl.Runtime.NodeRangeIterator.Current">
            <summary>
            Return the current result navigator.  This is only defined after MoveNext() has returned true.
            </summary>
        </member>
        <member name="T:System.Xml.Xsl.Runtime.WhitespaceRuleLookup">
            <summary>
            This class keeps a list of whitespace rules in order to determine whether whitespace children of particular
            elements should be stripped.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.WhitespaceRuleLookup.#ctor(System.Collections.Generic.IList{System.Xml.Xsl.Qil.WhitespaceRule})">
            <summary>
            Create a new lookup internal class from the specified WhitespaceRules.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.WhitespaceRuleLookup.Atomize(System.Xml.XmlNameTable)">
            <summary>
            Atomize all names contained within the whitespace rules with respect to "nameTable".
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.WhitespaceRuleLookup.ShouldStripSpace(System.String,System.String)">
            <summary>
            Return true if elements of the specified name should have whitespace children stripped.
            NOTE: This method is not thread-safe.  Different threads should create their own copy of the
            WhitespaceRuleLookup object.  This allows all names to be atomized according to a private NameTable.
            </summary>
        </member>
        <member name="T:System.Xml.Xsl.Runtime.WhitespaceRuleReader">
            <summary>
            </summary>
        </member>
        <member name="P:System.Xml.Xsl.Runtime.WhitespaceRuleReader.Value">
            <summary>
            Override Value in order to possibly prepend extra whitespace.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.WhitespaceRuleReader.Read">
            <summary>
            Override Read in order to search for strippable whitespace, to concatenate adjacent text nodes, and to
            resolve entities.
            </summary>
        </member>
        <member name="T:System.Xml.Xsl.Runtime.Int32Aggregator">
            <summary>
            Computes aggregates over a sequence of Int32 values.
            </summary>
        </member>
        <member name="T:System.Xml.Xsl.Runtime.Int64Aggregator">
            <summary>
            Computes aggregates over a sequence of Int64 values.
            </summary>
        </member>
        <member name="T:System.Xml.Xsl.Runtime.DecimalAggregator">
            <summary>
            Computes aggregates over a sequence of Decimal values.
            </summary>
        </member>
        <member name="T:System.Xml.Xsl.Runtime.DoubleAggregator">
            <summary>
            Computes aggregates over a sequence of Double values.
            </summary>
        </member>
        <member name="T:System.Xml.Xsl.Runtime.XmlAttributeCache">
            <summary>
            This writer supports only writer methods which write attributes.  Attributes are stored in a
            data structure until StartElementContent() is called, at which time the attributes are flushed
            to the wrapped writer.  In the case of duplicate attributes, the last attribute's value is used.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XmlAttributeCache.Init(System.Xml.XmlRawWriter)">
            <summary>
            Initialize the cache.  Use this method instead of a constructor in order to reuse the cache.
            </summary>
        </member>
        <member name="P:System.Xml.Xsl.Runtime.XmlAttributeCache.Count">
            <summary>
            Return the number of cached attributes.
            </summary>
        </member>
        <member name="P:System.Xml.Xsl.Runtime.XmlAttributeCache.OnRemoveWriterEvent">
            <summary>
            This writer will raise this event once cached attributes have been flushed in order to signal that the cache
            no longer needs to be part of the pipeline.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XmlAttributeCache.SetWrappedWriter(System.Xml.XmlRawWriter)">
            <summary>
            The wrapped writer will callback on this method if it wishes to remove itself from the pipeline.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XmlAttributeCache.WriteStartAttribute(System.String,System.String,System.String)">
            <summary>
            Add an attribute to the cache.  If an attribute if the same name already exists, replace it.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XmlAttributeCache.WriteEndAttribute">
            <summary>
            No-op.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XmlAttributeCache.WriteNamespaceDeclaration(System.String,System.String)">
            <summary>
            Pass through namespaces to underlying writer.  If any attributes have been cached, flush them.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XmlAttributeCache.WriteString(System.String)">
            <summary>
            Add a block of text to the cache.  This text block makes up some or all of the untyped string
            value of the current attribute.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XmlAttributeCache.WriteValue(System.Object)">
            <summary>
            All other WriteValue methods are implemented by XmlWriter to delegate to WriteValue(object), so
            only this method needs to be implemented.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XmlAttributeCache.StartElementContent">
            <summary>
            Send cached, non-overridden attributes to the specified writer.  Calling this method has
            the side effect of clearing the attribute cache.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XmlAttributeCache.Close">
            <summary>
            Forward call to wrapped writer.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XmlAttributeCache.Flush">
            <summary>
            Forward call to wrapped writer.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XmlAttributeCache.AttrNameVal.Init(System.String,System.String,System.String,System.Int32)">
            <summary>
            Cache an attribute's name and type.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XmlAttributeCache.AttrNameVal.Init(System.String)">
            <summary>
            Cache all or part of the attribute's string value.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XmlAttributeCache.AttrNameVal.Init(System.Xml.Schema.XmlAtomicValue)">
            <summary>
            Cache all or part of the attribute's typed value.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XmlAttributeCache.AttrNameVal.IsDuplicate(System.String,System.String,System.Int32)">
            <summary>
            Returns true if this attribute has the specified name (and thus is a duplicate).
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XmlAttributeCache.EnsureAttributeCache">
            <summary>
            Ensure that attribute array has been created and is large enough for at least one
            additional entry.
            </summary>
        </member>
        <member name="T:System.Xml.Xsl.Runtime.XmlCollation.Options">
            <summary>
            Extends System.Globalization.CompareOptions with additional flags.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XmlCollation.#ctor(System.Globalization.CultureInfo,System.Xml.Xsl.Runtime.XmlCollation.Options)">
            <summary>
            Construct a collation that uses the specified culture and compare options.
            </summary>
        </member>
        <member name="F:System.Xml.Xsl.Runtime.XmlCollation.s_cp">
            <summary>
            Singleton collation that sorts according to Unicode code points.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XmlCollation.CreateSortKey(System.String)">
            <summary>
            Create a sort key that can be compared quickly with other keys.
            </summary>
        </member>
        <member name="T:System.Xml.Xsl.Runtime.XmlExtensionFunctionTable">
            <summary>
            Table of bound extension functions.  Once an extension function is bound and entered into the table, future bindings
            will be very fast.  This table is not thread-safe.
            </summary>
        </member>
        <member name="T:System.Xml.Xsl.Runtime.XmlExtensionFunction">
            <summary>
            This internal class contains methods that allow binding to extension functions and invoking them.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XmlExtensionFunction.#ctor">
            <summary>
            Constructor.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XmlExtensionFunction.#ctor(System.String,System.String,System.Reflection.MethodInfo)">
            <summary>
            Constructor (directly binds to passed MethodInfo).
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XmlExtensionFunction.#ctor(System.String,System.String,System.Int32,System.Type,System.Reflection.BindingFlags)">
            <summary>
            Constructor.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XmlExtensionFunction.Init(System.String,System.String,System.Int32,System.Type,System.Reflection.BindingFlags)">
            <summary>
            Initialize, but do not bind.
            </summary>
        </member>
        <member name="P:System.Xml.Xsl.Runtime.XmlExtensionFunction.Method">
            <summary>
            Once Bind has been successfully called, Method will be non-null.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XmlExtensionFunction.GetClrArgumentType(System.Int32)">
            <summary>
            Once Bind has been successfully called, the Clr type of each argument can be accessed.
            Note that this may be different than Method.GetParameterInfo().ParameterType.
            </summary>
        </member>
        <member name="P:System.Xml.Xsl.Runtime.XmlExtensionFunction.ClrReturnType">
            <summary>
            Once Bind has been successfully called, the Clr type of the return value can be accessed.
            Note that this may be different than Method.GetParameterInfo().ReturnType.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XmlExtensionFunction.GetXmlArgumentType(System.Int32)">
            <summary>
            Once Bind has been successfully called, the inferred Xml types of the arguments can be accessed.
            </summary>
        </member>
        <member name="P:System.Xml.Xsl.Runtime.XmlExtensionFunction.XmlReturnType">
            <summary>
            Once Bind has been successfully called, the inferred Xml type of the return value can be accessed.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XmlExtensionFunction.CanBind">
            <summary>
            Return true if the CLR type specified in the Init() call has a matching method.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XmlExtensionFunction.Bind">
            <summary>
            Bind to the CLR type specified in the Init() call.  If a matching method cannot be found, throw an exception.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XmlExtensionFunction.Bind(System.Reflection.MethodInfo)">
            <summary>
            Bind to the specified MethodInfo.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XmlExtensionFunction.Invoke(System.Object,System.Object[])">
            <summary>
            Convert the incoming arguments to an array of CLR objects, and then invoke the external function on the "extObj" object instance.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XmlExtensionFunction.Equals(System.Object)">
            <summary>
            Return true if this XmlExtensionFunction has the same values as another XmlExtensionFunction.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XmlExtensionFunction.GetHashCode">
            <summary>
            Return this object's hash code, previously computed for performance.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XmlExtensionFunction.GetClrType(System.Type)">
            <summary>
            1. Map enumerations to the underlying integral type.
            2. Throw an exception if the type is ByRef
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XmlExtensionFunction.InferXmlType(System.Type)">
            <summary>
            Infer an Xml type from a Clr type using Xslt inference rules
            </summary>
        </member>
        <member name="T:System.Xml.Xsl.Runtime.XmlILIndex">
            <summary>
            This class manages nodes from one input document, indexed by key value(s).
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XmlILIndex.#ctor">
            <summary>
            This constructor is internal so that external users cannot construct it (and therefore we do not have to test it separately).
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XmlILIndex.Add(System.String,System.Xml.XPath.XPathNavigator)">
            <summary>
            Add a node indexed by the specified key value.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XmlILIndex.Lookup(System.String)">
            <summary>
            Lookup a sequence of nodes that are indexed by the specified key value.
            Return a non-null empty sequence, if there are no nodes associated with the key.
            </summary>
        </member>
        <member name="T:System.Xml.Xsl.Runtime.XmlILStorageConverter">
            <summary>
            This is a simple convenience wrapper internal class that contains static helper methods that get a value
            converter from XmlQueryRuntime and use it convert among several physical Clr representations for
            the same logical Xml type.  For example, an external function might have an argument typed as
            xs:integer, with Clr type Decimal.  Since ILGen stores xs:integer as Clr type Int64 instead of
            Decimal, a conversion to the desired storage type must take place.
            </summary>
        </member>
        <member name="T:System.Xml.Xsl.Runtime.IteratorResult">
            <summary>
            Iterators that use containment to control a nested iterator return one of the following values from MoveNext().
            </summary>
        </member>
        <member name="T:System.Xml.Xsl.Runtime.IdIterator">
            <summary>
            Tokenize a string containing IDREF values and deref the values in order to get a list of ID elements.
            </summary>
        </member>
        <member name="P:System.Xml.Xsl.Runtime.IdIterator.Current">
            <summary>
            Return the current result navigator.  This is only defined after MoveNext() has returned true.
            </summary>
        </member>
        <member name="T:System.Xml.Xsl.Runtime.XmlNavigatorFilter">
            <summary>
            XmlNavigatorFilter provides a flexible filtering abstraction over XPathNavigator.  Callers do
            not know what type of filtering will occur; they simply call MoveToContent or MoveToSibling.
            The filter implementation invokes appropriate operation(s) on the XPathNavigator in order
            to skip over filtered nodes.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XmlNavigatorFilter.MoveToContent(System.Xml.XPath.XPathNavigator)">
            <summary>
            Reposition the navigator to the first matching content node (inc. attributes); skip over
            filtered nodes.  If there are no matching nodes, then don't move navigator and return false.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XmlNavigatorFilter.MoveToNextContent(System.Xml.XPath.XPathNavigator)">
            <summary>
            Reposition the navigator to the next matching content node (inc. attributes); skip over
            filtered nodes.  If there are no matching nodes, then don't move navigator and return false.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XmlNavigatorFilter.MoveToFollowingSibling(System.Xml.XPath.XPathNavigator)">
            <summary>
            Reposition the navigator to the next following sibling node (no attributes); skip over
            filtered nodes.  If there are no matching nodes, then don't move navigator and return false.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XmlNavigatorFilter.MoveToPreviousSibling(System.Xml.XPath.XPathNavigator)">
            <summary>
            Reposition the navigator to the previous sibling node (no attributes); skip over filtered
            nodes.  If there are no matching nodes, then don't move navigator and return false.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XmlNavigatorFilter.MoveToFollowing(System.Xml.XPath.XPathNavigator,System.Xml.XPath.XPathNavigator)">
            <summary>
            Reposition the navigator to the next following node (inc. descendants); skip over filtered nodes.
            If there are no matching nodes, then return false.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XmlNavigatorFilter.IsFiltered(System.Xml.XPath.XPathNavigator)">
            <summary>
            Return true if the navigator's current node matches the filter condition.
            </summary>
        </member>
        <member name="T:System.Xml.Xsl.Runtime.XmlNavNameFilter">
            <summary>
            Filters any non-element and any element with a non-matching local name or namespace uri.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XmlNavNameFilter.Create(System.String,System.String)">
            <summary>
            Return an XmlNavigatorFilter that skips over nodes that do not match the specified name.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XmlNavNameFilter.#ctor(System.String,System.String)">
            <summary>
            Keep only elements with name = localName, namespaceUri.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XmlNavNameFilter.MoveToContent(System.Xml.XPath.XPathNavigator)">
            <summary>
            Reposition the navigator on the first element child with a matching name.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XmlNavNameFilter.MoveToNextContent(System.Xml.XPath.XPathNavigator)">
            <summary>
            Reposition the navigator on the next element child with a matching name.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XmlNavNameFilter.MoveToFollowingSibling(System.Xml.XPath.XPathNavigator)">
            <summary>
            Reposition the navigator on the next element sibling with a matching name.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XmlNavNameFilter.MoveToPreviousSibling(System.Xml.XPath.XPathNavigator)">
            <summary>
            Reposition the navigator on the previous element sibling with a matching name.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XmlNavNameFilter.MoveToFollowing(System.Xml.XPath.XPathNavigator,System.Xml.XPath.XPathNavigator)">
            <summary>
            Reposition the navigator on the next following element with a matching name.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XmlNavNameFilter.IsFiltered(System.Xml.XPath.XPathNavigator)">
            <summary>
            Return false if the navigator is positioned on an element with a matching name.
            </summary>
        </member>
        <member name="T:System.Xml.Xsl.Runtime.XmlNavTypeFilter">
            <summary>
            Filters any node not of the specified type (type may not be attribute or namespace).
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XmlNavTypeFilter.CreateTypeFilters">
            <summary>
            There are a limited number of types, so create all possible XmlNavTypeFilter objects just once.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XmlNavTypeFilter.Create(System.Xml.XPath.XPathNodeType)">
            <summary>
            Return a previously constructed XmlNavigatorFilter that skips over nodes that do not match the specified type.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XmlNavTypeFilter.#ctor(System.Xml.XPath.XPathNodeType)">
            <summary>
            Keep only nodes with XPathNodeType = nodeType, where XPathNodeType.Text selects whitespace as well.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XmlNavTypeFilter.MoveToContent(System.Xml.XPath.XPathNavigator)">
            <summary>
            Reposition the navigator on the first child with a matching type.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XmlNavTypeFilter.MoveToNextContent(System.Xml.XPath.XPathNavigator)">
            <summary>
            Reposition the navigator on the next child with a matching type.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XmlNavTypeFilter.MoveToFollowingSibling(System.Xml.XPath.XPathNavigator)">
            <summary>
            Reposition the navigator on the next non-attribute sibling with a matching type.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XmlNavTypeFilter.MoveToPreviousSibling(System.Xml.XPath.XPathNavigator)">
            <summary>
            Reposition the navigator on the previous non-attribute sibling with a matching type.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XmlNavTypeFilter.MoveToFollowing(System.Xml.XPath.XPathNavigator,System.Xml.XPath.XPathNavigator)">
            <summary>
            Reposition the navigator on the next following element with a matching kind.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XmlNavTypeFilter.IsFiltered(System.Xml.XPath.XPathNavigator)">
            <summary>
            Return false if the navigator is positioned on a node with a matching type.
            </summary>
        </member>
        <member name="T:System.Xml.Xsl.Runtime.XmlNavAttrFilter">
            <summary>
            Filters all attribute nodes.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XmlNavAttrFilter.Create">
            <summary>
            Return a singleton XmlNavigatorFilter that filters all attribute nodes.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XmlNavAttrFilter.#ctor">
            <summary>
            Constructor.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XmlNavAttrFilter.MoveToContent(System.Xml.XPath.XPathNavigator)">
            <summary>
            Reposition the navigator on the first non-attribute child.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XmlNavAttrFilter.MoveToNextContent(System.Xml.XPath.XPathNavigator)">
            <summary>
            Reposition the navigator on the next non-attribute sibling.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XmlNavAttrFilter.MoveToFollowingSibling(System.Xml.XPath.XPathNavigator)">
            <summary>
            Reposition the navigator on the next non-attribute sibling.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XmlNavAttrFilter.MoveToPreviousSibling(System.Xml.XPath.XPathNavigator)">
            <summary>
            Reposition the navigator on the previous non-attribute sibling.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XmlNavAttrFilter.MoveToFollowing(System.Xml.XPath.XPathNavigator,System.Xml.XPath.XPathNavigator)">
            <summary>
            Reposition the navigator on the next following non-attribute.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XmlNavAttrFilter.IsFiltered(System.Xml.XPath.XPathNavigator)">
            <summary>
            Return true if the navigator is positioned on an attribute.
            </summary>
        </member>
        <member name="T:System.Xml.Xsl.Runtime.XmlNavNeverFilter">
            <summary>
            Never filter nodes.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XmlNavNeverFilter.Create">
            <summary>
            Return a singleton XmlNavigatorFilter that never filters any nodes.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XmlNavNeverFilter.#ctor">
            <summary>
            Constructor.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XmlNavNeverFilter.MoveToContent(System.Xml.XPath.XPathNavigator)">
            <summary>
            Reposition the navigator on the first child (attribute or non-attribute).
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XmlNavNeverFilter.MoveToNextContent(System.Xml.XPath.XPathNavigator)">
            <summary>
            Reposition the navigator on the next child (attribute or non-attribute).
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XmlNavNeverFilter.MoveToFollowingSibling(System.Xml.XPath.XPathNavigator)">
            <summary>
            Reposition the navigator on the next sibling (no attributes).
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XmlNavNeverFilter.MoveToPreviousSibling(System.Xml.XPath.XPathNavigator)">
            <summary>
            Reposition the navigator on the previous sibling (no attributes).
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XmlNavNeverFilter.MoveToFollowing(System.Xml.XPath.XPathNavigator,System.Xml.XPath.XPathNavigator)">
            <summary>
            Reposition the navigator on the next following node.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XmlNavNeverFilter.IsFiltered(System.Xml.XPath.XPathNavigator)">
            <summary>
            Nodes are never filtered so always return false.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XmlNavNeverFilter.MoveToFirstAttributeContent(System.Xml.XPath.XPathNavigator)">
            <summary>
            Move to navigator's first attribute node.  If no attribute's exist, move to the first content node.
            If no content nodes exist, return null.  Otherwise, return navigator.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XmlNavNeverFilter.MoveToNextAttributeContent(System.Xml.XPath.XPathNavigator)">
            <summary>
            If navigator is positioned on an attribute, move to the next attribute node.  If there are no more
            attributes, move to the first content node.  If navigator is positioned on a content node, move to
            the next content node.  If there are no more attributes and content nodes, return null.
            Otherwise, return navigator.
            </summary>
        </member>
        <member name="T:System.Xml.Xsl.Runtime.XmlNavigatorStack">
            <summary>
            A dynamic stack of IXmlNavigators.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XmlNavigatorStack.Push(System.Xml.XPath.XPathNavigator)">
            <summary>
            Push a navigator onto the stack
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XmlNavigatorStack.Pop">
            <summary>
            Pop the topmost navigator and return it
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XmlNavigatorStack.Peek">
            <summary>
            Returns the navigator at the top of the stack without adjusting the stack pointer
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XmlNavigatorStack.Reset">
            <summary>
            Remove all navigators from the stack
            </summary>
        </member>
        <member name="P:System.Xml.Xsl.Runtime.XmlNavigatorStack.IsEmpty">
            <summary>
            Returns true if there are no navigators in the stack
            </summary>
        </member>
        <member name="T:System.Xml.Xsl.Runtime.XmlQueryContext">
             <summary>
             The context of a query consists of all user-provided information which influences the operation of the
             query. The context manages the following information:
            
               1. Input data sources, including the default data source if one exists
               2. Extension objects
               3. External parameters
             </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XmlQueryContext.#ctor(System.Xml.Xsl.Runtime.XmlQueryRuntime,System.Object,System.Xml.XmlResolver,System.Xml.Xsl.XsltArgumentList,System.Xml.Xsl.Runtime.WhitespaceRuleLookup)">
            <summary>
            This constructor is internal so that external users cannot construct it (and therefore we do not have to test it separately).
            </summary>
        </member>
        <member name="P:System.Xml.Xsl.Runtime.XmlQueryContext.QueryNameTable">
            <summary>
            Returns the name table that should be used in the query to atomize search names and to load
            new documents.
            </summary>
        </member>
        <member name="P:System.Xml.Xsl.Runtime.XmlQueryContext.DefaultNameTable">
            <summary>
            Returns the name table used by the default data source, or null if there is no default data source.
            </summary>
        </member>
        <member name="P:System.Xml.Xsl.Runtime.XmlQueryContext.DefaultDataSource">
            <summary>
            Return the document which is queried by default--i.e. no data source is explicitly selected in the query.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XmlQueryContext.GetDataSource(System.String,System.String)">
            <summary>
            Fetch the data source specified by "uriRelative" and "uriBase" from the XmlResolver that the user provided.
            If the resolver returns a stream or reader, create an instance of XPathDocument.  If the resolver returns an
            XPathNavigator, return the navigator.  Throw an exception if no data source was found.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XmlQueryContext.ConstructDocument(System.Object,System.String,System.Uri)">
            <summary>
            Ensure that "dataSource" is cached as an XPathDocument and return a navigator over the document.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XmlQueryContext.GetParameter(System.String,System.String)">
            <summary>
            Get a named parameter from the external argument list.  Return null if no argument list was provided, or if
            there is no parameter by that name.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XmlQueryContext.GetLateBoundObject(System.String)">
            <summary>
            Return the extension object that is mapped to the specified namespace, or null if no object is mapped.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XmlQueryContext.LateBoundFunctionExists(System.String,System.String)">
            <summary>
            Return true if the late bound object identified by "namespaceUri" contains a method that matches "name".
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XmlQueryContext.InvokeXsltLateBoundFunction(System.String,System.String,System.Collections.Generic.IList{System.Xml.XPath.XPathItem}[])">
            <summary>
            Get a late-bound extension object from the external argument list.  Bind to a method on the object and invoke it,
            passing "args" as arguments.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XmlQueryContext.OnXsltMessageEncountered(System.String)">
            <summary>
            Fire the XsltMessageEncounteredEvent, passing the specified text as the message.
            </summary>
        </member>
        <member name="T:System.Xml.Xsl.Runtime.XmlILQueryEventArgs">
            <summary>
            Simple implementation of XsltMessageEncounteredEventArgs.
            </summary>
        </member>
        <member name="T:System.Xml.Xsl.Runtime.XmlQueryOutput">
            <summary>
            At run-time, a number of checks may need to be made in order to generate the correct sequence of calls
            to XmlRawWriter:
              1. Well-formedness: Illegal state transitions, StartContent detection, no-content element detection
              2. Cached attributes: In XSLT, attributes override previously constructed attributes with the same name,
                 meaning that attribute names and values cannot be prematurely sent to XmlRawWriter.
              3. Cached namespaces: All namespaces are tracked in order to ensure adequate namespaces and to ensure
                 minimal (or something close) namespaces.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XmlQueryOutput.#ctor(System.Xml.Xsl.Runtime.XmlQueryRuntime,System.Xml.Xsl.Runtime.XmlSequenceWriter)">
            <summary>
            This constructor is internal so that external users cannot construct it (and therefore we do not have to test it separately).
            Initialize output state to accept top-level sequences.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XmlQueryOutput.#ctor(System.Xml.Xsl.Runtime.XmlQueryRuntime,System.Xml.XmlEventCache)">
            <summary>
            This constructor is internal so that external users cannot construct it (and therefore we do not have to test it separately).
            Initialize output state to accept Rtf content (top-level sequences are therefore prohibited).
            </summary>
        </member>
        <member name="P:System.Xml.Xsl.Runtime.XmlQueryOutput.SequenceWriter">
            <summary>
            Sequence writer to which output is directed by this class.
            </summary>
        </member>
        <member name="P:System.Xml.Xsl.Runtime.XmlQueryOutput.Writer">
            <summary>
            Raw writer to which output is directed by this class.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XmlQueryOutput.SetWrappedWriter(System.Xml.XmlRawWriter)">
            <summary>
            This method will be called if "xwrt" is a writer which no longer needs to be part of the pipeline and
            wishes to replace itself with a different writer.  For example, the auto-detect writer replaces itself
            with the Html or Xml writer once it has determined which output mode to use.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XmlQueryOutput.WriteStartDocument">
            <summary>
            Should never be called.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XmlQueryOutput.WriteStartDocument(System.Boolean)">
            <summary>
            Should never be called.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XmlQueryOutput.WriteEndDocument">
            <summary>
            Should never be called.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XmlQueryOutput.WriteDocType(System.String,System.String,System.String,System.String)">
            <summary>
            Should never be called.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XmlQueryOutput.WriteStartElement(System.String,System.String,System.String)">
            <summary>
            Before calling XmlRawWriter.WriteStartElement(), perform various checks to ensure well-formedness.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XmlQueryOutput.WriteEndElement">
            <summary>
            Before calling XmlRawWriter.WriteEndElement(), perform various checks to ensure well-formedness.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XmlQueryOutput.WriteFullEndElement">
            <summary>
            Same as calling WriteEndElement().
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XmlQueryOutput.WriteStartAttribute(System.String,System.String,System.String)">
            <summary>
            Before calling XmlRawWriter.WriteStartAttribute(), perform various checks to ensure well-formedness.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XmlQueryOutput.WriteEndAttribute">
            <summary>
            Before calling XmlRawWriter.WriteEndAttribute(), perform various checks to ensure well-formedness.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XmlQueryOutput.WriteComment(System.String)">
            <summary>
            Before writing a comment, perform various checks to ensure well-formedness.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XmlQueryOutput.WriteProcessingInstruction(System.String,System.String)">
            <summary>
            Before writing a processing instruction, perform various checks to ensure well-formedness.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XmlQueryOutput.WriteEntityRef(System.String)">
            <summary>
            Should never be called.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XmlQueryOutput.WriteCharEntity(System.Char)">
            <summary>
            Should never be called.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XmlQueryOutput.WriteSurrogateCharEntity(System.Char,System.Char)">
            <summary>
            Should never be called.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XmlQueryOutput.WriteWhitespace(System.String)">
            <summary>
            Treat whitespace as regular text.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XmlQueryOutput.WriteString(System.String)">
            <summary>
            Before writing text, perform various checks to ensure well-formedness.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XmlQueryOutput.WriteChars(System.Char[],System.Int32,System.Int32)">
            <summary>
            Before writing text, perform various checks to ensure well-formedness.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XmlQueryOutput.WriteRaw(System.Char[],System.Int32,System.Int32)">
            <summary>
            Write text, but do not escape special characters.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XmlQueryOutput.WriteRaw(System.String)">
            <summary>
            Write text, but do not escape special characters.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XmlQueryOutput.WriteCData(System.String)">
            <summary>
            Write CData text as regular text.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XmlQueryOutput.WriteBase64(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Should never be called.
            </summary>
        </member>
        <member name="P:System.Xml.Xsl.Runtime.XmlQueryOutput.WriteState">
            <summary>
            Should never be called.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XmlQueryOutput.Close">
            <summary>
            No-op.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XmlQueryOutput.Flush">
            <summary>
            No-op.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XmlQueryOutput.LookupPrefix(System.String)">
            <summary>
            Should never be called.
            </summary>
        </member>
        <member name="P:System.Xml.Xsl.Runtime.XmlQueryOutput.XmlSpace">
            <summary>
            Should never be called.
            </summary>
        </member>
        <member name="P:System.Xml.Xsl.Runtime.XmlQueryOutput.XmlLang">
            <summary>
            Should never be called.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XmlQueryOutput.StartTree(System.Xml.XPath.XPathNodeType)">
            <summary>
            Call XmlSequenceWriter.StartTree() in order to start construction of a new tree.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XmlQueryOutput.EndTree">
            <summary>
            Call XmlSequenceWriter.EndTree().
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XmlQueryOutput.WriteStartElementUnchecked(System.String,System.String,System.String)">
            <summary>
            Call XmlRawWriter.WriteStartElement() with prefix, local-name, ns, and schema type.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XmlQueryOutput.WriteStartElementUnchecked(System.String)">
            <summary>
            Call XmlRawWriter.WriteStartElement() with empty prefix, ns, and null schema type.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XmlQueryOutput.StartElementContentUnchecked">
            <summary>
            Call XmlRawWriter.StartElementContent().
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XmlQueryOutput.WriteEndElementUnchecked(System.String,System.String,System.String)">
            <summary>
            Call XmlRawWriter.WriteEndElement() with prefix, local-name, and ns.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XmlQueryOutput.WriteEndElementUnchecked(System.String)">
            <summary>
            Call XmlRawWriter.WriteEndElement() with empty prefix, ns.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XmlQueryOutput.WriteStartAttributeUnchecked(System.String,System.String,System.String)">
            <summary>
            XmlRawWriter.WriteStartAttribute() with prefix, local-name, ns, and schema type.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XmlQueryOutput.WriteStartAttributeUnchecked(System.String)">
            <summary>
            XmlRawWriter.WriteStartAttribute() with empty prefix, ns, and null schema type.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XmlQueryOutput.WriteEndAttributeUnchecked">
            <summary>
            XmlRawWriter.WriteEndAttribute().
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XmlQueryOutput.WriteNamespaceDeclarationUnchecked(System.String,System.String)">
            <summary>
            Add a new namespace declaration -- xmlns:prefix="ns" -- to the set of in-scope declarations.
            NOTE: This method should only be called if caller can guarantee that the current state is EnumAttrs
                  and that there will be no namespace conflicts in the current scope (e.g. trying to map the
                  same prefix to different namespaces within the same element start tag).  If no such
                  guarantees exist, then WriteNamespaceDeclaration() should be called instead.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XmlQueryOutput.WriteStringUnchecked(System.String)">
            <summary>
            Write a text block to the XmlRawWriter.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XmlQueryOutput.WriteRawUnchecked(System.String)">
            <summary>
            Write a text block without escaping special characters.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XmlQueryOutput.WriteStartRoot">
            <summary>
            Before calling XmlSequenceWriter.StartTree(), perform checks to ensure well-formedness.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XmlQueryOutput.WriteEndRoot">
            <summary>
            Call XmlSequenceWriter.EndTree() and reset state.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XmlQueryOutput.WriteStartElementLocalName(System.String)">
            <summary>
            WriteStartElement() with empty prefix, ns.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XmlQueryOutput.WriteStartAttributeLocalName(System.String)">
            <summary>
            WriteStartAttribute() with empty prefix, ns, and null schema type.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XmlQueryOutput.WriteStartElementComputed(System.String,System.Int32)">
            <summary>
            Write an element with a name that is computed from a "prefix:localName" tag name and a set of prefix mappings.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XmlQueryOutput.WriteStartElementComputed(System.String,System.String)">
            <summary>
            Write an element with a name that is computed from a "prefix:localName" tag name and a namespace URI.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XmlQueryOutput.WriteStartElementComputed(System.Xml.XPath.XPathNavigator)">
            <summary>
            Write an element with a name that is copied from the navigator.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XmlQueryOutput.WriteStartElementComputed(System.Xml.XmlQualifiedName)">
            <summary>
            Write an element with a name that is derived from the XmlQualifiedName.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XmlQueryOutput.WriteStartAttributeComputed(System.String,System.Int32)">
            <summary>
            Write an attribute with a name that is computed from a "prefix:localName" tag name and a set of prefix mappings.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XmlQueryOutput.WriteStartAttributeComputed(System.String,System.String)">
            <summary>
            Write an attribute with a name that is computed from a "prefix:localName" tag name and a namespace URI.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XmlQueryOutput.WriteStartAttributeComputed(System.Xml.XPath.XPathNavigator)">
            <summary>
            Write an attribute with a name that is copied from the navigator.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XmlQueryOutput.WriteStartAttributeComputed(System.Xml.XmlQualifiedName)">
            <summary>
            Write an attribute with a name that is derived from the XmlQualifiedName.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XmlQueryOutput.WriteNamespaceDeclaration(System.String,System.String)">
            <summary>
            Before calling XmlRawWriter.WriteNamespaceDeclaration(), perform various checks to ensure well-formedness.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XmlQueryOutput.WriteStartNamespace(System.String)">
            <summary>
            Before writing a namespace, perform various checks to ensure well-formedness.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XmlQueryOutput.WriteNamespaceString(System.String)">
            <summary>
            Cache the namespace's text.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XmlQueryOutput.WriteEndNamespace">
            <summary>
            Before writing a namespace, perform various checks to ensure well-formedness.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XmlQueryOutput.WriteStartComment">
            <summary>
            Before writing a comment, perform various checks to ensure well-formedness.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XmlQueryOutput.WriteCommentString(System.String)">
            <summary>
            Cache the comment's text.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XmlQueryOutput.WriteEndComment">
            <summary>
            Before writing a comment, perform various checks to ensure well-formedness.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XmlQueryOutput.WriteStartProcessingInstruction(System.String)">
            <summary>
            Before writing a processing instruction, perform various checks to ensure well-formedness.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XmlQueryOutput.WriteProcessingInstructionString(System.String)">
            <summary>
            Cache the processing instruction's text.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XmlQueryOutput.WriteEndProcessingInstruction">
            <summary>
            Before writing a processing instruction, perform various checks to ensure well-formedness.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XmlQueryOutput.WriteItem(System.Xml.XPath.XPathItem)">
            <summary>
            Write an item to output.  If currently constructing an Xml tree, then the item is always copied.
            At the top-level, the item's identity is preserved unless it's an atomic value.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XmlQueryOutput.XsltCopyOf(System.Xml.XPath.XPathNavigator)">
            <summary>
            Copy a node by value to output according to Xslt rules:
              1. Identity is never preserved
              2. If the item is an Rtf, preserve serialization hints when copying.
              3. If the item is a Root node, copy the children of the Root
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XmlQueryOutput.StartCopy(System.Xml.XPath.XPathNavigator)">
            <summary>
            Begin shallow copy of the navigator's current node to output.  Returns true if EndCopy
            should be called to complete the copy operation.
            Automatically copies all in-scope namespaces on elements.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XmlQueryOutput.EndCopy(System.Xml.XPath.XPathNavigator)">
            <summary>
            End shallow copy of the navigator's current node.  Should be called only for Element and Document nodes.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XmlQueryOutput.AddNamespace(System.String,System.String)">
            <summary>
            Add an in-scope namespace.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XmlQueryOutput.WriteString(System.String,System.Boolean)">
            <summary>
            Before writing text, perform various checks to ensure well-formedness.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XmlQueryOutput.CopyNode(System.Xml.XPath.XPathNavigator)">
            <summary>
            Deep copy the subtree that is rooted at this navigator's current position to output.  If the current
            item is an element, copy all in-scope namespace nodes.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XmlQueryOutput.StartCopy(System.Xml.XPath.XPathNavigator,System.Boolean)">
            <summary>
            Begin shallow copy of the navigator's current node to output.  Returns true if EndCopy
            should be called to complete the copy operation.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XmlQueryOutput.EndCopy(System.Xml.XPath.XPathNavigator,System.Boolean)">
            <summary>
            End shallow copy of the navigator's current node to output.  This method should only be called if StartCopy
            returned true.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XmlQueryOutput.CopyNamespaces(System.Xml.XPath.XPathNavigator,System.Xml.XPath.XPathNamespaceScope)">
            <summary>
            Copy all namespaces of the specified type (in-scope, exclude-xml, local) in document order to output.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XmlQueryOutput.CopyNamespacesHelper(System.Xml.XPath.XPathNavigator,System.Xml.XPath.XPathNamespaceScope)">
            <summary>
            Recursive helper function that reverses order of the namespaces retrieved by MoveToFirstNamespace and
            MoveToNextNamespace.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XmlQueryOutput.ConstructWithinContent(System.Xml.XPath.XPathNodeType)">
            <summary>
            Ensure that state transitions to WithinContent.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XmlQueryOutput.ConstructInEnumAttrs(System.Xml.XPath.XPathNodeType)">
            <summary>
            Ensure that state transitions to EnumAttrs.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XmlQueryOutput.WriteCachedNamespaces">
            <summary>
            Namespace declarations are added to this.nsmgr.  Just before element content has begun, write out
            all namespaces that were declared locally on the element.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XmlQueryOutput.XmlStateToNodeType(System.Xml.Xsl.Runtime.XmlState)">
            <summary>
            Return the type of node that is under construction given the specified XmlState.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XmlQueryOutput.CheckAttributePrefix(System.String,System.String)">
            <summary>
            If attribute's prefix conflicts with other prefixes then redeclare the prefix.  If the prefix has
            not yet been declared, then add it to the namespace manager.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XmlQueryOutput.RemapPrefix(System.String,System.String,System.Boolean)">
             <summary>
             Remaps an element or attribute prefix using the following rules:
            
               1. If another in-scope prefix is already mapped to "ns", then use that
               2. Otherwise, if a prefix was previously mapped to "ns" by this method, then use that
               3. Otherwise, generate a new prefix of the form 'xp_??', where ?? is a stringized counter
            
             These rules tend to reduce the number of unique prefixes used throughout the tree.
             </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XmlQueryOutput.WriteStartComputed(System.Xml.XPath.XPathNodeType,System.String,System.Int32)">
            <summary>
            Write an element or attribute with a name that is computed from a "prefix:localName" tag name and a set of prefix mappings.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XmlQueryOutput.WriteStartComputed(System.Xml.XPath.XPathNodeType,System.String,System.String)">
            <summary>
            Write an element or attribute with a name that is computed from a "prefix:localName" tag name and a namespace URI.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XmlQueryOutput.WriteStartComputed(System.Xml.XPath.XPathNodeType,System.Xml.XPath.XPathNavigator)">
            <summary>
            Write an element or attribute with a name that is copied from the navigator.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XmlQueryOutput.WriteStartComputed(System.Xml.XPath.XPathNodeType,System.Xml.XmlQualifiedName)">
            <summary>
            Write an element or attribute with a name that is derived from the XmlQualifiedName.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XmlQueryOutput.EnsureValidName(System.String,System.String,System.String,System.Xml.XPath.XPathNodeType)">
            <summary>
            Ensure that the specified name parts are valid according to Xml 1.0 and Namespace 1.0 rules.  Try to remap
            the prefix in order to attain validity.  Throw if validity is not possible.  Otherwise, return the (possibly
            remapped) prefix.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XmlQueryOutput.PushElementNames(System.String,System.String,System.String)">
            <summary>
            Push element name parts onto the stack.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XmlQueryOutput.PopElementNames(System.String@,System.String@,System.String@)">
            <summary>
            Pop element name parts from the stack.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XmlQueryOutput.ThrowInvalidStateError(System.Xml.XPath.XPathNodeType)">
            <summary>
            Throw an invalid state transition error.
            </summary>
        </member>
        <member name="T:System.Xml.Xsl.Runtime.XmlQueryRuntime">
             <summary>
             XmlQueryRuntime is passed as the first parameter to all generated query methods.
            
             XmlQueryRuntime contains runtime support for generated ILGen queries:
               1. Stack of output writers (stack handles nested document construction)
               2. Manages list of all xml types that are used within the query
               3. Manages list of all atomized names that are used within the query
             </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XmlQueryRuntime.#ctor(System.Xml.Xsl.Runtime.XmlQueryStaticData,System.Object,System.Xml.XmlResolver,System.Xml.Xsl.XsltArgumentList,System.Xml.Xsl.Runtime.XmlSequenceWriter)">
            <summary>
            This constructor is internal so that external users cannot construct it (and therefore we do not have to test it separately).
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XmlQueryRuntime.DebugGetGlobalNames">
            <summary>
            Return array containing the names of all the global variables and parameters used in this query, in this format:
                {namespace}prefix:local-name
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XmlQueryRuntime.DebugGetGlobalValue(System.String)">
            <summary>
            Get the value of a global value having the specified name.  Always return the global value as a list of XPathItem.
            Return null if there is no global value having the specified name.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XmlQueryRuntime.DebugSetGlobalValue(System.String,System.Object)">
            <summary>
            Set the value of a global value having the specified name.  If there is no such value, this method is a no-op.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XmlQueryRuntime.DebugGetXsltValue(System.Collections.IList)">
            <summary>
            Convert sequence to it's appropriate XSLT type and return to caller.
            </summary>
        </member>
        <member name="P:System.Xml.Xsl.Runtime.XmlQueryRuntime.ExternalContext">
            <summary>
            Return the object that manages external user context information such as data sources, parameters, extension objects, etc.
            </summary>
        </member>
        <member name="P:System.Xml.Xsl.Runtime.XmlQueryRuntime.XsltFunctions">
            <summary>
            Return the object that manages the state needed to implement various Xslt functions.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XmlQueryRuntime.GetEarlyBoundObject(System.Int32)">
            <summary>
            Get the early-bound extension object identified by "index".  If it does not yet exist, create an instance using the
            corresponding ConstructorInfo.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XmlQueryRuntime.EarlyBoundFunctionExists(System.String,System.String)">
            <summary>
            Return true if the early bound object identified by "namespaceUri" contains a method that matches "name".
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XmlQueryRuntime.IsGlobalComputed(System.Int32)">
            <summary>
            Return true if the global value specified by idxValue was previously computed.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XmlQueryRuntime.GetGlobalValue(System.Int32)">
            <summary>
            Return the value that is bound to the global variable or parameter specified by idxValue.
            If the value has not yet been computed, then compute it now and store it in this.globalValues.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XmlQueryRuntime.SetGlobalValue(System.Int32,System.Object)">
            <summary>
            Return the value that is bound to the global variable or parameter specified by idxValue.
            If the value has not yet been computed, then compute it now and store it in this.globalValues.
            </summary>
        </member>
        <member name="P:System.Xml.Xsl.Runtime.XmlQueryRuntime.NameTable">
            <summary>
            Return the name table used to atomize all names used by the query.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XmlQueryRuntime.GetAtomizedName(System.Int32)">
            <summary>
            Get the atomized name at the specified index in the array of names.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XmlQueryRuntime.GetNameFilter(System.Int32)">
            <summary>
            Get the name filter at the specified index in the array of filters.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XmlQueryRuntime.GetTypeFilter(System.Xml.XPath.XPathNodeType)">
            <summary>
            XPathNodeType.All: Filters all nodes
            XPathNodeType.Attribute: Filters attributes
            XPathNodeType.Namespace: Not allowed
            XPathNodeType.XXX: Filters all nodes *except* those having XPathNodeType.XXX
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XmlQueryRuntime.ParseTagName(System.String,System.Int32)">
            <summary>
            Parse the specified tag name (foo:bar) and resolve the resulting prefix.  If the prefix cannot be resolved,
            then throw an error.  Return an XmlQualifiedName.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XmlQueryRuntime.ParseTagName(System.String,System.String)">
            <summary>
            Parse the specified tag name (foo:bar).  Return an XmlQualifiedName consisting of the parsed local name
            and the specified namespace.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XmlQueryRuntime.ParseTagName(System.String,System.Int32,System.String@,System.String@,System.String@)">
            <summary>
            Parse the specified tag name (foo:bar) and resolve the resulting prefix.  If the prefix cannot be resolved,
            then throw an error.  Return the prefix, localName, and namespace URI.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XmlQueryRuntime.IsQNameEqual(System.Xml.XPath.XPathNavigator,System.Xml.XPath.XPathNavigator)">
            <summary>
            Return true if the nav1's LocalName and NamespaceURI properties equal nav2's corresponding properties.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XmlQueryRuntime.IsQNameEqual(System.Xml.XPath.XPathNavigator,System.Int32,System.Int32)">
            <summary>
            Return true if the specified navigator's LocalName and NamespaceURI properties equal the argument names.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XmlQueryRuntime.GetXmlType(System.Int32)">
            <summary>
            Get the Xml query type at the specified index in the array of types.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XmlQueryRuntime.ChangeTypeXsltArgument(System.Int32,System.Object,System.Type)">
            <summary>
            Forward call to ChangeTypeXsltArgument(XmlQueryType, object, Type).
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XmlQueryRuntime.ChangeTypeXsltArgument(System.Xml.Xsl.XmlQueryType,System.Object,System.Type)">
            <summary>
            Convert from the Clr type of "value" to Clr type "destinationType" using V1 Xslt rules.
            These rules include converting any Rtf values to Nodes.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XmlQueryRuntime.ChangeTypeXsltResult(System.Int32,System.Object)">
            <summary>
            Forward call to ChangeTypeXsltResult(XmlQueryType, object)
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XmlQueryRuntime.ChangeTypeXsltResult(System.Xml.Xsl.XmlQueryType,System.Object)">
            <summary>
            Convert from the Clr type of "value" to the default Clr type that ILGen uses to represent the xml type, using
            the conversion rules of the xml type.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XmlQueryRuntime.EnsureNavigator(System.Object)">
            <summary>
            Ensure that "value" is a navigator and not null.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XmlQueryRuntime.MatchesXmlType(System.Collections.Generic.IList{System.Xml.XPath.XPathItem},System.Int32)">
            <summary>
            Return true if the type of every item in "seq" matches the xml type identified by "idxType".
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XmlQueryRuntime.MatchesXmlType(System.Xml.XPath.XPathItem,System.Int32)">
            <summary>
            Return true if the type of "item" matches the xml type identified by "idxType".
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XmlQueryRuntime.MatchesXmlType(System.Collections.Generic.IList{System.Xml.XPath.XPathItem},System.Xml.Schema.XmlTypeCode)">
            <summary>
            Return true if the type of "seq" is a subtype of a singleton type identified by "code".
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XmlQueryRuntime.MatchesXmlType(System.Xml.XPath.XPathItem,System.Xml.Schema.XmlTypeCode)">
            <summary>
            Return true if the type of "item" is a subtype of the type identified by "code".
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XmlQueryRuntime.CreateXmlType(System.Xml.XPath.XPathItem)">
            <summary>
            Create an XmlQueryType that represents the type of "item".
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XmlQueryRuntime.GetCollation(System.Int32)">
            <summary>
            Get a collation that was statically created.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XmlQueryRuntime.CreateCollation(System.String)">
            <summary>
            Create a collation from a string.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XmlQueryRuntime.ComparePosition(System.Xml.XPath.XPathNavigator,System.Xml.XPath.XPathNavigator)">
            <summary>
            Compare the relative positions of two navigators.  Return -1 if navThis is before navThat, 1 if after, and
            0 if they are positioned to the same node.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XmlQueryRuntime.DocOrderDistinct(System.Collections.Generic.IList{System.Xml.XPath.XPathNavigator})">
            <summary>
            Get a comparer which guarantees a stable ordering among nodes, even those from different documents.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XmlQueryRuntime.GenerateId(System.Xml.XPath.XPathNavigator)">
            <summary>
            Generate a unique string identifier for the specified node.  Do this by asking the navigator for an identifier
            that is unique within the document, and then prepend a document index.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XmlQueryRuntime.FindIndex(System.Xml.XPath.XPathNavigator,System.Int32,System.Xml.Xsl.Runtime.XmlILIndex@)">
            <summary>
            If an index having the specified Id has already been created over the "context" document, then return it
            in "index" and return true.  Otherwise, create a new, empty index and return false.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XmlQueryRuntime.AddNewIndex(System.Xml.XPath.XPathNavigator,System.Int32,System.Xml.Xsl.Runtime.XmlILIndex)">
            <summary>
            Add a newly built index over the specified "context" document to the existing collection of indexes.
            </summary>
        </member>
        <member name="P:System.Xml.Xsl.Runtime.XmlQueryRuntime.Output">
            <summary>
            Get output writer object.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XmlQueryRuntime.StartSequenceConstruction(System.Xml.Xsl.Runtime.XmlQueryOutput@)">
            <summary>
            Start construction of a nested sequence of items. Return a new XmlQueryOutput that will be
            used to construct this new sequence.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XmlQueryRuntime.EndSequenceConstruction(System.Xml.Xsl.Runtime.XmlQueryOutput@)">
            <summary>
            End construction of a nested sequence of items and return the items as an IList{XPathItem}
            internal class.  Return previous XmlQueryOutput.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XmlQueryRuntime.StartRtfConstruction(System.String,System.Xml.Xsl.Runtime.XmlQueryOutput@)">
            <summary>
            Start construction of an Rtf. Return a new XmlQueryOutput object that will be used to construct this Rtf.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XmlQueryRuntime.EndRtfConstruction(System.Xml.Xsl.Runtime.XmlQueryOutput@)">
            <summary>
            End construction of an Rtf and return it as an RtfNavigator.  Return previous XmlQueryOutput object.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XmlQueryRuntime.TextRtfConstruction(System.String,System.String)">
            <summary>
            Construct a new RtfTextNavigator from the specified "text".  This is much more efficient than calling
            StartNodeConstruction(), StartRtf(), WriteString(), EndRtf(), and EndNodeConstruction().
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XmlQueryRuntime.SendMessage(System.String)">
            <summary>
            Report query execution information to event handler.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XmlQueryRuntime.ThrowException(System.String)">
            <summary>
            Throw an Xml exception having the specified message text.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XmlQueryRuntime.SyncToNavigator(System.Xml.XPath.XPathNavigator,System.Xml.XPath.XPathNavigator)">
            <summary>
            Position navThis to the same location as navThat.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XmlQueryRuntime.OnCurrentNodeChanged(System.Xml.XPath.XPathNavigator)">
            <summary>
            Function is called in Debug mode on each time context node change.
            </summary>
        </member>
        <member name="T:System.Xml.Xsl.Runtime.XmlQuerySequence`1">
            <summary>
            A sequence of Xml values that dynamically expands and allows random access to items.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XmlQuerySequence`1.CreateOrReuse(System.Xml.Xsl.Runtime.XmlQuerySequence{`0})">
            <summary>
            If "seq" is non-null, then clear it and reuse it.  Otherwise, create a new XmlQuerySequence.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XmlQuerySequence`1.CreateOrReuse(System.Xml.Xsl.Runtime.XmlQuerySequence{`0},`0)">
            <summary>
            If "seq" is non-null, then clear it and reuse it.  Otherwise, create a new XmlQuerySequence.
            Add "item" to the sequence.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XmlQuerySequence`1.#ctor">
            <summary>
            Construct new sequence.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XmlQuerySequence`1.#ctor(System.Int32)">
            <summary>
            Construct new sequence.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XmlQuerySequence`1.#ctor(`0[],System.Int32)">
            <summary>
            Construct sequence from the specified array.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XmlQuerySequence`1.#ctor(`0)">
            <summary>
            Construct singleton sequence having "value" as its only element.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XmlQuerySequence`1.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Return IEnumerator implementation.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XmlQuerySequence`1.GetEnumerator">
            <summary>
            Return IEnumerator{T} implementation.
            </summary>
        </member>
        <member name="P:System.Xml.Xsl.Runtime.XmlQuerySequence`1.Count">
            <summary>
            Return the number of items in the sequence.
            </summary>
        </member>
        <member name="P:System.Xml.Xsl.Runtime.XmlQuerySequence`1.System#Collections#ICollection#IsSynchronized">
            <summary>
            The XmlQuerySequence is not thread-safe.
            </summary>
        </member>
        <member name="P:System.Xml.Xsl.Runtime.XmlQuerySequence`1.System#Collections#ICollection#SyncRoot">
            <summary>
            This instance can be used to synchronize access.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XmlQuerySequence`1.System#Collections#ICollection#CopyTo(System.Array,System.Int32)">
            <summary>
            Copy contents of this sequence to the specified Array, starting at the specified index in the target array.
            </summary>
        </member>
        <member name="P:System.Xml.Xsl.Runtime.XmlQuerySequence`1.System#Collections#Generic#ICollection{T}#IsReadOnly">
            <summary>
            Items may not be added, removed, or modified through the ICollection{T} interface.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XmlQuerySequence`1.System#Collections#Generic#ICollection{T}#Add(`0)">
            <summary>
            Items may not be added through the ICollection{T} interface.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XmlQuerySequence`1.System#Collections#Generic#ICollection{T}#Clear">
            <summary>
            Items may not be cleared through the ICollection{T} interface.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XmlQuerySequence`1.Contains(`0)">
            <summary>
            Returns true if the specified value is in the sequence.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XmlQuerySequence`1.CopyTo(`0[],System.Int32)">
            <summary>
            Copy contents of this sequence to the specified Array, starting at the specified index in the target array.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XmlQuerySequence`1.System#Collections#Generic#ICollection{T}#Remove(`0)">
            <summary>
            Items may not be removed through the ICollection{T} interface.
            </summary>
        </member>
        <member name="P:System.Xml.Xsl.Runtime.XmlQuerySequence`1.System#Collections#IList#IsFixedSize">
            <summary>
            Items may not be added, removed, or modified through the IList interface.
            </summary>
        </member>
        <member name="P:System.Xml.Xsl.Runtime.XmlQuerySequence`1.System#Collections#IList#IsReadOnly">
            <summary>
            Items may not be added, removed, or modified through the IList interface.
            </summary>
        </member>
        <member name="P:System.Xml.Xsl.Runtime.XmlQuerySequence`1.System#Collections#IList#Item(System.Int32)">
            <summary>
            Return item at the specified index.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XmlQuerySequence`1.System#Collections#IList#Add(System.Object)">
            <summary>
            Items may not be added through the IList interface.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XmlQuerySequence`1.System#Collections#IList#Clear">
            <summary>
            Items may not be cleared through the IList interface.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XmlQuerySequence`1.System#Collections#IList#Contains(System.Object)">
            <summary>
            Returns true if the specified value is in the sequence.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XmlQuerySequence`1.System#Collections#IList#IndexOf(System.Object)">
            <summary>
            Returns the index of the specified value in the sequence.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XmlQuerySequence`1.System#Collections#IList#Insert(System.Int32,System.Object)">
            <summary>
            Items may not be added through the IList interface.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XmlQuerySequence`1.System#Collections#IList#Remove(System.Object)">
            <summary>
            Items may not be removed through the IList interface.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XmlQuerySequence`1.System#Collections#IList#RemoveAt(System.Int32)">
            <summary>
            Items may not be removed through the IList interface.
            </summary>
        </member>
        <member name="P:System.Xml.Xsl.Runtime.XmlQuerySequence`1.Item(System.Int32)">
            <summary>
            Return item at the specified index.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XmlQuerySequence`1.IndexOf(`0)">
            <summary>
            Returns the index of the specified value in the sequence.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XmlQuerySequence`1.System#Collections#Generic#IList{T}#Insert(System.Int32,`0)">
            <summary>
            Items may not be added through the IList{T} interface.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XmlQuerySequence`1.System#Collections#Generic#IList{T}#RemoveAt(System.Int32)">
            <summary>
            Items may not be removed through the IList{T} interface.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XmlQuerySequence`1.Clear">
            <summary>
            Clear the cache.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XmlQuerySequence`1.Add(`0)">
            <summary>
            Add an item to the sequence.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XmlQuerySequence`1.SortByKeys(System.Array)">
            <summary>
            Sort the items in the cache using the keys contained in the provided array.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XmlQuerySequence`1.EnsureCache">
            <summary>
            Ensure that an array of the specified type is created and has room for at least one more item.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XmlQuerySequence`1.OnItemsChanged">
            <summary>
            This method is called when one or more items in the cache have been added or removed.
            By default, it does nothing, but subclasses can override it.
            </summary>
        </member>
        <member name="T:System.Xml.Xsl.Runtime.XmlQueryItemSequence">
            <summary>
            A sequence of Xml items that dynamically expands and allows random access to items.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XmlQueryItemSequence.CreateOrReuse(System.Xml.Xsl.Runtime.XmlQueryItemSequence)">
            <summary>
            If "seq" is non-null, then clear it and reuse it.  Otherwise, create a new XmlQueryItemSequence.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XmlQueryItemSequence.CreateOrReuse(System.Xml.Xsl.Runtime.XmlQueryItemSequence,System.Xml.XPath.XPathItem)">
            <summary>
            If "seq" is non-null, then clear it and reuse it.  Otherwise, create a new XmlQueryItemSequence.
            Add "item" to the sequence.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XmlQueryItemSequence.#ctor">
            <summary>
            Construct sequence from the specified array.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XmlQueryItemSequence.#ctor(System.Int32)">
            <summary>
            Construct sequence with the specified initial capacity.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XmlQueryItemSequence.#ctor(System.Xml.XPath.XPathItem)">
            <summary>
            Construct singleton sequence from a single item.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XmlQueryItemSequence.AddClone(System.Xml.XPath.XPathItem)">
            <summary>
            Add an item to the sequence; clone the item before doing so if it's a navigator.
            </summary>
        </member>
        <member name="T:System.Xml.Xsl.Runtime.XmlQueryNodeSequence">
            <summary>
            A sequence of Xml nodes that dynamically expands and allows random access to items.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XmlQueryNodeSequence.CreateOrReuse(System.Xml.Xsl.Runtime.XmlQueryNodeSequence)">
            <summary>
            If "seq" is non-null, then clear it and reuse it.  Otherwise, create a new XmlQueryNodeSequence.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XmlQueryNodeSequence.CreateOrReuse(System.Xml.Xsl.Runtime.XmlQueryNodeSequence,System.Xml.XPath.XPathNavigator)">
            <summary>
            If "seq" is non-null, then clear it and reuse it.  Otherwise, create a new XmlQueryNodeSequence.
            Add "nav" to the sequence.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XmlQueryNodeSequence.#ctor">
            <summary>
            Construct sequence with the specified initial capacity.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XmlQueryNodeSequence.#ctor(System.Int32)">
            <summary>
            Construct sequence from the specified array.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XmlQueryNodeSequence.#ctor(System.Collections.Generic.IList{System.Xml.XPath.XPathNavigator})">
            <summary>
            Construct sequence from the specified array, cloning each navigator before adding it.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XmlQueryNodeSequence.#ctor(System.Xml.XPath.XPathNavigator[],System.Int32)">
            <summary>
            Construct sequence from the specified array.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XmlQueryNodeSequence.#ctor(System.Xml.XPath.XPathNavigator)">
            <summary>
            Construct singleton sequence from a single navigator.
            </summary>
        </member>
        <member name="P:System.Xml.Xsl.Runtime.XmlQueryNodeSequence.IsDocOrderDistinct">
            <summary>
            If this property is true, then the nodes in this cache are already in document order with no duplicates.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XmlQueryNodeSequence.DocOrderDistinct(System.Collections.Generic.IComparer{System.Xml.XPath.XPathNavigator})">
            <summary>
            Return a sequence which contains all distinct nodes in this cache, sorted by document order.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XmlQueryNodeSequence.AddClone(System.Xml.XPath.XPathNavigator)">
            <summary>
            Add a node to the sequence; clone the navigator before doing so.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XmlQueryNodeSequence.OnItemsChanged">
            <summary>
            If any items in the sequence change, then clear docOrderDistinct pointer as well.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XmlQueryNodeSequence.System#Collections#Generic#IEnumerable{System#Xml#XPath#XPathItem}#GetEnumerator">
            <summary>
            Return IEnumerator{XPathItem} implementation.
            </summary>
        </member>
        <member name="P:System.Xml.Xsl.Runtime.XmlQueryNodeSequence.System#Collections#Generic#ICollection{System#Xml#XPath#XPathItem}#IsReadOnly">
            <summary>
            Items may not be added, removed, or modified through the ICollection{T} interface.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XmlQueryNodeSequence.System#Collections#Generic#ICollection{System#Xml#XPath#XPathItem}#Add(System.Xml.XPath.XPathItem)">
            <summary>
            Items may not be added through the ICollection{T} interface.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XmlQueryNodeSequence.System#Collections#Generic#ICollection{System#Xml#XPath#XPathItem}#Clear">
            <summary>
            Items may not be cleared through the ICollection{T} interface.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XmlQueryNodeSequence.System#Collections#Generic#ICollection{System#Xml#XPath#XPathItem}#Contains(System.Xml.XPath.XPathItem)">
            <summary>
            Returns true if the specified value is in the sequence.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XmlQueryNodeSequence.System#Collections#Generic#ICollection{System#Xml#XPath#XPathItem}#CopyTo(System.Xml.XPath.XPathItem[],System.Int32)">
            <summary>
            Copy contents of this sequence to the specified Array, starting at the specified index in the target array.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XmlQueryNodeSequence.System#Collections#Generic#ICollection{System#Xml#XPath#XPathItem}#Remove(System.Xml.XPath.XPathItem)">
            <summary>
            Items may not be removed through the ICollection{T} interface.
            </summary>
        </member>
        <member name="P:System.Xml.Xsl.Runtime.XmlQueryNodeSequence.System#Collections#Generic#IList{System#Xml#XPath#XPathItem}#Item(System.Int32)">
            <summary>
            Return item at the specified index.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XmlQueryNodeSequence.System#Collections#Generic#IList{System#Xml#XPath#XPathItem}#IndexOf(System.Xml.XPath.XPathItem)">
            <summary>
            Returns the index of the specified value in the sequence.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XmlQueryNodeSequence.System#Collections#Generic#IList{System#Xml#XPath#XPathItem}#Insert(System.Int32,System.Xml.XPath.XPathItem)">
            <summary>
            Items may not be added through the IList{T} interface.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XmlQueryNodeSequence.System#Collections#Generic#IList{System#Xml#XPath#XPathItem}#RemoveAt(System.Int32)">
            <summary>
            Items may not be removed through the IList{T} interface.
            </summary>
        </member>
        <member name="T:System.Xml.Xsl.Runtime.XmlQueryStaticData">
            <summary>
            Contains all static data that is used by the runtime.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XmlQueryStaticData.#ctor(System.Xml.XmlWriterSettings,System.Collections.Generic.IList{System.Xml.Xsl.Qil.WhitespaceRule},System.Xml.Xsl.IlGen.StaticDataManager)">
            <summary>
            Constructor.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XmlQueryStaticData.#ctor(System.Byte[],System.Type[])">
            <summary>
            Deserialize XmlQueryStaticData object from a byte array.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XmlQueryStaticData.GetObjectData(System.Byte[]@,System.Type[]@)">
            <summary>
            Serialize XmlQueryStaticData object into a byte array.
            </summary>
        </member>
        <member name="P:System.Xml.Xsl.Runtime.XmlQueryStaticData.DefaultWriterSettings">
            <summary>
            Return the default writer settings.
            </summary>
        </member>
        <member name="P:System.Xml.Xsl.Runtime.XmlQueryStaticData.WhitespaceRules">
            <summary>
            Return the rules used for whitespace stripping/preservation.
            </summary>
        </member>
        <member name="P:System.Xml.Xsl.Runtime.XmlQueryStaticData.Names">
            <summary>
            Return array of names used by this query.
            </summary>
        </member>
        <member name="P:System.Xml.Xsl.Runtime.XmlQueryStaticData.PrefixMappingsList">
            <summary>
            Return array of prefix mappings used by this query.
            </summary>
        </member>
        <member name="P:System.Xml.Xsl.Runtime.XmlQueryStaticData.Filters">
            <summary>
            Return array of name filter specifications used by this query.
            </summary>
        </member>
        <member name="P:System.Xml.Xsl.Runtime.XmlQueryStaticData.Types">
            <summary>
            Return array of types used by this query.
            </summary>
        </member>
        <member name="P:System.Xml.Xsl.Runtime.XmlQueryStaticData.Collations">
            <summary>
            Return array of collations used by this query.
            </summary>
        </member>
        <member name="P:System.Xml.Xsl.Runtime.XmlQueryStaticData.GlobalNames">
            <summary>
            Return names of all global variables and parameters used by this query.
            </summary>
        </member>
        <member name="P:System.Xml.Xsl.Runtime.XmlQueryStaticData.EarlyBound">
            <summary>
            Return array of early bound object information related to this query.
            </summary>
        </member>
        <member name="T:System.Xml.Xsl.Runtime.XmlQueryDataReader">
            <summary>
            Subclass of BinaryReader used to serialize query static data.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XmlQueryDataReader.ReadStringQ">
            <summary>
            Read a string value from the stream. Value can be null.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XmlQueryDataReader.ReadSByte(System.SByte,System.SByte)">
            <summary>
            Read a signed byte value from the stream and check if it belongs to the given diapason.
            </summary>
        </member>
        <member name="T:System.Xml.Xsl.Runtime.XmlQueryDataWriter">
            <summary>
            Subclass of BinaryWriter used to deserialize query static data.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XmlQueryDataWriter.WriteStringQ(System.String)">
            <summary>
            Write a string value to the stream. Value can be null.
            </summary>
        </member>
        <member name="T:System.Xml.Xsl.Runtime.XmlRawWriterWrapper">
            <summary>
            This internal class implements the XmlRawWriter interface by passing all calls to a wrapped XmlWriter implementation.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XmlRawWriterWrapper.WriteXmlDeclaration(System.Xml.XmlStandalone)">
            <summary>
            No-op.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XmlRawWriterWrapper.WriteXmlDeclaration(System.String)">
            <summary>
            No-op.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XmlRawWriterWrapper.StartElementContent">
            <summary>
            No-op.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XmlRawWriterWrapper.WriteEndElement(System.String,System.String,System.String)">
            <summary>
            Forward to WriteEndElement().
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XmlRawWriterWrapper.WriteFullEndElement(System.String,System.String,System.String)">
            <summary>
            Forward to WriteFullEndElement().
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XmlRawWriterWrapper.WriteNamespaceDeclaration(System.String,System.String)">
            <summary>
            Forward to WriteAttribute();
            </summary>
        </member>
        <member name="T:System.Xml.Xsl.Runtime.XmlSequenceWriter">
             <summary>
                                     External XmlWriter      Cached Sequence
             ===================================================================================================
             Multiple Trees          Merged into Entity      Multiple Trees
            
             Attributes              Error                   Floating
             at top-level                                    Attribute
            
             Namespace               Error                   Floating
             at top-level                                    Namespace
            
             Elements, Text, PI      Implicit Root           Floating
             Comments at top-level                           Nodes
            
             Root at top-level       Ignored                 Root
            
             Atomic Values           Whitespace-Separated    Atomic Values
             at top-level            Text Node
            
             Nodes By Reference      Copied                  Preserve Identity
             </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XmlSequenceWriter.StartTree(System.Xml.XPath.XPathNodeType,System.Xml.IXmlNamespaceResolver,System.Xml.XmlNameTable)">
            <summary>
            Start construction of a new Xml tree (document or fragment).
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XmlSequenceWriter.EndTree">
            <summary>
            End construction of a new Xml tree (document or fragment).
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XmlSequenceWriter.WriteItem(System.Xml.XPath.XPathItem)">
            <summary>
            Write a top-level item by reference.
            </summary>
        </member>
        <member name="T:System.Xml.Xsl.Runtime.XmlCachedSequenceWriter">
            <summary>
            An implementation of XmlSequenceWriter that builds a cached XPath/XQuery sequence.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XmlCachedSequenceWriter.#ctor">
            <summary>
            Constructor.
            </summary>
        </member>
        <member name="P:System.Xml.Xsl.Runtime.XmlCachedSequenceWriter.ResultSequence">
            <summary>
            Return the sequence after it has been fully constructed.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XmlCachedSequenceWriter.StartTree(System.Xml.XPath.XPathNodeType,System.Xml.IXmlNamespaceResolver,System.Xml.XmlNameTable)">
            <summary>
            Start construction of a new Xml tree (document or fragment).
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XmlCachedSequenceWriter.EndTree">
            <summary>
            End construction of a new Xml tree (document or fragment).
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XmlCachedSequenceWriter.WriteItem(System.Xml.XPath.XPathItem)">
            <summary>
            Write a top-level item by reference.
            </summary>
        </member>
        <member name="T:System.Xml.Xsl.Runtime.XmlMergeSequenceWriter">
            <summary>
            An implementation of XmlSequenceWriter that converts an instance of the XQuery data model into a series
            of calls to XmlRawWriter.  The algorithm to do this is designed to be compatible with the rules in the
            "XSLT 2.0 and XQuery 1.0 Serialization" spec.  Here are the rules we use:
              1. An exception is thrown if the top-level sequence contains attribute or namespace nodes
              2. Each atomic value in the top-level sequence is converted to text, and XmlWriter.WriteString is called
              3. A call to XmlRawWriter.WriteWhitespace(" ") is made between adjacent atomic values at the top-level
              4. All items in the top-level sequence are merged together into a single result document.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XmlMergeSequenceWriter.#ctor(System.Xml.XmlRawWriter)">
            <summary>
            Constructor.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XmlMergeSequenceWriter.StartTree(System.Xml.XPath.XPathNodeType,System.Xml.IXmlNamespaceResolver,System.Xml.XmlNameTable)">
            <summary>
            Start construction of a new Xml tree (document or fragment).
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XmlMergeSequenceWriter.EndTree">
            <summary>
            End construction of a new Xml tree (document or fragment).
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XmlMergeSequenceWriter.WriteItem(System.Xml.XPath.XPathItem)">
            <summary>
            Write a top-level item by reference.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XmlMergeSequenceWriter.WriteString(System.String)">
            <summary>
            Write the string value of a top-level atomic value.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XmlMergeSequenceWriter.CopyNode(System.Xml.XPath.XPathNavigator)">
            <summary>
            Copy the navigator subtree to the raw writer.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XmlMergeSequenceWriter.CopyShallowNode(System.Xml.XPath.XPathNavigator)">
            <summary>
            Begin shallow copy of the specified node to the writer.  Returns true if the node might have content.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XmlMergeSequenceWriter.CopyNamespaces(System.Xml.XPath.XPathNavigator,System.Xml.XPath.XPathNamespaceScope)">
            <summary>
            Copy all or some (which depends on nsScope) of the namespaces on the navigator's current node to the
            raw writer.
            </summary>
        </member>
        <member name="T:System.Xml.Xsl.Runtime.XmlSortKey">
            <summary>
            Base internal class for all sort keys.
            Inherits from IComparable, so that Array.Sort can perform comparison.
            </summary>
        </member>
        <member name="P:System.Xml.Xsl.Runtime.XmlSortKey.Priority">
            <summary>
            Get or set this key's index, relative to other keys involved in a sort.  This priority will
            break ties.  If the priority is not set, then the sort will not be stable.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XmlSortKey.AddSortKey(System.Xml.Xsl.Runtime.XmlSortKey)">
            <summary>
            Sometimes a key is composed of multiple parts.  For example: (LastName, FirstName).  Multi-part
            keys are linked together in a list.  This method recursively adds a new key part to the end of the list.
            Returns the first (primary) key in the list.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XmlSortKey.BreakSortingTie(System.Xml.Xsl.Runtime.XmlSortKey)">
            <summary>
            When two keys are compared and found to be equal, the tie must be broken.  If there is a secondary key,
            then use that to break the tie.  Otherwise, use the input ordering to break the tie.  Since every key
            has a unique index, this is guaranteed to always break the tie.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XmlSortKey.CompareToEmpty(System.Object)">
            <summary>
            Compare a non-empty key (this) to an empty key (obj).  The empty sequence always sorts either before all
            other values, or after all other values.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XmlSortKey.CompareTo(System.Object)">
            <summary>
            Base internal class is abstract and doesn't actually implement CompareTo; derived classes must do this.
            </summary>
        </member>
        <member name="T:System.Xml.Xsl.Runtime.XmlEmptySortKey">
            <summary>
            Sort key for the empty sequence.  Empty sequence always compares sorts either before all other values,
            or after all other values.
            </summary>
        </member>
        <member name="T:System.Xml.Xsl.Runtime.XmlDecimalSortKey">
            <summary>
            Sort key for xs:decimal values.
            </summary>
        </member>
        <member name="T:System.Xml.Xsl.Runtime.XmlIntegerSortKey">
            <summary>
            Sort key for xs:integer values.
            </summary>
        </member>
        <member name="T:System.Xml.Xsl.Runtime.XmlIntSortKey">
            <summary>
            Sort key for xs:int values.
            </summary>
        </member>
        <member name="T:System.Xml.Xsl.Runtime.XmlStringSortKey">
            <summary>
            Sort key for xs:string values.  Strings are sorted according to a byte-wise sort key calculated by caller.
            </summary>
        </member>
        <member name="T:System.Xml.Xsl.Runtime.XmlDoubleSortKey">
            <summary>
            Sort key for Double values.
            </summary>
        </member>
        <member name="T:System.Xml.Xsl.Runtime.XmlDateTimeSortKey">
            <summary>
            Sort key for DateTime values (just convert DateTime to ticks and use Long sort key).
            </summary>
        </member>
        <member name="T:System.Xml.Xsl.Runtime.XmlSortKeyAccumulator">
            <summary>
            Accumulates a list of sort keys and stores them in an array.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XmlSortKeyAccumulator.Create">
            <summary>
            Initialize the XmlSortKeyAccumulator.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XmlSortKeyAccumulator.AddStringSortKey(System.Xml.Xsl.Runtime.XmlCollation,System.String)">
            <summary>
            Create a new sort key and append it to the current run of sort keys.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XmlSortKeyAccumulator.FinishSortKeys">
            <summary>
            Finish creating the current run of sort keys and begin a new run.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XmlSortKeyAccumulator.AppendSortKey(System.Xml.Xsl.Runtime.XmlSortKey)">
            <summary>
            Append new sort key to the current run of sort keys.
            </summary>
        </member>
        <member name="P:System.Xml.Xsl.Runtime.XmlSortKeyAccumulator.Keys">
            <summary>
            Get array of sort keys that was constructed by this internal class.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.NumberFormatter.FormatSequence(System.Collections.Generic.IList{System.Xml.XPath.XPathItem})">
            <summary>
            Format the given xsl:number place marker
            </summary>
            <param name="val">Place marker - either a sequence of ints, or a double singleton</param>
            <returns>Formatted string</returns>
        </member>
        <member name="T:System.Xml.Xsl.Runtime.XsltConvert">
            <summary>
            Contains conversion routines used by Xslt.  These conversions fall into several categories:
              1. Internal type to internal type: These are conversions from one of the five Xslt types to another
                 of the five types.
              2. External type to internal type: These are conversions from any of the Xsd types to one of the five
                 Xslt types.
              3. Internal type to external type: These are conversions from one of the five Xslt types to any of
                 of the Xsd types.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.Runtime.XsltConvert.InferXsltType(System.Type)">
            <summary>
            Infer one of the Xslt types from "clrType" -- Boolean, Double, String, Node, Node*, Item*.
            </summary>
        </member>
        <member name="F:System.Xml.Xsl.SourceLineInfo.NoSourceMagicNumber">
            <summary>
            Magic number 0xfeefee is used in PDB to denote a section of IL that does not map to any user code.
            When VS debugger steps into IL marked with 0xfeefee, it will continue the step until it reaches
            some user code.
            </summary>
        </member>
        <member name="T:System.Xml.Xsl.XmlNodeKindFlags">
            <summary>
            the xml node kind of a QIL expression
            </summary>
        </member>
        <member name="F:System.Xml.Xsl.XmlNodeKindFlags.None">
            <summary>
            no node kind
            </summary>
        </member>
        <member name="F:System.Xml.Xsl.XmlNodeKindFlags.Document">
            <summary>
            document node kind
            </summary>
        </member>
        <member name="F:System.Xml.Xsl.XmlNodeKindFlags.Element">
            <summary>
            element node kind
            </summary>
        </member>
        <member name="F:System.Xml.Xsl.XmlNodeKindFlags.Attribute">
            <summary>
            attribute node
            </summary>
        </member>
        <member name="F:System.Xml.Xsl.XmlNodeKindFlags.Text">
            <summary>
            text node
            </summary>
        </member>
        <member name="F:System.Xml.Xsl.XmlNodeKindFlags.Comment">
            <summary>
            comment node
            </summary>
        </member>
        <member name="F:System.Xml.Xsl.XmlNodeKindFlags.PI">
            <summary>
            processing-instruction node
            </summary>
        </member>
        <member name="F:System.Xml.Xsl.XmlNodeKindFlags.Namespace">
            <summary>
            namespace node
            </summary>
        </member>
        <member name="F:System.Xml.Xsl.XmlNodeKindFlags.Content">
            <summary>
            shortcut for any node that may appear in element content
            </summary>
        </member>
        <member name="F:System.Xml.Xsl.XmlNodeKindFlags.Any">
            <summary>
            shortcut for any node kind
            </summary>
        </member>
        <member name="T:System.Xml.Xsl.XmlQualifiedNameTest">
            <summary>
            XmlQualifiedName extends XmlQualifiedName to support wildcards and adds nametest functionality
            Following are the examples:
                {A}:B     XmlQualifiedNameTest.New("B", "A")        Match QName with namespace A        and local name B
                *         XmlQualifiedNameTest.New(null, null)      Match any QName
                {A}:*     XmlQualifiedNameTest.New(null, "A")       Match QName with namespace A        and any local name
                          XmlQualifiedNameTest.New("A", false)
                *:B       XmlQualifiedNameTest.New("B", null)       Match QName with any namespace      and local name B
                ~{A}:*    XmlQualifiedNameTest.New("B", "A")        Match QName with namespace not A    and any local name
                {~A}:B    only as a result of the intersection      Match QName with namespace not A    and local name B
            </summary>
        </member>
        <member name="P:System.Xml.Xsl.XmlQualifiedNameTest.Wildcard">
            <summary>
            Full wildcard
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.XmlQualifiedNameTest.#ctor(System.String,System.String,System.Boolean)">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.XmlQualifiedNameTest.New(System.String,System.String)">
            <summary>
            Construct new from name and namespace. Returns singleton Wildcard in case full wildcard
            </summary>
        </member>
        <member name="P:System.Xml.Xsl.XmlQualifiedNameTest.IsWildcard">
            <summary>
            True if matches any name and any namespace
            </summary>
        </member>
        <member name="P:System.Xml.Xsl.XmlQualifiedNameTest.IsNameWildcard">
            <summary>
            True if matches any name
            </summary>
        </member>
        <member name="P:System.Xml.Xsl.XmlQualifiedNameTest.IsNamespaceWildcard">
            <summary>
            True if matches any namespace
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.XmlQualifiedNameTest.IsSubsetOf(System.Xml.Xsl.XmlQualifiedNameTest)">
            <summary>
            True if this matches every QName other does
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.XmlQualifiedNameTest.HasIntersection(System.Xml.Xsl.XmlQualifiedNameTest)">
            <summary>
            Return true if the result of intersection with other is not empty
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.XmlQualifiedNameTest.ToString">
            <summary>
            String representation
            </summary>
        </member>
        <member name="T:System.Xml.Xsl.XmlQueryCardinality">
            <summary>
            Cardinality of part of XmlQueryType
            struct is being used because enum doesn't allow members
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.XmlQueryCardinality.#ctor(System.Int32)">
            <summary>
            Private constructor
            </summary>
        </member>
        <member name="P:System.Xml.Xsl.XmlQueryCardinality.None">
            <summary>
            exactly zero (empty)
            </summary>
        </member>
        <member name="P:System.Xml.Xsl.XmlQueryCardinality.Zero">
            <summary>
            exactly zero (empty)
            </summary>
        </member>
        <member name="P:System.Xml.Xsl.XmlQueryCardinality.One">
            <summary>
            exactly one
            </summary>
        </member>
        <member name="P:System.Xml.Xsl.XmlQueryCardinality.ZeroOrOne">
            <summary>
            zero or one (not more)
            </summary>
        </member>
        <member name="P:System.Xml.Xsl.XmlQueryCardinality.More">
            <summary>
            strictly more than one
            </summary>
        </member>
        <member name="P:System.Xml.Xsl.XmlQueryCardinality.NotOne">
            <summary>
            not one (strictly zero or strictly more)
            </summary>
        </member>
        <member name="P:System.Xml.Xsl.XmlQueryCardinality.OneOrMore">
            <summary>
            one or more (not empty)
            </summary>
        </member>
        <member name="P:System.Xml.Xsl.XmlQueryCardinality.ZeroOrMore">
            <summary>
            zero or more (any cardinality)
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.XmlQueryCardinality.Equals(System.Xml.Xsl.XmlQueryCardinality)">
            <summary>
            Strongly-typed Equals that returns true if this type and "other" type are equivalent.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.XmlQueryCardinality.op_Equality(System.Xml.Xsl.XmlQueryCardinality,System.Xml.Xsl.XmlQueryCardinality)">
            <summary>
            Overload == operator to call Equals rather than do reference equality.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.XmlQueryCardinality.op_Inequality(System.Xml.Xsl.XmlQueryCardinality,System.Xml.Xsl.XmlQueryCardinality)">
            <summary>
            Overload != operator to call Equals rather than do reference inequality.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.XmlQueryCardinality.Equals(System.Object)">
            <summary>
            True if "other" is an XmlQueryCardinality, and this type is the exact same static type.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.XmlQueryCardinality.GetHashCode">
            <summary>
            Return hash code of this instance.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.XmlQueryCardinality.op_BitwiseOr(System.Xml.Xsl.XmlQueryCardinality,System.Xml.Xsl.XmlQueryCardinality)">
            <summary>
            Return union with other
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.XmlQueryCardinality.op_Multiply(System.Xml.Xsl.XmlQueryCardinality,System.Xml.Xsl.XmlQueryCardinality)">
            <summary>
            Return this product other
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.XmlQueryCardinality.op_Addition(System.Xml.Xsl.XmlQueryCardinality,System.Xml.Xsl.XmlQueryCardinality)">
            <summary>
            Return sum with other
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.XmlQueryCardinality.op_LessThanOrEqual(System.Xml.Xsl.XmlQueryCardinality,System.Xml.Xsl.XmlQueryCardinality)">
            <summary>
            Returns true is left is subset of right.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.XmlQueryCardinality.op_GreaterThanOrEqual(System.Xml.Xsl.XmlQueryCardinality,System.Xml.Xsl.XmlQueryCardinality)">
            <summary>
            Returns true is right is subset of left.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.XmlQueryCardinality.AtMost">
            <summary>
            Compute the cardinality of a subset of a set of the given cardinality.
            </summary>
            <returns>the cardinality of a subset</returns>
        </member>
        <member name="M:System.Xml.Xsl.XmlQueryCardinality.NeverSubset(System.Xml.Xsl.XmlQueryCardinality)">
            <summary>
            Returns true if every non-None subset of this cardinality is disjoint with "other" cardinality.
            Here is the behavior for None, which is the inverse of the None behavior for IsSubset:
              None op  None = false
              None op ~None = false
             ~None op  None = true
            </summary>
        </member>
        <member name="F:System.Xml.Xsl.XmlQueryCardinality.s_cardinalityProduct">
            <summary>
            Table of cardinality products.
            </summary>
        </member>
        <member name="F:System.Xml.Xsl.XmlQueryCardinality.s_cardinalitySum">
            <summary>
            Table of cardinality sums.
            </summary>
        </member>
        <member name="F:System.Xml.Xsl.XmlQueryCardinality.s_toString">
            <summary>
            String representation.
            </summary>
        </member>
        <member name="F:System.Xml.Xsl.XmlQueryCardinality.s_serialized">
            <summary>
            Serialization
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.XmlQueryCardinality.ToString(System.String)">
            <summary>
            Return the string representation of a cardinality, normalized to either ?, +, *, or "" (card 1).
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.XmlQueryCardinality.ToString">
            <summary>
            Return the string representation of a cardinality, normalized to either ?, +, *, or "" (card 1).
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.XmlQueryCardinality.GetObjectData(System.IO.BinaryWriter)">
            <summary>
            Serialize the object to BinaryWriter.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.XmlQueryCardinality.#ctor(System.IO.BinaryReader)">
            <summary>
            Deserialize the object from BinaryReader.
            </summary>
        </member>
        <member name="T:System.Xml.Xsl.XmlQueryType">
             <summary>
             XmlQueryType contains static type information that describes the structure and possible values of dynamic
             instances of the Xml data model.
            
             Every XmlQueryType is composed of a Prime type and a cardinality.  The Prime type itself may be a union
             between several item types.  The XmlQueryType IList<XmlQueryType/> implementation allows callers
             to enumerate the item types.  Other properties expose other information about the type.
             </summary>
        </member>
        <member name="P:System.Xml.Xsl.XmlQueryType.TypeCode">
            <summary>
            Static data type code.  The dynamic type is guaranteed to be this type or a subtype of this code.
            This type code includes support for XQuery types that are not part of Xsd, such as Item,
            Node, AnyAtomicType, and Comment.
            </summary>
        </member>
        <member name="P:System.Xml.Xsl.XmlQueryType.NameTest">
            <summary>
            Set of allowed names for element, document{element}, attribute and PI
            Returns XmlQualifiedName.Wildcard for all other types
            </summary>
        </member>
        <member name="P:System.Xml.Xsl.XmlQueryType.SchemaType">
            <summary>
            Static Xsd schema type.  The dynamic type is guaranteed to be this type or a subtype of this type.
            SchemaType will follow these rules:
              1. If TypeCode is an atomic type code, then SchemaType will be the corresponding non-null simple type
              2. If TypeCode is Element or Attribute, then SchemaType will be the non-null content type
              3. If TypeCode is Item, Node, Comment, PI, Text, Document, Namespace, None, then SchemaType will be AnyType
            </summary>
        </member>
        <member name="P:System.Xml.Xsl.XmlQueryType.IsNillable">
            <summary>
            Permits the element or document{element} node to have the nilled property.
            Returns false for all other types
            </summary>
        </member>
        <member name="P:System.Xml.Xsl.XmlQueryType.NodeKinds">
            <summary>
            This property is always XmlNodeKindFlags.None unless TypeCode = XmlTypeCode.Node, in which case this
            property lists all node kinds that instances of this type may be.
            </summary>
        </member>
        <member name="P:System.Xml.Xsl.XmlQueryType.IsStrict">
            <summary>
            If IsStrict is true, then the dynamic type is guaranteed to be the exact same as the static type, and
            will therefore never be a subtype of the static type.
            </summary>
        </member>
        <member name="P:System.Xml.Xsl.XmlQueryType.Cardinality">
            <summary>
            This property specifies the possible cardinalities that instances of this type may have.
            </summary>
        </member>
        <member name="P:System.Xml.Xsl.XmlQueryType.Prime">
            <summary>
            This property returns this type's Prime type, which is always cardinality One.
            </summary>
        </member>
        <member name="P:System.Xml.Xsl.XmlQueryType.IsNotRtf">
            <summary>
            True if dynamic data type of all items in this sequence is guaranteed to be not a subtype of Rtf.
            </summary>
        </member>
        <member name="P:System.Xml.Xsl.XmlQueryType.IsDod">
            <summary>
            True if items in the sequence are guaranteed to be nodes in document order with no duplicates.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.XmlQueryType.IsSubtypeOf(System.Xml.Xsl.XmlQueryType)">
            <summary>
            Returns true if every possible dynamic instance of this type is also an instance of "baseType".
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.XmlQueryType.NeverSubtypeOf(System.Xml.Xsl.XmlQueryType)">
            <summary>
            Returns true if a dynamic instance (type None never has an instance) of this type can never be a subtype of "baseType".
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.XmlQueryType.Equals(System.Xml.Xsl.XmlQueryType)">
            <summary>
            Strongly-typed Equals that returns true if this type and "that" type are equivalent.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.XmlQueryType.op_Equality(System.Xml.Xsl.XmlQueryType,System.Xml.Xsl.XmlQueryType)">
            <summary>
            Overload == operator to call Equals rather than do reference equality.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.XmlQueryType.op_Inequality(System.Xml.Xsl.XmlQueryType,System.Xml.Xsl.XmlQueryType)">
            <summary>
            Overload != operator to call Equals rather than do reference inequality.
            </summary>
        </member>
        <member name="P:System.Xml.Xsl.XmlQueryType.IsEmpty">
            <summary>
            True if dynamic cardinality of this sequence is guaranteed to be 0.
            </summary>
        </member>
        <member name="P:System.Xml.Xsl.XmlQueryType.IsSingleton">
            <summary>
            True if dynamic cardinality of this sequence is guaranteed to be 1.
            </summary>
        </member>
        <member name="P:System.Xml.Xsl.XmlQueryType.MaybeEmpty">
            <summary>
            True if dynamic cardinality of this sequence might be 0.
            </summary>
        </member>
        <member name="P:System.Xml.Xsl.XmlQueryType.MaybeMany">
            <summary>
            True if dynamic cardinality of this sequence might be >1.
            </summary>
        </member>
        <member name="P:System.Xml.Xsl.XmlQueryType.IsNode">
            <summary>
            True if dynamic data type of all items in this sequence is guaranteed to be a subtype of Node.
            Equivalent to calling IsSubtypeOf(TypeFactory.NodeS).
            </summary>
        </member>
        <member name="P:System.Xml.Xsl.XmlQueryType.IsAtomicValue">
            <summary>
            True if dynamic data type of all items in this sequence is guaranteed to be a subtype of AnyAtomicType.
            Equivalent to calling IsSubtypeOf(TypeFactory.AnyAtomicTypeS).
            </summary>
        </member>
        <member name="P:System.Xml.Xsl.XmlQueryType.IsNumeric">
            <summary>
            True if dynamic data type of all items in this sequence is guaranteed to be a subtype of Decimal, Double, or Float.
            Equivalent to calling IsSubtypeOf(TypeFactory.NumericS).
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.XmlQueryType.Equals(System.Object)">
            <summary>
            True if "obj" is an XmlQueryType, and this type is the exact same static type.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.XmlQueryType.GetHashCode">
            <summary>
            Return hash code of this instance.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.XmlQueryType.ToString">
            <summary>
            Return a user-friendly string representation of the XmlQueryType.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.XmlQueryType.ToString(System.String)">
             <summary>
             Return a string representation of the XmlQueryType using the specified format.  The following formats are
             supported:
            
               "G" (General): This is the default mode, and is used if no other format is recognized.  This format is
                              easier to read than the canonical format, since it excludes redundant information.
                              (e.g. element instead of element(*, xs:anyType))
            
               "X" (XQuery): Return the canonical XQuery representation, which excludes Qil specific information and
                             includes extra, redundant information, such as fully specified types.
                             (e.g. element(*, xs:anyType) instead of element)
            
               "S" (Serialized): This format is used to serialize parts of the type which can be serialized easily, in
                                 a format that is easy to parse.  Only the cardinality, type code, and strictness flag
                                 are serialized.  User-defined type information and element/attribute content types
                                 are lost.
                                 (e.g. One;Attribute|String|Int;true)
            
             </summary>
        </member>
        <member name="M:System.Xml.Xsl.XmlQueryType.GetObjectData(System.IO.BinaryWriter)">
            <summary>
            Serialize the object to BinaryWriter.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.XmlQueryType.IsSubtypeOfItemType(System.Xml.Xsl.XmlQueryType)">
            <summary>
            Returns true if this item type is a subtype of another item type.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.XmlQueryType.HasIntersectionItemType(System.Xml.Xsl.XmlQueryType)">
            <summary>
            Returns true if the intersection between this item type and "other" item type is not empty.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.XmlQueryType.ItemTypeToString(System.Boolean)">
            <summary>
            Return the string representation of an item type (cannot be a union or a sequence).
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.XmlQueryType.NameAndType(System.Boolean)">
            <summary>
            Return "(name-test, type-name)" for this type.  If isXQ is false, normalize xs:anySimpleType and
            xs:anyType to "*".
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.XmlQueryType.QNameToString(System.Xml.XmlQualifiedName)">
            <summary>
            Convert an XmlQualifiedName to a string, using somewhat different rules than XmlQualifiedName.ToString():
              1. Empty QNames are assumed to be wildcard names, so return "*"
              2. Recognize the built-in xs: and xdt: namespaces and print the short prefix rather than the long namespace
              3. Use brace characters "{", "}" around the namespace portion of the QName
            </summary>
        </member>
        <member name="T:System.Xml.Xsl.XmlQueryType.BitMatrix">
            <summary>
            Implements an NxN bit matrix.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.XmlQueryType.BitMatrix.#ctor(System.Int32)">
            <summary>
            Create NxN bit matrix, where N = count.
            </summary>
        </member>
        <member name="P:System.Xml.Xsl.XmlQueryType.BitMatrix.Item(System.Int32,System.Int32)">
            <summary>
            Get or set a bit in the matrix at position (index1, index2).
            </summary>
        </member>
        <member name="P:System.Xml.Xsl.XmlQueryType.BitMatrix.Item(System.Xml.Schema.XmlTypeCode,System.Xml.Schema.XmlTypeCode)">
            <summary>
            Strongly typed indexer.
            </summary>
        </member>
        <member name="T:System.Xml.Xsl.XmlQueryTypeFactory">
            <summary>
            This class is the only way to create concrete instances of the abstract XmlQueryType class.
            Once basic types have been created, they can be combined and transformed in various ways.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.XmlQueryTypeFactory.Type(System.Xml.Schema.XmlTypeCode,System.Boolean)">
            <summary>
            Create an XmlQueryType from an XmlTypeCode.
            </summary>
            <param name="code">the type code of the item</param>
            <param name="isStrict">true if the dynamic type is guaranteed to match the static type exactly</param>
            <returns>the atomic value type</returns>
        </member>
        <member name="M:System.Xml.Xsl.XmlQueryTypeFactory.Type(System.Xml.Schema.XmlSchemaSimpleType,System.Boolean)">
            <summary>
            Create an XmlQueryType from an Xsd simple type (where variety can be Atomic, List, or Union).
            </summary>
            <param name="schemaType">the simple Xsd schema type of the atomic value</param>
            <param name="isStrict">true if the dynamic type is guaranteed to match the static type exactly</param>
            <returns>the atomic value type</returns>
        </member>
        <member name="M:System.Xml.Xsl.XmlQueryTypeFactory.Choice(System.Xml.Xsl.XmlQueryType,System.Xml.Xsl.XmlQueryType)">
            <summary>
            Construct the union of two XmlQueryTypes
            </summary>
            <param name="left">the left type</param>
            <param name="right">the right type</param>
            <returns>the union type</returns>
        </member>
        <member name="M:System.Xml.Xsl.XmlQueryTypeFactory.Choice(System.Xml.Xsl.XmlQueryType[])">
            <summary>
            Construct the union of several XmlQueryTypes
            </summary>
            <param name="types">the list of types</param>
            <returns>the union type</returns>
        </member>
        <member name="M:System.Xml.Xsl.XmlQueryTypeFactory.NodeChoice(System.Xml.Xsl.XmlNodeKindFlags)">
            <summary>
            Create a Node XmlQueryType which is the choice between several different node kinds.
            </summary>
            <param name="kinds">the node kinds which will make up the choice</param>
            <returns>the node type</returns>
        </member>
        <member name="M:System.Xml.Xsl.XmlQueryTypeFactory.Sequence(System.Xml.Xsl.XmlQueryType,System.Xml.Xsl.XmlQueryType)">
            <summary>
            Construct the sequence of two XmlQueryTypes
            </summary>
            <param name="left">the left type</param>
            <param name="right">the right type</param>
            <returns>the sequence type</returns>
        </member>
        <member name="M:System.Xml.Xsl.XmlQueryTypeFactory.PrimeProduct(System.Xml.Xsl.XmlQueryType,System.Xml.Xsl.XmlQueryCardinality)">
            <summary>
            Compute the product of the prime of "t" with cardinality "c".
            </summary>
            <param name="t">the member type</param>
            <param name="c">the cardinality</param>
            <returns>the prime type with the indicated cardinality applied</returns>
        </member>
        <member name="M:System.Xml.Xsl.XmlQueryTypeFactory.AtMost(System.Xml.Xsl.XmlQueryType,System.Xml.Xsl.XmlQueryCardinality)">
            <summary>
            Compute a sequence of zero to some max cardinality.
            </summary>
            <param name="t">the type to sequence</param>
            <param name="c">the upper bound</param>
            <returns>the sequence of t from 0 to c</returns>
        </member>
        <member name="M:System.Xml.Xsl.XmlQueryTypeFactory.PrimeChoice(System.Collections.Generic.List{System.Xml.Xsl.XmlQueryType},System.Collections.Generic.IList{System.Xml.Xsl.XmlQueryType})">
            <summary>
            Construct the union of two lists of prime XmlQueryTypes.  Types are added to "accumulator" as necessary to ensure
            it contains a superset of "types".
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.XmlQueryTypeFactory.AddItemToChoice(System.Collections.Generic.List{System.Xml.Xsl.XmlQueryType},System.Xml.Xsl.XmlQueryType)">
            <summary>
            Adds itemType to a union. Returns false if new item is a subtype of one of the types in the list.
            </summary>
        </member>
        <member name="F:System.Xml.Xsl.XmlQueryTypeFactory.s_nodeKindToTypeCode">
            <summary>
            Map XPathNodeType to XmlTypeCode.
            </summary>
        </member>
        <member name="T:System.Xml.Xsl.XmlQueryTypeFactory.ItemType">
            <summary>
            Implementation of XmlQueryType for singleton types.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.XmlQueryTypeFactory.ItemType.#cctor">
            <summary>
            Construct arrays of built-in types.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.XmlQueryTypeFactory.ItemType.Create(System.Xml.Schema.XmlTypeCode,System.Boolean)">
            <summary>
            Create ItemType from XmlTypeCode.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.XmlQueryTypeFactory.ItemType.Create(System.Xml.Schema.XmlSchemaSimpleType,System.Boolean)">
            <summary>
            Create ItemType from Xsd atomic type.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.XmlQueryTypeFactory.ItemType.Create(System.Xml.Schema.XmlTypeCode,System.Xml.Xsl.XmlQualifiedNameTest,System.Xml.Schema.XmlSchemaType,System.Boolean)">
            <summary>
            Create Document, Element or Attribute with specified name test, content type and nillable.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.XmlQueryTypeFactory.ItemType.#ctor(System.Xml.Schema.XmlTypeCode,System.Xml.Xsl.XmlQualifiedNameTest,System.Xml.Schema.XmlSchemaType,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Private constructor.  Create methods should be used to create instances.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.XmlQueryTypeFactory.ItemType.GetObjectData(System.IO.BinaryWriter)">
            <summary>
            Serialize the object to BinaryWriter.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.XmlQueryTypeFactory.ItemType.Create(System.IO.BinaryReader)">
            <summary>
            Deserialize the object from BinaryReader.
            </summary>
        </member>
        <member name="P:System.Xml.Xsl.XmlQueryTypeFactory.ItemType.TypeCode">
            <summary>
            Return the TypeCode.
            </summary>
        </member>
        <member name="P:System.Xml.Xsl.XmlQueryTypeFactory.ItemType.NameTest">
            <summary>
            Return the NameTest.
            </summary>
        </member>
        <member name="P:System.Xml.Xsl.XmlQueryTypeFactory.ItemType.SchemaType">
            <summary>
            Return the Xsd schema type.  This must be non-null for atomic value types.
            </summary>
        </member>
        <member name="P:System.Xml.Xsl.XmlQueryTypeFactory.ItemType.IsNillable">
            <summary>
            Return the IsNillable.
            </summary>
        </member>
        <member name="P:System.Xml.Xsl.XmlQueryTypeFactory.ItemType.NodeKinds">
            <summary>
            Since this is always an atomic value type, NodeKinds = None.
            </summary>
        </member>
        <member name="P:System.Xml.Xsl.XmlQueryTypeFactory.ItemType.IsStrict">
            <summary>
            Return flag indicating whether the dynamic type is guaranteed to be the same as the static type.
            </summary>
        </member>
        <member name="P:System.Xml.Xsl.XmlQueryTypeFactory.ItemType.IsNotRtf">
            <summary>
            Return flag indicating whether this is not an Rtf.
            </summary>
        </member>
        <member name="P:System.Xml.Xsl.XmlQueryTypeFactory.ItemType.IsDod">
            <summary>
            Singleton types return false.
            </summary>
        </member>
        <member name="P:System.Xml.Xsl.XmlQueryTypeFactory.ItemType.Cardinality">
            <summary>
            Always return cardinality One.
            </summary>
        </member>
        <member name="P:System.Xml.Xsl.XmlQueryTypeFactory.ItemType.Prime">
            <summary>
            Prime of atomic value type is itself.
            </summary>
        </member>
        <member name="P:System.Xml.Xsl.XmlQueryTypeFactory.ItemType.Count">
            <summary>
            AtomicValueType is only a composition of itself, rather than other smaller types.
            </summary>
        </member>
        <member name="P:System.Xml.Xsl.XmlQueryTypeFactory.ItemType.Item(System.Int32)">
            <summary>
            AtomicValueType is only a composition of itself, rather than other smaller types.
            </summary>
        </member>
        <member name="T:System.Xml.Xsl.XmlQueryTypeFactory.ChoiceType">
            <summary>
            Implementation of XmlQueryType that composes a choice of various prime types.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.XmlQueryTypeFactory.ChoiceType.Create(System.Xml.Xsl.XmlNodeKindFlags)">
            <summary>
            Create choice between node kinds.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.XmlQueryTypeFactory.ChoiceType.Create(System.Collections.Generic.List{System.Xml.Xsl.XmlQueryType})">
            <summary>
            Create choice containing the specified list of types.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.XmlQueryTypeFactory.ChoiceType.#ctor(System.Collections.Generic.List{System.Xml.Xsl.XmlQueryType})">
            <summary>
            Private constructor.  Create methods should be used to create instances.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.XmlQueryTypeFactory.ChoiceType.GetObjectData(System.IO.BinaryWriter)">
            <summary>
            Serialize the object to BinaryWriter.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.XmlQueryTypeFactory.ChoiceType.Create(System.IO.BinaryReader)">
            <summary>
            Deserialize the object from BinaryReader.
            </summary>
        </member>
        <member name="P:System.Xml.Xsl.XmlQueryTypeFactory.ChoiceType.TypeCode">
            <summary>
            Return a type code which is a supertype of all member types.
            </summary>
        </member>
        <member name="P:System.Xml.Xsl.XmlQueryTypeFactory.ChoiceType.NameTest">
            <summary>
            Return the NameTest.
            </summary>
        </member>
        <member name="P:System.Xml.Xsl.XmlQueryTypeFactory.ChoiceType.SchemaType">
            <summary>
            Return an Xsd schema type which is a supertype of all member types.
            </summary>
        </member>
        <member name="P:System.Xml.Xsl.XmlQueryTypeFactory.ChoiceType.IsNillable">
            <summary>
            Return the IsNillable.
            </summary>
        </member>
        <member name="P:System.Xml.Xsl.XmlQueryTypeFactory.ChoiceType.NodeKinds">
            <summary>
            Return a set of NodeKinds which is the union of all member node kinds.
            </summary>
        </member>
        <member name="P:System.Xml.Xsl.XmlQueryTypeFactory.ChoiceType.IsStrict">
            <summary>
            Choice types are always non-strict, except for the empty choice.
            </summary>
        </member>
        <member name="P:System.Xml.Xsl.XmlQueryTypeFactory.ChoiceType.IsNotRtf">
            <summary>
            Return true if every type in the choice is not an Rtf.
            </summary>
        </member>
        <member name="P:System.Xml.Xsl.XmlQueryTypeFactory.ChoiceType.IsDod">
            <summary>
            Singleton types return false.
            </summary>
        </member>
        <member name="P:System.Xml.Xsl.XmlQueryTypeFactory.ChoiceType.Cardinality">
            <summary>
            Always return cardinality none or one.
            </summary>
        </member>
        <member name="P:System.Xml.Xsl.XmlQueryTypeFactory.ChoiceType.Prime">
            <summary>
            Prime of union type is itself.
            </summary>
        </member>
        <member name="P:System.Xml.Xsl.XmlQueryTypeFactory.ChoiceType.Count">
            <summary>
            Return the number of union member types.
            </summary>
        </member>
        <member name="P:System.Xml.Xsl.XmlQueryTypeFactory.ChoiceType.Item(System.Int32)">
            <summary>
            Return a union member type by index.
            </summary>
        </member>
        <member name="T:System.Xml.Xsl.XmlQueryTypeFactory.SequenceType">
            <summary>
            Implementation of XmlQueryType that modifies the cardinality of a composed type.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.XmlQueryTypeFactory.SequenceType.Create(System.Xml.Xsl.XmlQueryType,System.Xml.Xsl.XmlQueryCardinality)">
            <summary>
            Create sequence type from prime and cardinality.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.XmlQueryTypeFactory.SequenceType.#ctor(System.Xml.Xsl.XmlQueryType,System.Xml.Xsl.XmlQueryCardinality)">
            <summary>
            Private constructor.  Create methods should be used to create instances.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.XmlQueryTypeFactory.SequenceType.GetObjectData(System.IO.BinaryWriter)">
            <summary>
            Serialize the object to BinaryWriter.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.XmlQueryTypeFactory.SequenceType.Create(System.IO.BinaryReader)">
            <summary>
            Deserialize the object from BinaryReader.
            </summary>
        </member>
        <member name="P:System.Xml.Xsl.XmlQueryTypeFactory.SequenceType.TypeCode">
            <summary>
            Return the TypeCode of the prime type.
            </summary>
        </member>
        <member name="P:System.Xml.Xsl.XmlQueryTypeFactory.SequenceType.NameTest">
            <summary>
            Return the NameTest of the prime type
            </summary>
        </member>
        <member name="P:System.Xml.Xsl.XmlQueryTypeFactory.SequenceType.SchemaType">
            <summary>
            Return the Xsd schema type of the prime type.
            </summary>
        </member>
        <member name="P:System.Xml.Xsl.XmlQueryTypeFactory.SequenceType.IsNillable">
            <summary>
            Return the IsNillable of the prime type
            </summary>
        </member>
        <member name="P:System.Xml.Xsl.XmlQueryTypeFactory.SequenceType.NodeKinds">
            <summary>
            Return the NodeKinds of the prime type.
            </summary>
        </member>
        <member name="P:System.Xml.Xsl.XmlQueryTypeFactory.SequenceType.IsStrict">
            <summary>
            Return the IsStrict flag of the prime type.
            </summary>
        </member>
        <member name="P:System.Xml.Xsl.XmlQueryTypeFactory.SequenceType.IsNotRtf">
            <summary>
            Return the IsNotRtf flag of the prime type.
            </summary>
        </member>
        <member name="P:System.Xml.Xsl.XmlQueryTypeFactory.SequenceType.IsDod">
            <summary>
            Only NodeSDod type returns true.
            </summary>
        </member>
        <member name="P:System.Xml.Xsl.XmlQueryTypeFactory.SequenceType.Cardinality">
            <summary>
            Return the modified cardinality.
            </summary>
        </member>
        <member name="P:System.Xml.Xsl.XmlQueryTypeFactory.SequenceType.Prime">
            <summary>
            Return prime of sequence type.
            </summary>
        </member>
        <member name="P:System.Xml.Xsl.XmlQueryTypeFactory.SequenceType.Count">
            <summary>
            Return the Count of the prime type.
            </summary>
        </member>
        <member name="P:System.Xml.Xsl.XmlQueryTypeFactory.SequenceType.Item(System.Int32)">
            <summary>
            Return the parts of the prime type.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.XmlQueryTypeFactory.Type(System.Xml.XPath.XPathNodeType,System.Xml.Xsl.XmlQualifiedNameTest,System.Xml.Schema.XmlSchemaType,System.Boolean)">
            <summary>
            Create a Node XmlQueryType having an XSD content type.
            </summary>
            <param name="nameTest">The name test.</param>
            <param name="kind">unless kind is Root, Element, or Attribute, "contentType" is ignored</param>
            <param name="contentType">content type of the node</param>
            <param name="isNillable">Whether it's nillable.</param>
            <returns>the node type</returns>
        </member>
        <member name="M:System.Xml.Xsl.XmlQueryTypeFactory.CheckSerializability(System.Xml.Xsl.XmlQueryType)">
            <summary>
            Check if the given type can be serialized.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.XmlQueryTypeFactory.Serialize(System.IO.BinaryWriter,System.Xml.Xsl.XmlQueryType)">
            <summary>
            Serialize XmlQueryType to BinaryWriter.
            </summary>
        </member>
        <member name="M:System.Xml.Xsl.XmlQueryTypeFactory.Deserialize(System.IO.BinaryReader)">
            <summary>
            Deserialize XmlQueryType from BinaryReader.
            </summary>
        </member>
        <member name="T:System.Xml.Xsl.XPathConvert">
            Converts according to XPath/XSLT rules.
        </member>
        <member name="T:System.Xml.Xsl.XPathConvert.BigNumber">
             Implementation of a big floating point number used to ensure adequate
             precision when performing calculations.
            
             Hungarian: num
            
        </member>
        <member name="T:System.Xml.Xsl.XPathConvert.BigInteger">
             Implementation of very large variable-precision non-negative integers.
            
             Hungarian: bi
            
        </member>
        <member name="T:System.Xml.Xsl.XPathConvert.FloatingDecimal">
            Floating point number represented in base-10.
        </member>
        <member name="T:System.Xml.Xsl.Xslt.InvokeGenerator">
                InvokeGenerator is one of the trickiest peaces here.
                ARGS:
                     QilFunction func      -- Functions which should be invoked. Arguments of this function (formalArgs) are Let nodes
                                              annotated with names and default values.
                                              Problem 1 is that default values can contain references to previous args of this function.
                                              Problem 2 is that default values shouldn't contain fix-up nodes.
                     ArrayList actualArgs  -- Array of QilNodes annotated with names. When name of formalArg match name actualArg last one
                                              is used as invokeArg, otherwise formalArg's default value is cloned and used.
                *
        </member>
        <member name="M:System.Xml.Xsl.Xslt.QilGenerator.CompileOrderAttribute(System.String,System.String,System.String,System.String,System.Boolean)">
            <summary>
            Compiles AVT with two possible values
            </summary>
            <param name="attName"  >NodeCtor name (used for constructing an error message)</param>
            <param name="attValue" >NodeCtor value</param>
            <param name="value0"   >First possible value of attribute</param>
            <param name="value1"   >Second possible value of attribute</param>
            <param name="fwdCompat">If true, unrecognized value does not report an error</param>
            <returns>
            If AVT is null (i.e. the attribute is omitted), null is returned. Otherwise, QilExpression
            returning "1" if AVT evaluates to value1, or "0" if AVT evaluates to value0 or any other value.
            If AVT evaluates to neither value0 nor value1 and fwdCompat == false, an error is reported.
            </returns>
        </member>
        <member name="T:System.Xml.Xsl.Xslt.XslAstAnalyzer.Graph`1">
            <summary>
            Represents a graph using hashtable of adjacency lists.
            </summary>
            <typeparam name="V">Vertex type</typeparam>
        </member>
        <member name="M:System.Xml.Schema.ChameleonKey.#ctor(System.String,System.Xml.Schema.XmlSchema)">
            <summary>
            Creates a new chameleon key - an identification for a chameleon schema instance
            </summary>
            <param name="ns">The target namespace of the instance of the chameleon schema</param>
            <param name="originalSchema">The original (chameleon) schema (the one without the target namespace).
              This is used to get the location (base uri) and to identify the schema.</param>
        </member>
        <member name="T:System.Xml.Schema.UpaException">
            <summary>
            UPA violations will throw this exception
            </summary>
        </member>
        <member name="T:System.Xml.Schema.SymbolsDictionary">
            <summary>
            SymbolsDictionary is a map between names that ContextValidator recognizes and symbols - int symbol[XmlQualifiedName name].
            There are two types of name - full names and wildcards (namespace is specified, local name is anything).
            Wildcard excludes all full names that would match by the namespace part.
            SymbolsDictionary always recognizes all the symbols - the last one is a true wildcard -
                 both name and namespace can be anything that none of the other symbols matched.
            </summary>
        </member>
        <member name="P:System.Xml.Schema.SymbolsDictionary.IsUpaEnforced">
            <summary>
            True is particle can be deterministically attributed from the symbol and conversion to DFA is possible.
            </summary>
        </member>
        <member name="M:System.Xml.Schema.SymbolsDictionary.AddName(System.Xml.XmlQualifiedName,System.Object)">
            <summary>
            Add name  and return it's number
            </summary>
        </member>
        <member name="P:System.Xml.Schema.SymbolsDictionary.Item(System.Xml.XmlQualifiedName)">
            <summary>
            Find the symbol for the given name. If neither names nor wilcards match it last (*.*) symbol will be returned
            </summary>
        </member>
        <member name="M:System.Xml.Schema.SymbolsDictionary.Exists(System.Xml.XmlQualifiedName)">
            <summary>
            Check if a name exists in the symbol dictionary
            </summary>
        </member>
        <member name="M:System.Xml.Schema.SymbolsDictionary.GetParticle(System.Int32)">
            <summary>
            Return content processing mode for the symbol
            </summary>
        </member>
        <member name="M:System.Xml.Schema.SymbolsDictionary.NameOf(System.Int32)">
            <summary>
            Output symbol's name
            </summary>
        </member>
        <member name="T:System.Xml.Schema.SyntaxTreeNode">
            <summary>
            Base class for the systax tree nodes
            </summary>
        </member>
        <member name="M:System.Xml.Schema.SyntaxTreeNode.ExpandTree(System.Xml.Schema.InteriorNode,System.Xml.Schema.SymbolsDictionary,System.Xml.Schema.Positions)">
            <summary>
            Expand NamesapceListNode and RangeNode nodes. All other nodes
            </summary>
        </member>
        <member name="M:System.Xml.Schema.SyntaxTreeNode.ConstructPos(System.Xml.Schema.BitSet,System.Xml.Schema.BitSet,System.Xml.Schema.BitSet[])">
            <summary>
            From a regular expression to a DFA
            Compilers by Aho, Sethi, Ullman.
            ISBN 0-201-10088-6, p135
            Construct firstpos, lastpos and calculate followpos
            </summary>
        </member>
        <member name="P:System.Xml.Schema.SyntaxTreeNode.IsNullable">
            <summary>
            Returns nullable property that is being used by ConstructPos
            </summary>
        </member>
        <member name="P:System.Xml.Schema.SyntaxTreeNode.IsRangeNode">
            <summary>
            Returns true if node is a range node
            </summary>
        </member>
        <member name="M:System.Xml.Schema.SyntaxTreeNode.Dump(System.Text.StringBuilder,System.Xml.Schema.SymbolsDictionary,System.Xml.Schema.Positions)">
            <summary>
            Print syntax tree
            </summary>
        </member>
        <member name="T:System.Xml.Schema.LeafNode">
            <summary>
            Terminal of the syntax tree
            </summary>
        </member>
        <member name="T:System.Xml.Schema.NamespaceListNode">
            <summary>
            Temporary node to represent NamespaceList. Will be expended as a choice of symbols
            </summary>
        </member>
        <member name="T:System.Xml.Schema.InteriorNode">
            <summary>
            Base class for all internal node. Note that only sequence and choice have right child
            </summary>
        </member>
        <member name="T:System.Xml.Schema.LeafRangeNode">
            <summary>
            Using range node as one of the terminals
            </summary>
        </member>
        <member name="T:System.Xml.Schema.ContentValidator">
            <summary>
            Basic ContentValidator
            </summary>
        </member>
        <member name="M:System.Xml.Schema.ParticleContentValidator.BuildTransitionTable(System.Xml.Schema.BitSet,System.Xml.Schema.BitSet[],System.Int32)">
            <summary>
            Algorithm 3.5 Construction of a DFA from a regular expression
            </summary>
        </member>
        <member name="T:System.Xml.Schema.DfaContentValidator">
            <summary>
            Deterministic Finite Automata
            Compilers by Aho, Sethi, Ullman.
            ISBN 0-201-10088-6, pp. 115, 116, 140
            </summary>
        </member>
        <member name="M:System.Xml.Schema.DfaContentValidator.#ctor(System.Int32[][],System.Xml.Schema.SymbolsDictionary,System.Xml.Schema.XmlSchemaContentType,System.Boolean,System.Boolean)">
            <summary>
            Algorithm 3.5 Construction of a DFA from a regular expression
            </summary>
        </member>
        <member name="M:System.Xml.Schema.DfaContentValidator.ValidateElement(System.Xml.XmlQualifiedName,System.Xml.Schema.ValidationState,System.Int32@)">
            <summary>
            Algorithm 3.1 Simulating a DFA
            </summary>
        </member>
        <member name="T:System.Xml.Schema.NfaContentValidator">
            <summary>
            Nondeterministic Finite Automata
            Compilers by Aho, Sethi, Ullman.
            ISBN 0-201-10088-6, pp. 126,140
            </summary>
        </member>
        <member name="M:System.Xml.Schema.NfaContentValidator.ValidateElement(System.Xml.XmlQualifiedName,System.Xml.Schema.ValidationState,System.Int32@)">
            <summary>
            Algorithm 3.4 Simulation of an NFA
            </summary>
        </member>
        <member name="M:System.Xml.Schema.DatatypeImplementation.StartBuiltinType(System.Xml.XmlQualifiedName,System.Xml.Schema.XmlSchemaDatatype)">
            <summary>
            Begin the creation of an XmlSchemaSimpleType object that will be used to represent a static built-in type.
            Once StartBuiltinType has been called for all built-in types, FinishBuiltinType should be called in order
            to create links between the types.
            </summary>
        </member>
        <member name="M:System.Xml.Schema.DatatypeImplementation.FinishBuiltinType(System.Xml.Schema.XmlSchemaSimpleType,System.Xml.Schema.XmlSchemaSimpleType)">
            <summary>
            Finish constructing built-in types by setting up derivation and list links.
            </summary>
        </member>
        <member name="P:System.Xml.Schema.StringFacetsChecker.LanguageRegex">
            <remarks>
            Pattern:<br/>
            <code>^([a-zA-Z]{1,8})(-[a-zA-Z0-9]{1,8})*$</code><br/>
            Options:<br/>
            <code>RegexOptions.ExplicitCapture</code><br/>
            Explanation:<br/>
            <code>
             Match if at the beginning of the string.<br/>
             Match a character in the set [A-Za-z] greedily at least 1 and at most 8 times.<br/>
             Loop greedily any number of times.<br/>
                 Match '-'.<br/>
                 Match a character in the set [0-9A-Za-z] atomically at least 1 and at most 8 times.<br/>
             Match if at the end of the string or if before an ending newline.<br/>
            </code>
            </remarks>
        </member>
        <member name="T:System.Xml.Schema.ValidationEventArgs">
            <summary>
            Returns detailed information relating to
            the ValidationEventhandler.
            </summary>
        </member>
        <member name="P:System.Xml.Schema.ValidationEventArgs.Message">
            <summary>
            Gets the text description corresponding to the validation error.
            </summary>
        </member>
        <member name="T:System.Xml.Schema.XmlAtomicValue">
            <summary>
            This class contains a (CLR Object, XmlType) pair that represents an instance of an Xml atomic value.
            It is optimized to avoid boxing.
            </summary>
        </member>
        <member name="M:System.Xml.Schema.XmlAtomicValue.Clone">
            <summary>
            Since XmlAtomicValue is immutable, clone simply returns this.
            </summary>
        </member>
        <member name="M:System.Xml.Schema.XmlAtomicValue.System#ICloneable#Clone">
            <summary>
            Since XmlAtomicValue is immutable, clone simply returns this.
            </summary>
        </member>
        <member name="T:System.Xml.Schema.XmlSchemaCollection">
            <summary>
            The XmlSchemaCollection contains a set of namespace URI's.
            Each namespace also have an associated private data cache
            corresponding to the XML-Data Schema or W3C XML Schema.
            The XmlSchemaCollection will able to load XSD and XDR schemas,
            and compile them into an internal "cooked schema representation".
            The Validate method then uses this internal representation for
            efficient runtime validation of any given subtree.
            </summary>
        </member>
        <member name="M:System.Xml.Schema.XmlSchemaCollection.#ctor">
            <summary>
            Construct a new empty schema collection.
            </summary>
        </member>
        <member name="M:System.Xml.Schema.XmlSchemaCollection.#ctor(System.Xml.XmlNameTable)">
            <summary>
            Construct a new empty schema collection with associated XmlNameTable.
            The XmlNameTable is used when loading schemas.
            </summary>
        </member>
        <member name="P:System.Xml.Schema.XmlSchemaCollection.Count">
            <summary>
            Returns the number of namespaces defined in this collection
            (whether or not there is an actual schema associated with those namespaces or not).
            </summary>
        </member>
        <member name="P:System.Xml.Schema.XmlSchemaCollection.NameTable">
            <summary>
            The default XmlNameTable used by the XmlSchemaCollection when loading new schemas.
            </summary>
        </member>
        <member name="M:System.Xml.Schema.XmlSchemaCollection.Add(System.String,System.String)">
            <summary>
            Add the schema located by the given URL into the schema collection.
            If the given schema references other namespaces, the schemas for those other
            namespaces are NOT automatically loaded.
            </summary>
        </member>
        <member name="M:System.Xml.Schema.XmlSchemaCollection.Add(System.String,System.Xml.XmlReader,System.Xml.XmlResolver)">
            <summary>
            Add the given schema into the schema collection.
            If the given schema references other namespaces, the schemas for those
            other namespaces are NOT automatically loaded.
            </summary>
        </member>
        <member name="M:System.Xml.Schema.XmlSchemaCollection.Add(System.Xml.Schema.XmlSchemaCollection)">
            <summary>
            Adds all the namespaces defined in the given collection
            (including their associated schemas) to this collection.
            </summary>
        </member>
        <member name="P:System.Xml.Schema.XmlSchemaCollection.Item(System.String)">
            <summary>
            Looks up the schema by its associated namespace URI
            </summary>
        </member>
        <member name="M:System.Xml.Schema.XmlSchemaCollection.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Get a IEnumerator of the XmlSchemaCollection.
            </summary>
        </member>
        <member name="T:System.Xml.Schema.XmlSchemaForm">
            <devdoc>
               <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="F:System.Xml.Schema.XmlSchemaForm.None">
            <devdoc>
               <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="F:System.Xml.Schema.XmlSchemaForm.Qualified">
            <devdoc>
               <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="F:System.Xml.Schema.XmlSchemaForm.Unqualified">
            <devdoc>
               <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="T:System.Xml.Schema.XmlSchemaSet">
            <summary>
            The XmlSchemaSet contains a set of namespace URI's.
            Each namespace also have an associated private data cache
            corresponding to the XML-Data Schema or W3C XML Schema.
            The XmlSchemaSet will able to load only XSD schemas,
            and compile them into an internal "cooked schema representation".
            The Validate method then uses this internal representation for
            efficient runtime validation of any given subtree.
            </summary>
        </member>
        <member name="M:System.Xml.Schema.XmlSchemaSet.#ctor">
            <summary>
            Construct a new empty schema schemas.
            </summary>
        </member>
        <member name="M:System.Xml.Schema.XmlSchemaSet.#ctor(System.Xml.XmlNameTable)">
            <summary>
            Construct a new empty schema schemas with associated XmlNameTable.
            The XmlNameTable is used when loading schemas.
            </summary>
        </member>
        <member name="P:System.Xml.Schema.XmlSchemaSet.NameTable">
            <summary>
            The default XmlNameTable used by the XmlSchemaSet when loading new schemas.
            </summary>
        </member>
        <member name="P:System.Xml.Schema.XmlSchemaSet.IsCompiled">
            <summary>
            IsCompiled is true when the schema set is in compiled state.
            </summary>
        </member>
        <member name="P:System.Xml.Schema.XmlSchemaSet.Count">
            <summary>
            Returns the count of schemas in the set.
            </summary>
        </member>
        <member name="P:System.Xml.Schema.XmlSchemaSet.SchemaLocations">
            <summary>
            Table of all types extensions
            </summary>
        </member>
        <member name="P:System.Xml.Schema.XmlSchemaSet.TypeExtensions">
            <summary>
            Table of all types extensions
            </summary>
        </member>
        <member name="M:System.Xml.Schema.XmlSchemaSet.Add(System.String,System.String)">
            <summary>
            Add the schema located by the given URL into the schema schemas.
            If the given schema references other namespaces, the schemas for those other
            namespaces are NOT automatically loaded.
            </summary>
        </member>
        <member name="M:System.Xml.Schema.XmlSchemaSet.Add(System.String,System.Xml.XmlReader)">
            <summary>
            Add the given schema into the schema schemas.
            If the given schema references other namespaces, the schemas for those
            other namespaces are NOT automatically loaded.
            </summary>
        </member>
        <member name="M:System.Xml.Schema.XmlSchemaSet.Add(System.Xml.Schema.XmlSchemaSet)">
            <summary>
            Adds all the namespaces defined in the given schemas
            (including their associated schemas) to this schemas.
            </summary>
        </member>
        <member name="T:System.Xml.Schema.XmlSchemaType">
            <devdoc>
               <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="M:System.Xml.Schema.XmlSchemaType.GetBuiltInSimpleType(System.Xml.XmlQualifiedName)">
            <devdoc>
               <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="M:System.Xml.Schema.XmlSchemaType.GetBuiltInSimpleType(System.Xml.Schema.XmlTypeCode)">
            <devdoc>
               <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="M:System.Xml.Schema.XmlSchemaType.GetBuiltInComplexType(System.Xml.Schema.XmlTypeCode)">
            <devdoc>
               <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="M:System.Xml.Schema.XmlSchemaType.GetBuiltInComplexType(System.Xml.XmlQualifiedName)">
            <devdoc>
               <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="P:System.Xml.Schema.XmlSchemaType.Name">
            <devdoc>
               <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="P:System.Xml.Schema.XmlSchemaType.Final">
            <devdoc>
               <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="P:System.Xml.Schema.XmlSchemaType.QualifiedName">
            <devdoc>
               <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="P:System.Xml.Schema.XmlSchemaType.FinalResolved">
            <devdoc>
               <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="P:System.Xml.Schema.XmlSchemaType.BaseSchemaType">
            <devdoc>
               <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="P:System.Xml.Schema.XmlSchemaType.BaseXmlSchemaType">
            <devdoc>
               <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="P:System.Xml.Schema.XmlSchemaType.DerivedBy">
            <devdoc>
               <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="P:System.Xml.Schema.XmlSchemaType.Datatype">
            <devdoc>
               <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="P:System.Xml.Schema.XmlSchemaType.IsMixed">
            <devdoc>
               <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="F:System.Xml.Schema.XmlSeverityType.Error">
            <summary>
            Errors that can be recovered from.
            </summary>
        </member>
        <member name="F:System.Xml.Schema.XmlSeverityType.Warning">
            <summary>
            Errors that can be ignored.
            </summary>
        </member>
        <member name="P:System.Xml.Schema.XmlBaseConverter.SchemaType">
            <summary>
            Return this converter's prime schema type (may be null in case of Node, Item, etc).
            </summary>
        </member>
        <member name="P:System.Xml.Schema.XmlBaseConverter.TypeCode">
            <summary>
            Return the XmlTypeCode of this converter's prime schema type.
            </summary>
        </member>
        <member name="P:System.Xml.Schema.XmlBaseConverter.XmlTypeName">
            <summary>
            Return a string representation of this converter's prime schema type.
            </summary>
        </member>
        <member name="P:System.Xml.Schema.XmlBaseConverter.DefaultClrType">
            <summary>
            Return default V1 Clr mapping of this converter's type.
            </summary>
        </member>
        <member name="P:System.Xml.Schema.XmlBaseConverter.DefaultClrListType">
            <summary>
            Return an array type with the element type of the default V1 Clr mapping of this converter's type.
            </summary>
        </member>
        <member name="M:System.Xml.Schema.XmlBaseConverter.IsDerivedFrom(System.Type,System.Type)">
            <summary>
            Type.IsSubtypeOf does not return true if types are equal, this method does.
            </summary>
        </member>
        <member name="M:System.Xml.Schema.XmlBaseConverter.CreateInvalidClrMappingException(System.Type,System.Type)">
            <summary>
            Create an InvalidCastException for cases where either "destinationType" or "sourceType" is not a supported CLR representation
            for this Xml type.
            </summary>
        </member>
        <member name="M:System.Xml.Schema.XmlBaseConverter.QNameToString(System.Xml.XmlQualifiedName)">
            <summary>
            Convert an XmlQualifiedName to a string, using somewhat different rules than XmlQualifiedName.ToString():
              1. Recognize the built-in xs: and xdt: namespaces and print the short prefix rather than the long namespace
              2. Use brace characters "{", "}" around the namespace portion of the QName
            </summary>
        </member>
        <member name="M:System.Xml.Schema.XmlBaseConverter.ChangeListType(System.Object,System.Type,System.Xml.IXmlNamespaceResolver)">
            <summary>
            This method is called when a valid conversion cannot be found.  By default, this method throws an error.  It can
            be overridden in derived classes to support list conversions.
            </summary>
        </member>
        <member name="M:System.Xml.Schema.XmlAnyConverter.ToNavigator(System.Xml.XPath.XPathNavigator)">
            <summary>
            Throw an exception if nodes are not allowed by this converter.
            </summary>
        </member>
        <member name="M:System.Xml.Schema.XmlListConverter.IsListType(System.Type)">
            <summary>
            Return true if "type" is one of the following:
              1. IList, ICollection, IEnumerable
              2. A strongly-typed array
              3. A string
            </summary>
        </member>
        <member name="M:System.Xml.Schema.XmlListConverter.ToArray``1(System.Object,System.Xml.IXmlNamespaceResolver)">
            <summary>
            Convert "list" to an array of type T by iterating over each item in "list" and converting it to type "T"
            by invoking the atomic converter.
            </summary>
        </member>
        <member name="M:System.Xml.Schema.XmlListConverter.ToList(System.Object,System.Xml.IXmlNamespaceResolver)">
            <summary>
            Convert "list" to an IList containing items in the atomic type's default representation.
            </summary>
        </member>
        <member name="M:System.Xml.Schema.XmlListConverter.StringAsList(System.String)">
            <summary>
            Tokenize "value" by splitting it on whitespace characters.  Insert tokens into an ArrayList and return the list.
            </summary>
        </member>
        <member name="M:System.Xml.Schema.XmlListConverter.ListAsString(System.Collections.IEnumerable,System.Xml.IXmlNamespaceResolver)">
            <summary>
            Convert a list to a corresponding list of strings.  Then concatenate the strings, which adjacent values delimited
            by a space character.
            </summary>
        </member>
        <member name="M:System.Xml.Schema.XmlListConverter.CreateInvalidClrMappingException(System.Type,System.Type)">
            <summary>
            Create an InvalidCastException for cases where either "destinationType" or "sourceType" is not a supported CLR representation
            for this Xml type.
            </summary>
        </member>
        <member name="T:System.Xml.Schema.XsdDateTimeFlags">
            <summary>
            This enum specifies what format should be used when converting string to XsdDateTime
            </summary>
        </member>
        <member name="T:System.Xml.Schema.XsdDateTime">
            <summary>
            This structure extends System.DateTime to support timeInTicks zone and Gregorian types components of an Xsd Duration.  It is used internally to support Xsd durations without loss
            of fidelity.  XsdDuration structures are immutable once they've been created.
            </summary>
        </member>
        <member name="M:System.Xml.Schema.XsdDateTime.#ctor(System.String,System.Xml.Schema.XsdDateTimeFlags)">
            <summary>
            Constructs an XsdDateTime from a string using specific format.
            </summary>
        </member>
        <member name="M:System.Xml.Schema.XsdDateTime.#ctor(System.DateTime,System.Xml.Schema.XsdDateTimeFlags)">
            <summary>
            Constructs an XsdDateTime from a DateTime.
            </summary>
        </member>
        <member name="P:System.Xml.Schema.XsdDateTime.InternalTypeCode">
            <summary>
            Returns auxiliary enumeration of XSD date type
            </summary>
        </member>
        <member name="P:System.Xml.Schema.XsdDateTime.InternalKind">
            <summary>
            Returns geographical "position" of the value
            </summary>
        </member>
        <member name="P:System.Xml.Schema.XsdDateTime.TypeCode">
            <summary>
            Returns XmlTypeCode of the value being stored
            </summary>
        </member>
        <member name="P:System.Xml.Schema.XsdDateTime.Year">
            <summary>
            Returns the year part of XsdDateTime
            The returned value is integer between 1 and 9999
            </summary>
        </member>
        <member name="P:System.Xml.Schema.XsdDateTime.Month">
            <summary>
            Returns the month part of XsdDateTime
            The returned value is integer between 1 and 12
            </summary>
        </member>
        <member name="P:System.Xml.Schema.XsdDateTime.Day">
            <summary>
            Returns the day of the month part of XsdDateTime
            The returned value is integer between 1 and 31
            </summary>
        </member>
        <member name="P:System.Xml.Schema.XsdDateTime.Hour">
            <summary>
            Returns the hour part of XsdDateTime
            The returned value is integer between 0 and 23
            </summary>
        </member>
        <member name="P:System.Xml.Schema.XsdDateTime.Minute">
            <summary>
            Returns the minute part of XsdDateTime
            The returned value is integer between 0 and 60
            </summary>
        </member>
        <member name="P:System.Xml.Schema.XsdDateTime.Second">
            <summary>
            Returns the second part of XsdDateTime
            The returned value is integer between 0 and 60
            </summary>
        </member>
        <member name="P:System.Xml.Schema.XsdDateTime.Fraction">
            <summary>
            Returns number of ticks in the fraction of the second
            The returned value is integer between 0 and 9999999
            </summary>
        </member>
        <member name="P:System.Xml.Schema.XsdDateTime.ZoneHour">
            <summary>
            Returns the hour part of the time zone
            The returned value is integer between -13 and 13
            </summary>
        </member>
        <member name="P:System.Xml.Schema.XsdDateTime.ZoneMinute">
            <summary>
            Returns the minute part of the time zone
            The returned value is integer between 0 and 60
            </summary>
        </member>
        <member name="M:System.Xml.Schema.XsdDateTime.op_Implicit(System.Xml.Schema.XsdDateTime)~System.DateTime">
             <summary>
             Cast to DateTime
             The following table describes the behaviors of getting the default value
             when a certain year/month/day values are missing.
            
             An "X" means that the value exists.  And "--" means that value is missing.
            
             Year    Month   Day =>  ResultYear  ResultMonth     ResultDay       Note
            
             X       X       X       Parsed year Parsed month    Parsed day
             X       X       --      Parsed Year Parsed month    First day       If we have year and month, assume the first day of that month.
             X       --      X       Parsed year First month     Parsed day      If the month is missing, assume first month of that year.
             X       --      --      Parsed year First month     First day       If we have only the year, assume the first day of that year.
            
             --      X       X       CurrentYear Parsed month    Parsed day      If the year is missing, assume the current year.
             --      X       --      CurrentYear Parsed month    First day       If we have only a month value, assume the current year and current day.
             --      --      X       CurrentYear First month     Parsed day      If we have only a day value, assume current year and first month.
             --      --      --      CurrentYear Current month   Current day     So this means that if the date string only contains time, you will get current date.
             </summary>
        </member>
        <member name="M:System.Xml.Schema.XsdDateTime.ToString">
            <summary>
            Serialization to a string
            </summary>
        </member>
        <member name="T:System.Xml.Schema.XsdDuration">
            <summary>
            This structure holds components of an Xsd Duration.  It is used internally to support Xsd durations without loss
            of fidelity.  XsdDuration structures are immutable once they've been created.
            </summary>
        </member>
        <member name="M:System.Xml.Schema.XsdDuration.#ctor(System.Boolean,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Construct an XsdDuration from component parts.
            </summary>
        </member>
        <member name="M:System.Xml.Schema.XsdDuration.#ctor(System.TimeSpan)">
            <summary>
            Construct an XsdDuration from a TimeSpan value.
            </summary>
        </member>
        <member name="M:System.Xml.Schema.XsdDuration.#ctor(System.TimeSpan,System.Xml.Schema.XsdDuration.DurationType)">
            <summary>
            Construct an XsdDuration from a TimeSpan value that represents an xsd:duration, an xdt:dayTimeDuration, or
            an xdt:yearMonthDuration.
            </summary>
        </member>
        <member name="M:System.Xml.Schema.XsdDuration.#ctor(System.String)">
            <summary>
            Constructs an XsdDuration from a string in the xsd:duration format.  Components are stored with loss
            of fidelity (except in the case of overflow).
            </summary>
        </member>
        <member name="M:System.Xml.Schema.XsdDuration.#ctor(System.String,System.Xml.Schema.XsdDuration.DurationType)">
            <summary>
            Constructs an XsdDuration from a string in the xsd:duration format.  Components are stored without loss
            of fidelity (except in the case of overflow).
            </summary>
        </member>
        <member name="P:System.Xml.Schema.XsdDuration.IsNegative">
            <summary>
            Return true if this duration is negative.
            </summary>
        </member>
        <member name="P:System.Xml.Schema.XsdDuration.Years">
            <summary>
            Return number of years in this duration (stored in 31 bits).
            </summary>
        </member>
        <member name="P:System.Xml.Schema.XsdDuration.Months">
            <summary>
            Return number of months in this duration (stored in 31 bits).
            </summary>
        </member>
        <member name="P:System.Xml.Schema.XsdDuration.Days">
            <summary>
            Return number of days in this duration (stored in 31 bits).
            </summary>
        </member>
        <member name="P:System.Xml.Schema.XsdDuration.Hours">
            <summary>
            Return number of hours in this duration (stored in 31 bits).
            </summary>
        </member>
        <member name="P:System.Xml.Schema.XsdDuration.Minutes">
            <summary>
            Return number of minutes in this duration (stored in 31 bits).
            </summary>
        </member>
        <member name="P:System.Xml.Schema.XsdDuration.Seconds">
            <summary>
            Return number of seconds in this duration (stored in 31 bits).
            </summary>
        </member>
        <member name="P:System.Xml.Schema.XsdDuration.Nanoseconds">
            <summary>
            Return number of nanoseconds in this duration.
            </summary>
        </member>
        <member name="M:System.Xml.Schema.XsdDuration.ToTimeSpan">
            <summary>
            Internal helper method that converts an Xsd duration to a TimeSpan value.  This code uses the estimate
            that there are 365 days in the year and 30 days in a month.
            </summary>
        </member>
        <member name="M:System.Xml.Schema.XsdDuration.ToTimeSpan(System.Xml.Schema.XsdDuration.DurationType)">
            <summary>
            Internal helper method that converts an Xsd duration to a TimeSpan value.  This code uses the estimate
            that there are 365 days in the year and 30 days in a month.
            </summary>
        </member>
        <member name="M:System.Xml.Schema.XsdDuration.ToString">
            <summary>
            Return the string representation of this Xsd duration.
            </summary>
        </member>
        <member name="M:System.Xml.Schema.XsdDuration.ToString(System.Xml.Schema.XsdDuration.DurationType)">
            <summary>
            Return the string representation according to xsd:duration rules, xdt:dayTimeDuration rules, or
            xdt:yearMonthDuration rules.
            </summary>
        </member>
        <member name="M:System.Xml.Schema.XsdDuration.TryParseDigits(System.String,System.Int32@,System.Boolean,System.Int32@,System.Int32@)">
            Helper method that constructs an integer from leading digits starting at s[offset].  "offset" is
            updated to contain an offset just beyond the last digit.  The number of digits consumed is returned in
            cntDigits.  The integer is returned (0 if no digits).  If the digits cannot fit into an Int32:
              1. If eatDigits is true, then additional digits will be silently discarded (don't count towards numDigits)
              2. If eatDigits is false, an overflow exception is thrown
        </member>
        <member name="T:System.Xml.Schema.XmlSchemaInference">
            <summary>
            Infer class serves for inferring XML Schema from given XML instance document.
            </summary>
        </member>
        <member name="M:System.Xml.Schema.XmlSchemaInference.InferElement(System.Xml.Schema.XmlSchemaElement,System.Boolean,System.Xml.Schema.XmlSchema)">
            <summary>
            Sets type of the xse based on the currently read element.
            If the type is already set, verifies that it matches the instance and if not, updates the type to validate the instance.
            </summary>
            <param name="xse">XmlSchemaElement corresponding to the element just read by the xtr XmlTextReader</param>
            <param name="bCreatingNewType">true if the type is newly created, false if the type already existed and matches the current element name</param>
            <param name="parentSchema">namespaceURI of the parent element. Used to distinguish if ref= should be used when parent is in different ns than child.</param>
        </member>
        <member name="M:System.Xml.Schema.XmlSchemaInference.FindMatchingElement(System.Boolean,System.Xml.XmlReader,System.Xml.Schema.XmlSchemaComplexType,System.Int32@,System.Xml.Schema.XmlSchema,System.Boolean)">
            <summary>
            Verifies that the current element has its corresponding element in the sequence and order is the same.
            If the order is not the same, it changes the particle from Sequence to Sequence with Choice.
            If there is more elements of the same kind in the sequence, sets maxOccurs to unbounded
            </summary>
            <param name="bCreatingNewType">True if this is a new type. This is important for setting minOccurs=0 for elements that did not exist in a particle.</param>
            <param name="xtr">text reader positioned to the current element</param>
            <param name="ct">complex type with Sequence or Choice Particle</param>
            <param name="lastUsedSeqItem">ordinal number in the sequence to indicate current sequence position</param>
            <param name="parentSchema">The parent schema.</param>
            <param name="setMaxoccurs">Whether set max occurs.</param>
        </member>
        <member name="T:System.CSharpHelpers">
            <devdoc>
               <para>Provides a base class for code generators.</para>
            </devdoc>
        </member>
        <member name="M:System.CSharpHelpers.IsValidLanguageIndependentIdentifier(System.String)">
            <devdoc>
               <para>
                  Gets a value indicating whether the specified value is a valid language
                  independent identifier.
               </para>
            </devdoc>
        </member>
        <member name="P:System.SR.Xml_UserException">
            <summary>{0}</summary>
        </member>
        <member name="P:System.SR.Xml_DefaultException">
            <summary>An XML error has occurred.</summary>
        </member>
        <member name="P:System.SR.Xml_InvalidOperation">
            <summary>Operation is not valid due to the current state of the object.</summary>
        </member>
        <member name="P:System.SR.Xml_ErrorFilePosition">
            <summary>An error occurred at {0}, ({1}, {2}).</summary>
        </member>
        <member name="P:System.SR.Xml_StackOverflow">
            <summary>Stack overflow.</summary>
        </member>
        <member name="P:System.SR.Xslt_NoStylesheetLoaded">
            <summary>No stylesheet was loaded.</summary>
        </member>
        <member name="P:System.SR.Xslt_NotCompiledStylesheet">
            <summary>Type '{0}' is not a compiled stylesheet class.</summary>
        </member>
        <member name="P:System.SR.Xslt_IncompatibleCompiledStylesheetVersion">
            <summary>Executing a stylesheet that was compiled using a later version of the framework is not supported. Stylesheet Version: {0}. Current Framework Version: {1}.</summary>
        </member>
        <member name="P:System.SR.Xml_AsyncIsRunningException">
            <summary>An asynchronous operation is already in progress.</summary>
        </member>
        <member name="P:System.SR.Xml_ReaderAsyncNotSetException">
            <summary>Set XmlReaderSettings.Async to true if you want to use Async Methods.</summary>
        </member>
        <member name="P:System.SR.Xml_UnclosedQuote">
            <summary>There is an unclosed literal string.</summary>
        </member>
        <member name="P:System.SR.Xml_UnexpectedEOF">
            <summary>Unexpected end of file while parsing {0} has occurred.</summary>
        </member>
        <member name="P:System.SR.Xml_UnexpectedEOF1">
            <summary>Unexpected end of file has occurred.</summary>
        </member>
        <member name="P:System.SR.Xml_UnexpectedEOFInElementContent">
            <summary>Unexpected end of file has occurred. The following elements are not closed: {0}</summary>
        </member>
        <member name="P:System.SR.Xml_BadStartNameChar">
            <summary>Name cannot begin with the '{0}' character, hexadecimal value {1}.</summary>
        </member>
        <member name="P:System.SR.Xml_BadNameChar">
            <summary>The '{0}' character, hexadecimal value {1}, cannot be included in a name.</summary>
        </member>
        <member name="P:System.SR.Xml_BadDecimalEntity">
            <summary>Invalid syntax for a decimal numeric entity reference.</summary>
        </member>
        <member name="P:System.SR.Xml_BadHexEntity">
            <summary>Invalid syntax for a hexadecimal numeric entity reference.</summary>
        </member>
        <member name="P:System.SR.Xml_MissingByteOrderMark">
            <summary>There is no Unicode byte order mark. Cannot switch to Unicode.</summary>
        </member>
        <member name="P:System.SR.Xml_UnknownEncoding">
            <summary>System does not support '{0}' encoding.</summary>
        </member>
        <member name="P:System.SR.Xml_InternalError">
            <summary>An internal error has occurred.</summary>
        </member>
        <member name="P:System.SR.Xml_InvalidCharInThisEncoding">
            <summary>Invalid character in the given encoding.</summary>
        </member>
        <member name="P:System.SR.Xml_ErrorPosition">
            <summary>Line {0}, position {1}.</summary>
        </member>
        <member name="P:System.SR.Xml_MessageWithErrorPosition">
            <summary>{0} Line {1}, position {2}.</summary>
        </member>
        <member name="P:System.SR.Xml_UnexpectedTokenEx">
            <summary>'{0}' is an unexpected token. The expected token is '{1}'.</summary>
        </member>
        <member name="P:System.SR.Xml_UnexpectedTokens2">
            <summary>'{0}' is an unexpected token. The expected token is '{1}' or '{2}'.</summary>
        </member>
        <member name="P:System.SR.Xml_ExpectingWhiteSpace">
            <summary>'{0}' is an unexpected token. Expecting whitespace.</summary>
        </member>
        <member name="P:System.SR.Xml_TagMismatchEx">
            <summary>The '{0}' start tag on line {1} position {2} does not match the end tag of '{3}'.</summary>
        </member>
        <member name="P:System.SR.Xml_UnexpectedEndTag">
            <summary>Unexpected end tag.</summary>
        </member>
        <member name="P:System.SR.Xml_UnknownNs">
            <summary>'{0}' is an undeclared prefix.</summary>
        </member>
        <member name="P:System.SR.Xml_BadAttributeChar">
            <summary>'{0}', hexadecimal value {1}, is an invalid attribute character.</summary>
        </member>
        <member name="P:System.SR.Xml_ExpectExternalOrClose">
            <summary>Expecting external ID, '[' or '&gt;'.</summary>
        </member>
        <member name="P:System.SR.Xml_MissingRoot">
            <summary>Root element is missing.</summary>
        </member>
        <member name="P:System.SR.Xml_MultipleRoots">
            <summary>There are multiple root elements.</summary>
        </member>
        <member name="P:System.SR.Xml_InvalidRootData">
            <summary>Data at the root level is invalid.</summary>
        </member>
        <member name="P:System.SR.Xml_XmlDeclNotFirst">
            <summary>Unexpected XML declaration. The XML declaration must be the first node in the document, and no whitespace characters are allowed to appear before it.</summary>
        </member>
        <member name="P:System.SR.Xml_InvalidXmlDecl">
            <summary>Syntax for an XML declaration is invalid.</summary>
        </member>
        <member name="P:System.SR.Xml_InvalidNodeType">
            <summary>'{0}' is an invalid XmlNodeType.</summary>
        </member>
        <member name="P:System.SR.Xml_InvalidPIName">
            <summary>'{0}' is an invalid name for processing instructions.</summary>
        </member>
        <member name="P:System.SR.Xml_InvalidXmlSpace">
            <summary>'{0}' is an invalid xml:space value.</summary>
        </member>
        <member name="P:System.SR.Xml_InvalidVersionNumber">
            <summary>Version number '{0}' is invalid.</summary>
        </member>
        <member name="P:System.SR.Xml_DupAttributeName">
            <summary>'{0}' is a duplicate attribute name.</summary>
        </member>
        <member name="P:System.SR.Xml_BadDTDLocation">
            <summary>Unexpected DTD declaration.</summary>
        </member>
        <member name="P:System.SR.Xml_ElementNotFound">
            <summary>Element '{0}' was not found.</summary>
        </member>
        <member name="P:System.SR.Xml_ElementNotFoundNs">
            <summary>Element '{0}' with namespace name '{1}' was not found.</summary>
        </member>
        <member name="P:System.SR.Xml_PartialContentNodeTypeNotSupportedEx">
            <summary>XmlNodeType {0} is not supported for partial content parsing.</summary>
        </member>
        <member name="P:System.SR.Xml_MultipleDTDsProvided">
            <summary>Cannot have multiple DTDs.</summary>
        </member>
        <member name="P:System.SR.Xml_CanNotBindToReservedNamespace">
            <summary>Cannot bind to the reserved namespace.</summary>
        </member>
        <member name="P:System.SR.Xml_InvalidCharacter">
            <summary>'{0}', hexadecimal value {1}, is an invalid character.</summary>
        </member>
        <member name="P:System.SR.Xml_InvalidBinHexValue">
            <summary>'{0}' is not a valid BinHex text sequence.</summary>
        </member>
        <member name="P:System.SR.Xml_InvalidBinHexValueOddCount">
            <summary>'{0}' is not a valid BinHex text sequence. The sequence must contain an even number of characters.</summary>
        </member>
        <member name="P:System.SR.Xml_InvalidTextDecl">
            <summary>Invalid text declaration.</summary>
        </member>
        <member name="P:System.SR.Xml_InvalidBase64Value">
            <summary>'{0}' is not a valid Base64 text sequence.</summary>
        </member>
        <member name="P:System.SR.Xml_UndeclaredEntity">
            <summary>Reference to undeclared entity '{0}'.</summary>
        </member>
        <member name="P:System.SR.Xml_RecursiveParEntity">
            <summary>Parameter entity '{0}' references itself.</summary>
        </member>
        <member name="P:System.SR.Xml_RecursiveGenEntity">
            <summary>General entity '{0}' references itself.</summary>
        </member>
        <member name="P:System.SR.Xml_ExternalEntityInAttValue">
            <summary>External entity '{0}' reference cannot appear in the attribute value.</summary>
        </member>
        <member name="P:System.SR.Xml_UnparsedEntityRef">
            <summary>Reference to unparsed entity '{0}'.</summary>
        </member>
        <member name="P:System.SR.Xml_NotSameNametable">
            <summary>Not the same name table.</summary>
        </member>
        <member name="P:System.SR.Xml_NametableMismatch">
            <summary>XmlReaderSettings.XmlNameTable must be the same name table as in XmlParserContext.NameTable or XmlParserContext.NamespaceManager.NameTable, or it must be null.</summary>
        </member>
        <member name="P:System.SR.Xml_BadNamespaceDecl">
            <summary>Invalid namespace declaration.</summary>
        </member>
        <member name="P:System.SR.Xml_ErrorParsingEntityName">
            <summary>An error occurred while parsing EntityName.</summary>
        </member>
        <member name="P:System.SR.Xml_InvalidNmToken">
            <summary>Invalid NmToken value '{0}'.</summary>
        </member>
        <member name="P:System.SR.Xml_EntityRefNesting">
            <summary>Entity replacement text must nest properly within markup declarations.</summary>
        </member>
        <member name="P:System.SR.Xml_CannotResolveEntity">
            <summary>Cannot resolve entity reference '{0}'.</summary>
        </member>
        <member name="P:System.SR.Xml_CannotResolveEntityDtdIgnored">
            <summary>Cannot resolve entity reference '{0}' because the DTD has been ignored. To enable DTD processing set the DtdProcessing property on XmlReaderSettings to Parse and pass the settings into XmlReader.Create method.</summary>
        </member>
        <member name="P:System.SR.Xml_CannotResolveExternalSubset">
            <summary>Cannot resolve external DTD subset - public ID = '{0}', system ID = '{1}'.</summary>
        </member>
        <member name="P:System.SR.Xml_CannotResolveUrl">
            <summary>Cannot resolve '{0}'.</summary>
        </member>
        <member name="P:System.SR.Xml_CDATAEndInText">
            <summary>']]&gt;' is not allowed in character data.</summary>
        </member>
        <member name="P:System.SR.Xml_ExternalEntityInStandAloneDocument">
            <summary>Standalone document declaration must have a value of 'no' because an external entity '{0}' is referenced.</summary>
        </member>
        <member name="P:System.SR.Xml_DtdAfterRootElement">
            <summary>DTD must be defined before the document root element.</summary>
        </member>
        <member name="P:System.SR.Xml_ReadOnlyProperty">
            <summary>The '{0}' property is read only and cannot be set.</summary>
        </member>
        <member name="P:System.SR.Xml_DtdIsProhibited">
            <summary>DTD is prohibited in this XML document.</summary>
        </member>
        <member name="P:System.SR.Xml_DtdIsProhibitedEx">
            <summary>For security reasons DTD is prohibited in this XML document. To enable DTD processing set the DtdProcessing property on XmlReaderSettings to Parse and pass the settings into XmlReader.Create method.</summary>
        </member>
        <member name="P:System.SR.Xml_ReadSubtreeNotOnElement">
            <summary>ReadSubtree() can be called only if the reader is on an element node.</summary>
        </member>
        <member name="P:System.SR.Xml_DtdNotAllowedInFragment">
            <summary>DTD is not allowed in XML fragments.</summary>
        </member>
        <member name="P:System.SR.Xml_CannotStartDocumentOnFragment">
            <summary>WriteStartDocument cannot be called on writers created with ConformanceLevel.Fragment.</summary>
        </member>
        <member name="P:System.SR.Xml_ErrorOpeningExternalDtd">
            <summary>An error has occurred while opening external DTD '{0}': {1}</summary>
        </member>
        <member name="P:System.SR.Xml_ErrorOpeningExternalEntity">
            <summary>An error has occurred while opening external entity '{0}': {1}</summary>
        </member>
        <member name="P:System.SR.Xml_ReadBinaryContentNotSupported">
            <summary>{0} method is not supported on this XmlReader. Use CanReadBinaryContent property to find out if a reader implements it.</summary>
        </member>
        <member name="P:System.SR.Xml_ReadValueChunkNotSupported">
            <summary>ReadValueChunk method is not supported on this XmlReader. Use CanReadValueChunk property to find out if an XmlReader implements it.</summary>
        </member>
        <member name="P:System.SR.Xml_InvalidReadContentAs">
            <summary>The {0} method is not supported on node type {1}. If you want to read typed content of an element, use the ReadElementContentAs method.</summary>
        </member>
        <member name="P:System.SR.Xml_InvalidReadElementContentAs">
            <summary>The {0} method is not supported on node type {1}.</summary>
        </member>
        <member name="P:System.SR.Xml_MixedReadElementContentAs">
            <summary>ReadElementContentAs() methods cannot be called on an element that has child elements.</summary>
        </member>
        <member name="P:System.SR.Xml_MixingReadValueChunkWithBinary">
            <summary>ReadValueChunk calls cannot be mixed with ReadContentAsBase64 or ReadContentAsBinHex.</summary>
        </member>
        <member name="P:System.SR.Xml_MixingBinaryContentMethods">
            <summary>ReadContentAsBase64 and ReadContentAsBinHex method calls cannot be mixed with calls to ReadElementContentAsBase64 and ReadElementContentAsBinHex.</summary>
        </member>
        <member name="P:System.SR.Xml_MixingV1StreamingWithV2Binary">
            <summary>ReadContentAsBase64 and ReadContentAsBinHex method calls cannot be mixed with calls to ReadChars, ReadBase64, and ReadBinHex.</summary>
        </member>
        <member name="P:System.SR.Xml_InvalidReadValueChunk">
            <summary>The ReadValueAsChunk method is not supported on node type {0}.</summary>
        </member>
        <member name="P:System.SR.Xml_ReadContentAsFormatException">
            <summary>Content cannot be converted to the type {0}.</summary>
        </member>
        <member name="P:System.SR.Xml_DoubleBaseUri">
            <summary>BaseUri must be specified either as an argument of XmlReader.Create or on the XmlParserContext. If it is specified on both, it must be the same base URI.</summary>
        </member>
        <member name="P:System.SR.Xml_NotEnoughSpaceForSurrogatePair">
            <summary>The buffer is not large enough to fit a surrogate pair. Please provide a buffer of size at least 2 characters.</summary>
        </member>
        <member name="P:System.SR.Xml_UnexpectedNodeInSimpleContent">
            <summary>Unexpected node type {0}. {1} method can only be called on elements with simple or empty content.</summary>
        </member>
        <member name="P:System.SR.Xml_InvalidWhitespaceCharacter">
            <summary>The Whitespace or SignificantWhitespace node can contain only XML whitespace characters. '{0}' is not an XML white space character.</summary>
        </member>
        <member name="P:System.SR.Xml_IncompatibleConformanceLevel">
            <summary>Cannot change conformance checking to {0}. Make sure the ConformanceLevel in XmlReaderSettings is set to Auto for wrapping scenarios.</summary>
        </member>
        <member name="P:System.SR.Xml_LimitExceeded">
            <summary>The input document has exceeded a limit set by {0}.</summary>
        </member>
        <member name="P:System.SR.Xml_ClosedOrErrorReader">
            <summary>The XmlReader is closed or in error state.</summary>
        </member>
        <member name="P:System.SR.Xml_CharEntityOverflow">
            <summary>Invalid value of a character entity reference.</summary>
        </member>
        <member name="P:System.SR.Xml_BadNameCharWithPos">
            <summary>The '{0}' character, hexadecimal value {1}, at position {2} within the name, cannot be included in a name.</summary>
        </member>
        <member name="P:System.SR.Xml_XmlnsBelongsToReservedNs">
            <summary>The 'xmlns' attribute is bound to the reserved namespace 'http://www.w3.org/2000/xmlns/'.</summary>
        </member>
        <member name="P:System.SR.Xml_UndeclaredParEntity">
            <summary>Reference to undeclared parameter entity '{0}'.</summary>
        </member>
        <member name="P:System.SR.Xml_InvalidXmlDocument">
            <summary>Invalid XML document. {0}</summary>
        </member>
        <member name="P:System.SR.Xml_NoDTDPresent">
            <summary>No DTD found.</summary>
        </member>
        <member name="P:System.SR.Xml_MultipleValidationTypes">
            <summary>Unsupported combination of validation types.</summary>
        </member>
        <member name="P:System.SR.Xml_NoValidation">
            <summary>No validation occurred.</summary>
        </member>
        <member name="P:System.SR.Xml_WhitespaceHandling">
            <summary>Expected WhitespaceHandling.None, or WhitespaceHandling.All, or WhitespaceHandling.Significant.</summary>
        </member>
        <member name="P:System.SR.Xml_InvalidResetStateCall">
            <summary>Cannot call ResetState when parsing an XML fragment.</summary>
        </member>
        <member name="P:System.SR.Xml_EntityHandling">
            <summary>Expected EntityHandling.ExpandEntities or EntityHandling.ExpandCharEntities.</summary>
        </member>
        <member name="P:System.SR.Xml_AttlistDuplEnumValue">
            <summary>'{0}' is a duplicate enumeration value.</summary>
        </member>
        <member name="P:System.SR.Xml_AttlistDuplNotationValue">
            <summary>'{0}' is a duplicate notation value.</summary>
        </member>
        <member name="P:System.SR.Xml_EncodingSwitchAfterResetState">
            <summary>'{0}' is an invalid value for the 'encoding' attribute. The encoding cannot be switched after a call to ResetState.</summary>
        </member>
        <member name="P:System.SR.Xml_UnexpectedNodeType">
            <summary>Unexpected XmlNodeType: '{0}'.</summary>
        </member>
        <member name="P:System.SR.Xml_InvalidConditionalSection">
            <summary>A conditional section is not allowed in an internal subset.</summary>
        </member>
        <member name="P:System.SR.Xml_UnexpectedCDataEnd">
            <summary>']]&gt;' is not expected.</summary>
        </member>
        <member name="P:System.SR.Xml_UnclosedConditionalSection">
            <summary>There is an unclosed conditional section.</summary>
        </member>
        <member name="P:System.SR.Xml_ExpectDtdMarkup">
            <summary>Expected DTD markup was not found.</summary>
        </member>
        <member name="P:System.SR.Xml_IncompleteDtdContent">
            <summary>Incomplete DTD content.</summary>
        </member>
        <member name="P:System.SR.Xml_EnumerationRequired">
            <summary>Enumeration data type required.</summary>
        </member>
        <member name="P:System.SR.Xml_InvalidContentModel">
            <summary>Invalid content model.</summary>
        </member>
        <member name="P:System.SR.Xml_FragmentId">
            <summary>Fragment identifier '{0}' cannot be part of the system identifier '{1}'.</summary>
        </member>
        <member name="P:System.SR.Xml_ExpectPcData">
            <summary>Expecting 'PCDATA'.</summary>
        </member>
        <member name="P:System.SR.Xml_ExpectNoWhitespace">
            <summary>Whitespace not allowed before '?', '*', or '+'.</summary>
        </member>
        <member name="P:System.SR.Xml_ExpectOp">
            <summary>Expecting '?', '*', or '+'.</summary>
        </member>
        <member name="P:System.SR.Xml_InvalidAttributeType">
            <summary>'{0}' is an invalid attribute type.</summary>
        </member>
        <member name="P:System.SR.Xml_InvalidAttributeType1">
            <summary>Invalid attribute type.</summary>
        </member>
        <member name="P:System.SR.Xml_ExpectAttType">
            <summary>Expecting an attribute type.</summary>
        </member>
        <member name="P:System.SR.Xml_ColonInLocalName">
            <summary>'{0}' is an unqualified name and cannot contain the character ':'.</summary>
        </member>
        <member name="P:System.SR.Xml_InvalidParEntityRef">
            <summary>A parameter entity reference is not allowed in internal markup.</summary>
        </member>
        <member name="P:System.SR.Xml_ExpectSubOrClose">
            <summary>Expecting an internal subset or the end of the DOCTYPE declaration.</summary>
        </member>
        <member name="P:System.SR.Xml_ExpectExternalOrPublicId">
            <summary>Expecting a system identifier or a public identifier.</summary>
        </member>
        <member name="P:System.SR.Xml_ExpectExternalIdOrEntityValue">
            <summary>Expecting an external identifier or an entity value.</summary>
        </member>
        <member name="P:System.SR.Xml_ExpectIgnoreOrInclude">
            <summary>Conditional sections must specify the keyword 'IGNORE' or 'INCLUDE'.</summary>
        </member>
        <member name="P:System.SR.Xml_UnsupportedClass">
            <summary>Object type is not supported.</summary>
        </member>
        <member name="P:System.SR.Xml_NullResolver">
            <summary>Resolving of external URIs was prohibited. Attempted access to: {0}</summary>
        </member>
        <member name="P:System.SR.Xml_RelativeUriNotSupported">
            <summary>Relative URIs are not supported.</summary>
        </member>
        <member name="P:System.SR.Xml_WriterAsyncNotSetException">
            <summary>Set XmlWriterSettings.Async to true if you want to use Async Methods.</summary>
        </member>
        <member name="P:System.SR.Xml_PrefixForEmptyNs">
            <summary>Cannot use a prefix with an empty namespace.</summary>
        </member>
        <member name="P:System.SR.Xml_InvalidCommentChars">
            <summary>An XML comment cannot contain '--', and '-' cannot be the last character.</summary>
        </member>
        <member name="P:System.SR.Xml_UndefNamespace">
            <summary>The '{0}' namespace is not defined.</summary>
        </member>
        <member name="P:System.SR.Xml_EmptyName">
            <summary>The empty string '' is not a valid name.</summary>
        </member>
        <member name="P:System.SR.Xml_EmptyLocalName">
            <summary>The empty string '' is not a valid local name.</summary>
        </member>
        <member name="P:System.SR.Xml_InvalidNameCharsDetail">
            <summary>Invalid name character in '{0}'. The '{1}' character, hexadecimal value {2}, cannot be included in a name.</summary>
        </member>
        <member name="P:System.SR.Xml_NoStartTag">
            <summary>There was no XML start tag open.</summary>
        </member>
        <member name="P:System.SR.Xml_ClosedOrError">
            <summary>The Writer is closed or in error state.</summary>
        </member>
        <member name="P:System.SR.Xml_WrongToken">
            <summary>Token {0} in state {1} would result in an invalid XML document.</summary>
        </member>
        <member name="P:System.SR.Xml_XmlPrefix">
            <summary>Prefix "xml" is reserved for use by XML and can be mapped only to namespace name "http://www.w3.org/XML/1998/namespace".</summary>
        </member>
        <member name="P:System.SR.Xml_XmlnsPrefix">
            <summary>Prefix "xmlns" is reserved for use by XML.</summary>
        </member>
        <member name="P:System.SR.Xml_NamespaceDeclXmlXmlns">
            <summary>Prefix '{0}' cannot be mapped to namespace name reserved for "xml" or "xmlns".</summary>
        </member>
        <member name="P:System.SR.Xml_NonWhitespace">
            <summary>Only whitespace characters should be used.</summary>
        </member>
        <member name="P:System.SR.Xml_DupXmlDecl">
            <summary>Cannot write XML declaration. WriteStartDocument method has already written it.</summary>
        </member>
        <member name="P:System.SR.Xml_CannotWriteXmlDecl">
            <summary>Cannot write XML declaration. XML declaration can be only at the beginning of the document.</summary>
        </member>
        <member name="P:System.SR.Xml_NoRoot">
            <summary>Document does not have a root element.</summary>
        </member>
        <member name="P:System.SR.Xml_InvalidPosition">
            <summary>The current position on the Reader is neither an element nor an attribute.</summary>
        </member>
        <member name="P:System.SR.Xml_IncompleteEntity">
            <summary>Incomplete entity contents.</summary>
        </member>
        <member name="P:System.SR.Xml_InvalidSurrogateHighChar">
            <summary>Invalid high surrogate character (0x{0}). A high surrogate character must have a value from range (0xD800 - 0xDBFF).</summary>
        </member>
        <member name="P:System.SR.Xml_InvalidSurrogateMissingLowChar">
            <summary>The surrogate pair is invalid. Missing a low surrogate character.</summary>
        </member>
        <member name="P:System.SR.Xml_InvalidSurrogatePairWithArgs">
            <summary>The surrogate pair (0x{0}, 0x{1}) is invalid. A high surrogate character (0xD800 - 0xDBFF) must always be paired with a low surrogate character (0xDC00 - 0xDFFF).</summary>
        </member>
        <member name="P:System.SR.Xml_RedefinePrefix">
            <summary>The prefix '{0}' cannot be redefined from '{1}' to '{2}' within the same start element tag.</summary>
        </member>
        <member name="P:System.SR.Xml_DtdAlreadyWritten">
            <summary>The DTD has already been written out.</summary>
        </member>
        <member name="P:System.SR.Xml_InvalidCharsInIndent">
            <summary>XmlWriterSettings.{0} can contain only valid XML text content characters when XmlWriterSettings.CheckCharacters is true. {1}</summary>
        </member>
        <member name="P:System.SR.Xml_IndentCharsNotWhitespace">
            <summary>XmlWriterSettings.{0} can contain only valid XML whitespace characters when XmlWriterSettings.CheckCharacters and XmlWriterSettings.NewLineOnAttributes are true.</summary>
        </member>
        <member name="P:System.SR.Xml_ConformanceLevelFragment">
            <summary>Make sure that the ConformanceLevel setting is set to ConformanceLevel.Fragment or ConformanceLevel.Auto if you want to write an XML fragment.</summary>
        </member>
        <member name="P:System.SR.Xml_InvalidQuote">
            <summary>Invalid XML attribute quote character. Valid attribute quote characters are ' and ".</summary>
        </member>
        <member name="P:System.SR.Xml_UndefPrefix">
            <summary>An undefined prefix is in use.</summary>
        </member>
        <member name="P:System.SR.Xml_NoNamespaces">
            <summary>Cannot set the namespace if Namespaces is 'false'.</summary>
        </member>
        <member name="P:System.SR.Xml_InvalidCDataChars">
            <summary>Cannot have ']]&gt;' inside an XML CDATA block.</summary>
        </member>
        <member name="P:System.SR.Xml_NotTheFirst">
            <summary>WriteStartDocument needs to be the first call.</summary>
        </member>
        <member name="P:System.SR.Xml_InvalidPiChars">
            <summary>Cannot have '?&gt;' inside an XML processing instruction.</summary>
        </member>
        <member name="P:System.SR.Xml_InvalidNameChars">
            <summary>Invalid name character in '{0}'.</summary>
        </member>
        <member name="P:System.SR.Xml_Closed">
            <summary>The Writer is closed.</summary>
        </member>
        <member name="P:System.SR.Xml_InvalidPrefix">
            <summary>Prefixes beginning with "xml" (regardless of whether the characters are uppercase, lowercase, or some combination thereof) are reserved for use by XML.</summary>
        </member>
        <member name="P:System.SR.Xml_NotInWriteState">
            <summary>NotInWriteState.</summary>
        </member>
        <member name="P:System.SR.Xml_SurrogatePairSplit">
            <summary>The second character surrogate pair is not in the input buffer to be written.</summary>
        </member>
        <member name="P:System.SR.Xml_NoMultipleRoots">
            <summary>Document cannot have multiple document elements.</summary>
        </member>
        <member name="P:System.SR.XmlBadName">
            <summary>A node of type '{0}' cannot have the name '{1}'.</summary>
        </member>
        <member name="P:System.SR.XmlNoNameAllowed">
            <summary>A node of type '{0}' cannot have a name.</summary>
        </member>
        <member name="P:System.SR.XmlConvert_BadUri">
            <summary>The string was not recognized as a valid Uri.</summary>
        </member>
        <member name="P:System.SR.XmlConvert_BadFormat">
            <summary>The string '{0}' is not a valid {1} value.</summary>
        </member>
        <member name="P:System.SR.XmlConvert_Overflow">
            <summary>Value '{0}' was either too large or too small for {1}.</summary>
        </member>
        <member name="P:System.SR.XmlConvert_TypeBadMapping">
            <summary>Xml type '{0}' does not support Clr type '{1}'.</summary>
        </member>
        <member name="P:System.SR.XmlConvert_TypeBadMapping2">
            <summary>Xml type '{0}' does not support a conversion from Clr type '{1}' to Clr type '{2}'.</summary>
        </member>
        <member name="P:System.SR.XmlConvert_TypeListBadMapping">
            <summary>Xml type 'List of {0}' does not support Clr type '{1}'.</summary>
        </member>
        <member name="P:System.SR.XmlConvert_TypeListBadMapping2">
            <summary>Xml type 'List of {0}' does not support a conversion from Clr type '{1}' to Clr type '{2}'.</summary>
        </member>
        <member name="P:System.SR.XmlConvert_TypeToString">
            <summary>Xml type '{0}' cannot convert from Clr type '{1}' unless the destination type is String or XmlAtomicValue.</summary>
        </member>
        <member name="P:System.SR.XmlConvert_TypeFromString">
            <summary>Xml type '{0}' cannot convert to Clr type '{1}' unless the source value is a String or an XmlAtomicValue.</summary>
        </member>
        <member name="P:System.SR.XmlConvert_TypeNoPrefix">
            <summary>The QName '{0}' cannot be represented as a String.  A prefix for namespace '{1}' cannot be found.</summary>
        </member>
        <member name="P:System.SR.XmlConvert_TypeNoNamespace">
            <summary>The String '{0}' cannot be represented as an XmlQualifiedName.  A namespace for prefix '{1}' cannot be found.</summary>
        </member>
        <member name="P:System.SR.XmlConvert_NotOneCharString">
            <summary>String must be exactly one character long.</summary>
        </member>
        <member name="P:System.SR.Sch_ParEntityRefNesting">
            <summary>The parameter entity replacement text must nest properly within markup declarations.</summary>
        </member>
        <member name="P:System.SR.Sch_NotTokenString">
            <summary>line-feed (#xA) or tab (#x9) characters, leading or trailing spaces and sequences of one or more spaces (#x20) are not allowed in 'xs:token'.</summary>
        </member>
        <member name="P:System.SR.Sch_InvalidDateTimeOption">
            <summary>The '{0}' value for the 'dateTimeOption' parameter is not an allowed value for the 'XmlDateTimeSerializationMode' enumeration.</summary>
        </member>
        <member name="P:System.SR.Sch_StandAloneNormalization">
            <summary>StandAlone is 'yes' and the value of the attribute '{0}' contains a definition in an external document that changes on normalization.</summary>
        </member>
        <member name="P:System.SR.Sch_UnSpecifiedDefaultAttributeInExternalStandalone">
            <summary>Markup for unspecified default attribute '{0}' is external and standalone='yes'.</summary>
        </member>
        <member name="P:System.SR.Sch_DefaultException">
            <summary>A schema error occurred.</summary>
        </member>
        <member name="P:System.SR.Sch_DupElementDecl">
            <summary>The '{0}' element has already been declared.</summary>
        </member>
        <member name="P:System.SR.Sch_IdAttrDeclared">
            <summary>The attribute of type ID is already declared on the '{0}' element.</summary>
        </member>
        <member name="P:System.SR.Sch_RootMatchDocType">
            <summary>Root element name must match the DocType name.</summary>
        </member>
        <member name="P:System.SR.Sch_DupId">
            <summary>'{0}' is already used as an ID.</summary>
        </member>
        <member name="P:System.SR.Sch_UndeclaredElement">
            <summary>The '{0}' element is not declared.</summary>
        </member>
        <member name="P:System.SR.Sch_UndeclaredAttribute">
            <summary>The '{0}' attribute is not declared.</summary>
        </member>
        <member name="P:System.SR.Sch_UndeclaredNotation">
            <summary>The '{0}' notation is not declared.</summary>
        </member>
        <member name="P:System.SR.Sch_UndeclaredId">
            <summary>Reference to undeclared ID is '{0}'.</summary>
        </member>
        <member name="P:System.SR.Sch_SchemaRootExpected">
            <summary>Expected schema root. Make sure the root element is &lt;schema&gt; and the namespace is 'http://www.w3.org/2001/XMLSchema' for an XSD schema or 'urn:schemas-microsoft-com:xml-data' for an XDR schema.</summary>
        </member>
        <member name="P:System.SR.Sch_XSDSchemaRootExpected">
            <summary>The root element of a W3C XML Schema should be &lt;schema&gt; and its namespace should be 'http://www.w3.org/2001/XMLSchema'.</summary>
        </member>
        <member name="P:System.SR.Sch_UnsupportedAttribute">
            <summary>The '{0}' attribute is not supported in this context.</summary>
        </member>
        <member name="P:System.SR.Sch_UnsupportedElement">
            <summary>The '{0}' element is not supported in this context.</summary>
        </member>
        <member name="P:System.SR.Sch_MissAttribute">
            <summary>The '{0}' attribute is either invalid or missing.</summary>
        </member>
        <member name="P:System.SR.Sch_AnnotationLocation">
            <summary>The 'annotation' element cannot appear at this location.</summary>
        </member>
        <member name="P:System.SR.Sch_DataTypeTextOnly">
            <summary>Content must be "textOnly" when using DataType on an ElementType.</summary>
        </member>
        <member name="P:System.SR.Sch_UnknownModel">
            <summary>The model attribute must have a value of open or closed, not '{0}'.</summary>
        </member>
        <member name="P:System.SR.Sch_UnknownOrder">
            <summary>The order attribute must have a value of 'seq', 'one', or 'many', not '{0}'.</summary>
        </member>
        <member name="P:System.SR.Sch_UnknownContent">
            <summary>The content attribute must have a value of 'textOnly', 'eltOnly', 'mixed', or 'empty', not '{0}'.</summary>
        </member>
        <member name="P:System.SR.Sch_UnknownRequired">
            <summary>The required attribute must have a value of yes or no.</summary>
        </member>
        <member name="P:System.SR.Sch_UnknownDtType">
            <summary>Reference to an unknown data type, '{0}'.</summary>
        </member>
        <member name="P:System.SR.Sch_MixedMany">
            <summary>The order must be many when content is mixed.</summary>
        </member>
        <member name="P:System.SR.Sch_GroupDisabled">
            <summary>The group is not allowed when ElementType has empty or textOnly content.</summary>
        </member>
        <member name="P:System.SR.Sch_MissDtvalue">
            <summary>The DataType value cannot be empty.</summary>
        </member>
        <member name="P:System.SR.Sch_MissDtvaluesAttribute">
            <summary>The dt:values attribute is missing.</summary>
        </member>
        <member name="P:System.SR.Sch_DupDtType">
            <summary>Data type has already been declared.</summary>
        </member>
        <member name="P:System.SR.Sch_DupAttribute">
            <summary>The '{0}' attribute has already been declared for this ElementType.</summary>
        </member>
        <member name="P:System.SR.Sch_RequireEnumeration">
            <summary>Data type should be enumeration when the values attribute is present.</summary>
        </member>
        <member name="P:System.SR.Sch_DefaultIdValue">
            <summary>An attribute or element of type xs:ID or derived from xs:ID, should not have a value constraint.</summary>
        </member>
        <member name="P:System.SR.Sch_ElementNotAllowed">
            <summary>Element is not allowed when the content is empty or textOnly.</summary>
        </member>
        <member name="P:System.SR.Sch_ElementMissing">
            <summary>There is a missing element.</summary>
        </member>
        <member name="P:System.SR.Sch_ManyMaxOccurs">
            <summary>When the order is many, the maxOccurs attribute must have a value of '*'.</summary>
        </member>
        <member name="P:System.SR.Sch_MaxOccursInvalid">
            <summary>The maxOccurs attribute must have a value of 1 or *.</summary>
        </member>
        <member name="P:System.SR.Sch_MinOccursInvalid">
            <summary>The minOccurs attribute must have a value of 0 or 1.</summary>
        </member>
        <member name="P:System.SR.Sch_DtMaxLengthInvalid">
            <summary>The value '{0}' is invalid for dt:maxLength.</summary>
        </member>
        <member name="P:System.SR.Sch_DtMinLengthInvalid">
            <summary>The value '{0}' is invalid for dt:minLength.</summary>
        </member>
        <member name="P:System.SR.Sch_DupDtMaxLength">
            <summary>The value of maxLength has already been declared.</summary>
        </member>
        <member name="P:System.SR.Sch_DupDtMinLength">
            <summary>The value of minLength has already been declared.</summary>
        </member>
        <member name="P:System.SR.Sch_DtMinMaxLength">
            <summary>The maxLength value must be equal to or greater than the minLength value.</summary>
        </member>
        <member name="P:System.SR.Sch_DupElement">
            <summary>The '{0}' element already exists in the content model.</summary>
        </member>
        <member name="P:System.SR.Sch_DupGroupParticle">
            <summary>The content model can only have one of the following; 'all', 'choice', or 'sequence'.</summary>
        </member>
        <member name="P:System.SR.Sch_InvalidValue">
            <summary>The value '{0}' is invalid according to its data type.</summary>
        </member>
        <member name="P:System.SR.Sch_InvalidValueDetailed">
            <summary>The value '{0}' is invalid according to its schema type '{1}' - {2}</summary>
        </member>
        <member name="P:System.SR.Sch_InvalidValueDetailedAttribute">
            <summary>The attribute '{0}' has an invalid value '{1}' according to its schema type '{2}' - {3}</summary>
        </member>
        <member name="P:System.SR.Sch_MissRequiredAttribute">
            <summary>The required attribute '{0}' is missing.</summary>
        </member>
        <member name="P:System.SR.Sch_FixedAttributeValue">
            <summary>The value of the '{0}' attribute does not equal its fixed value.</summary>
        </member>
        <member name="P:System.SR.Sch_FixedElementValue">
            <summary>The value of the '{0}' element does not equal its fixed value.</summary>
        </member>
        <member name="P:System.SR.Sch_AttributeValueDataTypeDetailed">
            <summary>The '{0}' attribute is invalid - The value '{1}' is invalid according to its datatype '{2}' - {3}</summary>
        </member>
        <member name="P:System.SR.Sch_AttributeDefaultDataType">
            <summary>The default value of '{0}' attribute is invalid according to its datatype.</summary>
        </member>
        <member name="P:System.SR.Sch_IncludeLocation">
            <summary>The 'include' element cannot appear at this location.</summary>
        </member>
        <member name="P:System.SR.Sch_ImportLocation">
            <summary>The 'import' element cannot appear at this location.</summary>
        </member>
        <member name="P:System.SR.Sch_RedefineLocation">
            <summary>The 'redefine' element cannot appear at this location.</summary>
        </member>
        <member name="P:System.SR.Sch_InvalidBlockDefaultValue">
            <summary>The values 'list' and 'union' are invalid for the blockDefault attribute.</summary>
        </member>
        <member name="P:System.SR.Sch_InvalidFinalDefaultValue">
            <summary>The value 'substitution' is invalid for the finalDefault attribute.</summary>
        </member>
        <member name="P:System.SR.Sch_InvalidElementBlockValue">
            <summary>The values 'list' and 'union' are invalid for the block attribute on element.</summary>
        </member>
        <member name="P:System.SR.Sch_InvalidElementFinalValue">
            <summary>The values 'substitution', 'list', and 'union' are invalid for the final attribute on element.</summary>
        </member>
        <member name="P:System.SR.Sch_InvalidSimpleTypeFinalValue">
            <summary>The values 'substitution' and 'extension' are invalid for the final attribute on simpleType.</summary>
        </member>
        <member name="P:System.SR.Sch_InvalidComplexTypeBlockValue">
            <summary>The values 'substitution', 'list', and 'union' are invalid for the block attribute on complexType.</summary>
        </member>
        <member name="P:System.SR.Sch_InvalidComplexTypeFinalValue">
            <summary>The values 'substitution', 'list', and 'union' are invalid for the final attribute on complexType.</summary>
        </member>
        <member name="P:System.SR.Sch_DupIdentityConstraint">
            <summary>The identity constraint '{0}' has already been declared.</summary>
        </member>
        <member name="P:System.SR.Sch_DupGlobalElement">
            <summary>The global element '{0}' has already been declared.</summary>
        </member>
        <member name="P:System.SR.Sch_DupGlobalAttribute">
            <summary>The global attribute '{0}' has already been declared.</summary>
        </member>
        <member name="P:System.SR.Sch_DupSimpleType">
            <summary>The simpleType '{0}' has already been declared.</summary>
        </member>
        <member name="P:System.SR.Sch_DupComplexType">
            <summary>The complexType '{0}' has already been declared.</summary>
        </member>
        <member name="P:System.SR.Sch_DupGroup">
            <summary>The group '{0}' has already been declared.</summary>
        </member>
        <member name="P:System.SR.Sch_DupAttributeGroup">
            <summary>The attributeGroup '{0}' has already been declared.</summary>
        </member>
        <member name="P:System.SR.Sch_DupNotation">
            <summary>The notation '{0}' has already been declared.</summary>
        </member>
        <member name="P:System.SR.Sch_DefaultFixedAttributes">
            <summary>The fixed and default attributes cannot both be present.</summary>
        </member>
        <member name="P:System.SR.Sch_FixedInRef">
            <summary>The fixed value constraint on the '{0}' attribute reference must match the fixed value constraint on the declaration.</summary>
        </member>
        <member name="P:System.SR.Sch_FixedDefaultInRef">
            <summary>The default value constraint cannot be present on the '{0}' attribute reference if the fixed value constraint is present on the declaration.</summary>
        </member>
        <member name="P:System.SR.Sch_DupXsdElement">
            <summary>'{0}' is a duplicate XSD element.</summary>
        </member>
        <member name="P:System.SR.Sch_ForbiddenAttribute">
            <summary>The '{0}' attribute cannot be present.</summary>
        </member>
        <member name="P:System.SR.Sch_AttributeIgnored">
            <summary>The '{0}' attribute is ignored, because the value of 'prohibited' for attribute use only prevents inheritance of an identically named attribute from the base type definition.</summary>
        </member>
        <member name="P:System.SR.Sch_ElementRef">
            <summary>When the ref attribute is present, the type attribute and complexType, simpleType, key, keyref, and unique elements cannot be present.</summary>
        </member>
        <member name="P:System.SR.Sch_TypeMutualExclusive">
            <summary>The type attribute cannot be present with either simpleType or complexType.</summary>
        </member>
        <member name="P:System.SR.Sch_ElementNameRef">
            <summary>For element declaration, either the name or the ref attribute must be present.</summary>
        </member>
        <member name="P:System.SR.Sch_AttributeNameRef">
            <summary>For attribute '{0}', either the name or the ref attribute must be present, but not both.</summary>
        </member>
        <member name="P:System.SR.Sch_TextNotAllowed">
            <summary>The following text is not allowed in this context: '{0}'.</summary>
        </member>
        <member name="P:System.SR.Sch_UndeclaredType">
            <summary>Type '{0}' is not declared.</summary>
        </member>
        <member name="P:System.SR.Sch_UndeclaredSimpleType">
            <summary>Type '{0}' is not declared, or is not a simple type.</summary>
        </member>
        <member name="P:System.SR.Sch_UndeclaredEquivClass">
            <summary>Substitution group refers to '{0}', an undeclared element.</summary>
        </member>
        <member name="P:System.SR.Sch_AttListPresence">
            <summary>An attribute of type ID must have a declared default of either #IMPLIED or #REQUIRED.</summary>
        </member>
        <member name="P:System.SR.Sch_NotationValue">
            <summary>'{0}' is not in the notation list.</summary>
        </member>
        <member name="P:System.SR.Sch_EnumerationValue">
            <summary>'{0}' is not in the enumeration list.</summary>
        </member>
        <member name="P:System.SR.Sch_EmptyAttributeValue">
            <summary>The attribute value cannot be empty.</summary>
        </member>
        <member name="P:System.SR.Sch_InvalidLanguageId">
            <summary>'{0}' is an invalid language identifier.</summary>
        </member>
        <member name="P:System.SR.Sch_XmlSpace">
            <summary>Invalid xml:space syntax.</summary>
        </member>
        <member name="P:System.SR.Sch_InvalidXsdAttributeValue">
            <summary>'{1}' is an invalid value for the '{0}' attribute.</summary>
        </member>
        <member name="P:System.SR.Sch_InvalidXsdAttributeDatatypeValue">
            <summary>The value for the '{0}' attribute is invalid - {1}</summary>
        </member>
        <member name="P:System.SR.Sch_ElementValueDataTypeDetailed">
            <summary>The '{0}' element is invalid - The value '{1}' is invalid according to its datatype '{2}' - {3}</summary>
        </member>
        <member name="P:System.SR.Sch_InvalidElementDefaultValue">
            <summary>The default value '{0}' of element '{1}' is invalid according to the type specified by xsi:type.</summary>
        </member>
        <member name="P:System.SR.Sch_NonDeterministic">
            <summary>Multiple definition of element '{0}' causes the content model to become ambiguous. A content model must be formed such that during validation of an element information item sequence, the particle contained directly, indirectly or implicitly therein with wh ...</summary>
        </member>
        <member name="P:System.SR.Sch_NonDeterministicAnyEx">
            <summary>Wildcard '{0}' allows element '{1}', and causes the content model to become ambiguous. A content model must be formed such that during validation of an element information item sequence, the particle contained directly, indirectly or implicitly therein wit ...</summary>
        </member>
        <member name="P:System.SR.Sch_NonDeterministicAnyAny">
            <summary>Wildcards '{0}' and '{1}' have not empty intersection, and causes the content model to become ambiguous. A content model must be formed such that during validation of an element information item sequence, the particle contained directly, indirectly or impl ...</summary>
        </member>
        <member name="P:System.SR.Sch_StandAlone">
            <summary>The standalone document declaration must have a value of 'no'.</summary>
        </member>
        <member name="P:System.SR.Sch_XmlNsAttribute">
            <summary>The value 'xmlns' cannot be used as the name of an attribute declaration.</summary>
        </member>
        <member name="P:System.SR.Sch_AllElement">
            <summary>Element '{0}' cannot appear more than once if content model type is "all".</summary>
        </member>
        <member name="P:System.SR.Sch_MismatchTargetNamespaceInclude">
            <summary>The targetNamespace '{0}' of included/redefined schema should be the same as the targetNamespace '{1}' of the including schema.</summary>
        </member>
        <member name="P:System.SR.Sch_MismatchTargetNamespaceImport">
            <summary>The namespace attribute '{0}' of an import should be the same value as the targetNamespace '{1}' of the imported schema.</summary>
        </member>
        <member name="P:System.SR.Sch_MismatchTargetNamespaceEx">
            <summary>The targetNamespace parameter '{0}' should be the same value as the targetNamespace '{1}' of the schema.</summary>
        </member>
        <member name="P:System.SR.Sch_XsiTypeNotFound">
            <summary>This is an invalid xsi:type '{0}'.</summary>
        </member>
        <member name="P:System.SR.Sch_XsiTypeAbstract">
            <summary>The xsi:type '{0}' cannot be abstract.</summary>
        </member>
        <member name="P:System.SR.Sch_ListFromNonatomic">
            <summary>A list data type must be derived from an atomic or union data type.</summary>
        </member>
        <member name="P:System.SR.Sch_UnionFromUnion">
            <summary>It is an error if a union type has a member with variety union and this member cannot be substituted with its own members. This may be due to the fact that the union member is a restriction of a union with facets.</summary>
        </member>
        <member name="P:System.SR.Sch_DupLengthFacet">
            <summary>This is a duplicate Length constraining facet.</summary>
        </member>
        <member name="P:System.SR.Sch_DupMinLengthFacet">
            <summary>This is a duplicate MinLength constraining facet.</summary>
        </member>
        <member name="P:System.SR.Sch_DupMaxLengthFacet">
            <summary>This is a duplicate MaxLength constraining facet.</summary>
        </member>
        <member name="P:System.SR.Sch_DupWhiteSpaceFacet">
            <summary>This is a duplicate WhiteSpace constraining facet.</summary>
        </member>
        <member name="P:System.SR.Sch_DupMaxInclusiveFacet">
            <summary>This is a duplicate MaxInclusive constraining facet.</summary>
        </member>
        <member name="P:System.SR.Sch_DupMaxExclusiveFacet">
            <summary>This is a duplicate MaxExclusive constraining facet.</summary>
        </member>
        <member name="P:System.SR.Sch_DupMinInclusiveFacet">
            <summary>This is a duplicate MinInclusive constraining facet.</summary>
        </member>
        <member name="P:System.SR.Sch_DupMinExclusiveFacet">
            <summary>This is a duplicate MinExclusive constraining facet.</summary>
        </member>
        <member name="P:System.SR.Sch_DupTotalDigitsFacet">
            <summary>This is a duplicate TotalDigits constraining facet.</summary>
        </member>
        <member name="P:System.SR.Sch_DupFractionDigitsFacet">
            <summary>This is a duplicate FractionDigits constraining facet.</summary>
        </member>
        <member name="P:System.SR.Sch_LengthFacetProhibited">
            <summary>The length constraining facet is prohibited for '{0}'.</summary>
        </member>
        <member name="P:System.SR.Sch_MinLengthFacetProhibited">
            <summary>The MinLength constraining facet is prohibited for '{0}'.</summary>
        </member>
        <member name="P:System.SR.Sch_MaxLengthFacetProhibited">
            <summary>The MaxLength constraining facet is prohibited for '{0}'.</summary>
        </member>
        <member name="P:System.SR.Sch_PatternFacetProhibited">
            <summary>The Pattern constraining facet is prohibited for '{0}'.</summary>
        </member>
        <member name="P:System.SR.Sch_EnumerationFacetProhibited">
            <summary>The Enumeration constraining facet is prohibited for '{0}'.</summary>
        </member>
        <member name="P:System.SR.Sch_WhiteSpaceFacetProhibited">
            <summary>The WhiteSpace constraining facet is prohibited for '{0}'.</summary>
        </member>
        <member name="P:System.SR.Sch_MaxInclusiveFacetProhibited">
            <summary>The MaxInclusive constraining facet is prohibited for '{0}'.</summary>
        </member>
        <member name="P:System.SR.Sch_MaxExclusiveFacetProhibited">
            <summary>The MaxExclusive constraining facet is prohibited for '{0}'.</summary>
        </member>
        <member name="P:System.SR.Sch_MinInclusiveFacetProhibited">
            <summary>The MinInclusive constraining facet is prohibited for '{0}'.</summary>
        </member>
        <member name="P:System.SR.Sch_MinExclusiveFacetProhibited">
            <summary>The MinExclusive constraining facet is prohibited for '{0}'.</summary>
        </member>
        <member name="P:System.SR.Sch_TotalDigitsFacetProhibited">
            <summary>The TotalDigits constraining facet is prohibited for '{0}'.</summary>
        </member>
        <member name="P:System.SR.Sch_FractionDigitsFacetProhibited">
            <summary>The FractionDigits constraining facet is prohibited for '{0}'.</summary>
        </member>
        <member name="P:System.SR.Sch_LengthFacetInvalid">
            <summary>The Length constraining facet is invalid - {0}</summary>
        </member>
        <member name="P:System.SR.Sch_MinLengthFacetInvalid">
            <summary>The MinLength constraining facet is invalid - {0}</summary>
        </member>
        <member name="P:System.SR.Sch_MaxLengthFacetInvalid">
            <summary>The MaxLength constraining facet is invalid - {0}</summary>
        </member>
        <member name="P:System.SR.Sch_MaxInclusiveFacetInvalid">
            <summary>The MaxInclusive constraining facet is invalid - {0}</summary>
        </member>
        <member name="P:System.SR.Sch_MaxExclusiveFacetInvalid">
            <summary>The MaxExclusive constraining facet is invalid - {0}</summary>
        </member>
        <member name="P:System.SR.Sch_MinInclusiveFacetInvalid">
            <summary>The MinInclusive constraining facet is invalid - {0}</summary>
        </member>
        <member name="P:System.SR.Sch_MinExclusiveFacetInvalid">
            <summary>The MinExclusive constraining facet is invalid - {0}</summary>
        </member>
        <member name="P:System.SR.Sch_TotalDigitsFacetInvalid">
            <summary>The TotalDigits constraining facet is invalid - {0}</summary>
        </member>
        <member name="P:System.SR.Sch_FractionDigitsFacetInvalid">
            <summary>The FractionDigits constraining facet is invalid - {0}</summary>
        </member>
        <member name="P:System.SR.Sch_PatternFacetInvalid">
            <summary>The Pattern constraining facet is invalid - {0}</summary>
        </member>
        <member name="P:System.SR.Sch_EnumerationFacetInvalid">
            <summary>The Enumeration constraining facet is invalid - {0}</summary>
        </member>
        <member name="P:System.SR.Sch_InvalidWhiteSpace">
            <summary>The whitespace character, '{0}', is invalid.</summary>
        </member>
        <member name="P:System.SR.Sch_UnknownFacet">
            <summary>This is an unknown facet.</summary>
        </member>
        <member name="P:System.SR.Sch_LengthAndMinMax">
            <summary>It is an error for both length and minLength or maxLength to be present.</summary>
        </member>
        <member name="P:System.SR.Sch_MinLengthGtMaxLength">
            <summary>minLength is greater than maxLength.</summary>
        </member>
        <member name="P:System.SR.Sch_FractionDigitsGtTotalDigits">
            <summary>FractionDigits is greater than TotalDigits.</summary>
        </member>
        <member name="P:System.SR.Sch_LengthConstraintFailed">
            <summary>The actual length is not equal to the specified length.</summary>
        </member>
        <member name="P:System.SR.Sch_MinLengthConstraintFailed">
            <summary>The actual length is less than the MinLength value.</summary>
        </member>
        <member name="P:System.SR.Sch_MaxLengthConstraintFailed">
            <summary>The actual length is greater than the MaxLength value.</summary>
        </member>
        <member name="P:System.SR.Sch_PatternConstraintFailed">
            <summary>The Pattern constraint failed.</summary>
        </member>
        <member name="P:System.SR.Sch_EnumerationConstraintFailed">
            <summary>The Enumeration constraint failed.</summary>
        </member>
        <member name="P:System.SR.Sch_MaxInclusiveConstraintFailed">
            <summary>The MaxInclusive constraint failed.</summary>
        </member>
        <member name="P:System.SR.Sch_MaxExclusiveConstraintFailed">
            <summary>The MaxExclusive constraint failed.</summary>
        </member>
        <member name="P:System.SR.Sch_MinInclusiveConstraintFailed">
            <summary>The MinInclusive constraint failed.</summary>
        </member>
        <member name="P:System.SR.Sch_MinExclusiveConstraintFailed">
            <summary>The MinExclusive constraint failed.</summary>
        </member>
        <member name="P:System.SR.Sch_TotalDigitsConstraintFailed">
            <summary>The TotalDigits constraint failed.</summary>
        </member>
        <member name="P:System.SR.Sch_FractionDigitsConstraintFailed">
            <summary>The FractionDigits constraint failed.</summary>
        </member>
        <member name="P:System.SR.Sch_UnionFailedEx">
            <summary>The value '{0}' is not valid according to any of the memberTypes of the union.</summary>
        </member>
        <member name="P:System.SR.Sch_NotationRequired">
            <summary>NOTATION cannot be used directly in a schema; only data types derived from NOTATION by specifying an enumeration value can be used in a schema. All enumeration facet values must match the name of a notation declared in the current schema.</summary>
        </member>
        <member name="P:System.SR.Sch_DupNotationAttribute">
            <summary>No element type can have more than one NOTATION attribute specified.</summary>
        </member>
        <member name="P:System.SR.Sch_MissingPublicSystemAttribute">
            <summary>NOTATION must have either the Public or System attribute present.</summary>
        </member>
        <member name="P:System.SR.Sch_NotationAttributeOnEmptyElement">
            <summary>An attribute of type NOTATION must not be declared on an element declared EMPTY.</summary>
        </member>
        <member name="P:System.SR.Sch_RefNotInScope">
            <summary>The Keyref '{0}' cannot find the referred key or unique in scope.</summary>
        </member>
        <member name="P:System.SR.Sch_UndeclaredIdentityConstraint">
            <summary>The '{0}' identity constraint is not declared.</summary>
        </member>
        <member name="P:System.SR.Sch_RefInvalidIdentityConstraint">
            <summary>Reference to an invalid identity constraint, '{0}'.</summary>
        </member>
        <member name="P:System.SR.Sch_RefInvalidCardin">
            <summary>Keyref '{0}' has different cardinality as the referred key or unique element.</summary>
        </member>
        <member name="P:System.SR.Sch_ReftoKeyref">
            <summary>The '{0}' Keyref can refer to key or unique only.</summary>
        </member>
        <member name="P:System.SR.Sch_EmptyXPath">
            <summary>The XPath for selector or field cannot be empty.</summary>
        </member>
        <member name="P:System.SR.Sch_UnresolvedPrefix">
            <summary>The prefix '{0}' in XPath cannot be resolved.</summary>
        </member>
        <member name="P:System.SR.Sch_UnresolvedKeyref">
            <summary>The key sequence '{0}' in '{1}' Keyref fails to refer to some key.</summary>
        </member>
        <member name="P:System.SR.Sch_ICXpathError">
            <summary>'{0}' is an invalid XPath for selector or field.</summary>
        </member>
        <member name="P:System.SR.Sch_SelectorAttr">
            <summary>'{0}' is an invalid XPath for selector. Selector cannot have an XPath selection with an attribute node.</summary>
        </member>
        <member name="P:System.SR.Sch_FieldSimpleTypeExpected">
            <summary>The field '{0}' is expecting an element or attribute with simple type or simple content.</summary>
        </member>
        <member name="P:System.SR.Sch_FieldSingleValueExpected">
            <summary>The field '{0}' is expecting at the most one value.</summary>
        </member>
        <member name="P:System.SR.Sch_MissingKey">
            <summary>The identity constraint '{0}' validation has failed. Either a key is missing or the existing key has an empty node.</summary>
        </member>
        <member name="P:System.SR.Sch_DuplicateKey">
            <summary>There is a duplicate key sequence '{0}' for the '{1}' key or unique identity constraint.</summary>
        </member>
        <member name="P:System.SR.Sch_TargetNamespaceXsi">
            <summary>The target namespace of an attribute declaration, whether local or global, must not match http://www.w3.org/2001/XMLSchema-instance.</summary>
        </member>
        <member name="P:System.SR.Sch_UndeclaredEntity">
            <summary>Reference to an undeclared entity, '{0}'.</summary>
        </member>
        <member name="P:System.SR.Sch_UnparsedEntityRef">
            <summary>Reference to an unparsed entity, '{0}'.</summary>
        </member>
        <member name="P:System.SR.Sch_MaxOccursInvalidXsd">
            <summary>The value for the 'maxOccurs' attribute must be xsd:nonNegativeInteger or 'unbounded'.</summary>
        </member>
        <member name="P:System.SR.Sch_MinOccursInvalidXsd">
            <summary>The value for the 'minOccurs' attribute must be xsd:nonNegativeInteger.</summary>
        </member>
        <member name="P:System.SR.Sch_MaxInclusiveExclusive">
            <summary>'maxInclusive' and 'maxExclusive' cannot both be specified for the same data type.</summary>
        </member>
        <member name="P:System.SR.Sch_MinInclusiveExclusive">
            <summary>'minInclusive' and 'minExclusive' cannot both be specified for the same data type.</summary>
        </member>
        <member name="P:System.SR.Sch_MinInclusiveGtMaxInclusive">
            <summary>The value specified for 'minInclusive' cannot be greater than the value specified for 'maxInclusive' for the same data type.</summary>
        </member>
        <member name="P:System.SR.Sch_MinExclusiveGtMaxExclusive">
            <summary>The value specified for 'minExclusive' cannot be greater than the value specified for 'maxExclusive' for the same data type.</summary>
        </member>
        <member name="P:System.SR.Sch_MinInclusiveGtMaxExclusive">
            <summary>The value specified for 'minInclusive' cannot be greater than the value specified for 'maxExclusive' for the same data type.</summary>
        </member>
        <member name="P:System.SR.Sch_MinExclusiveGtMaxInclusive">
            <summary>The value specified for 'minExclusive' cannot be greater than the value specified for 'maxInclusive' for the same data type.</summary>
        </member>
        <member name="P:System.SR.Sch_SimpleTypeRestriction">
            <summary>'simpleType' should be the first child of restriction.</summary>
        </member>
        <member name="P:System.SR.Sch_InvalidFacetPosition">
            <summary>Facet should go before 'attribute', 'attributeGroup', or 'anyAttribute'.</summary>
        </member>
        <member name="P:System.SR.Sch_AttributeMutuallyExclusive">
            <summary>'{0}' and content model are mutually exclusive.</summary>
        </member>
        <member name="P:System.SR.Sch_AnyAttributeLastChild">
            <summary>'anyAttribute' must be the last child.</summary>
        </member>
        <member name="P:System.SR.Sch_ComplexTypeContentModel">
            <summary>The content model of a complex type must consist of 'annotation' (if present); followed by zero or one of the following: 'simpleContent', 'complexContent', 'group', 'choice', 'sequence', or 'all'; followed by zero or more 'attribute' or 'attributeGroup'; f ...</summary>
        </member>
        <member name="P:System.SR.Sch_ComplexContentContentModel">
            <summary>Complex content restriction or extension should consist of zero or one of 'group', 'choice', 'sequence', or 'all'; followed by zero or more 'attribute' or 'attributeGroup'; followed by zero or one 'anyAttribute'.</summary>
        </member>
        <member name="P:System.SR.Sch_NotNormalizedString">
            <summary>Carriage return (#xD), line feed (#xA), and tab (#x9) characters are not allowed in xs:normalizedString.</summary>
        </member>
        <member name="P:System.SR.Sch_FractionDigitsNotOnDecimal">
            <summary>FractionDigits should be equal to 0 on types other then decimal.</summary>
        </member>
        <member name="P:System.SR.Sch_ContentInNill">
            <summary>Element '{0}' must have no character or element children.</summary>
        </member>
        <member name="P:System.SR.Sch_NoElementSchemaFound">
            <summary>Could not find schema information for the element '{0}'.</summary>
        </member>
        <member name="P:System.SR.Sch_NoAttributeSchemaFound">
            <summary>Could not find schema information for the attribute '{0}'.</summary>
        </member>
        <member name="P:System.SR.Sch_InvalidNamespace">
            <summary>The Namespace '{0}' is an invalid URI.</summary>
        </member>
        <member name="P:System.SR.Sch_InvalidTargetNamespaceAttribute">
            <summary>The targetNamespace attribute cannot have empty string as its value.</summary>
        </member>
        <member name="P:System.SR.Sch_InvalidNamespaceAttribute">
            <summary>The namespace attribute cannot have empty string as its value.</summary>
        </member>
        <member name="P:System.SR.Sch_InvalidSchemaLocation">
            <summary>The SchemaLocation '{0}' is an invalid URI.</summary>
        </member>
        <member name="P:System.SR.Sch_ImportTargetNamespace">
            <summary>Namespace attribute of an import must not match the real value of the enclosing targetNamespace of the &lt;schema&gt;.</summary>
        </member>
        <member name="P:System.SR.Sch_ImportTargetNamespaceNull">
            <summary>The enclosing &lt;schema&gt; must have a targetNamespace, if the Namespace attribute is absent on the import element.</summary>
        </member>
        <member name="P:System.SR.Sch_GroupDoubleRedefine">
            <summary>Double redefine for group.</summary>
        </member>
        <member name="P:System.SR.Sch_ComponentRedefineNotFound">
            <summary>Cannot find a {0} with name '{1}' to redefine.</summary>
        </member>
        <member name="P:System.SR.Sch_GroupRedefineNotFound">
            <summary>No group to redefine.</summary>
        </member>
        <member name="P:System.SR.Sch_AttrGroupDoubleRedefine">
            <summary>Double redefine for attribute group.</summary>
        </member>
        <member name="P:System.SR.Sch_AttrGroupRedefineNotFound">
            <summary>No attribute group to redefine.</summary>
        </member>
        <member name="P:System.SR.Sch_ComplexTypeDoubleRedefine">
            <summary>Double redefine for complex type.</summary>
        </member>
        <member name="P:System.SR.Sch_ComplexTypeRedefineNotFound">
            <summary>No complex type to redefine.</summary>
        </member>
        <member name="P:System.SR.Sch_SimpleToComplexTypeRedefine">
            <summary>Cannot redefine a simple type as complex type.</summary>
        </member>
        <member name="P:System.SR.Sch_SimpleTypeDoubleRedefine">
            <summary>Double redefine for simple type.</summary>
        </member>
        <member name="P:System.SR.Sch_ComplexToSimpleTypeRedefine">
            <summary>Cannot redefine a complex type as simple type.</summary>
        </member>
        <member name="P:System.SR.Sch_SimpleTypeRedefineNotFound">
            <summary>No simple type to redefine.</summary>
        </member>
        <member name="P:System.SR.Sch_MinMaxGroupRedefine">
            <summary>When group is redefined, the real value of both minOccurs and maxOccurs attribute must be 1 (or absent).</summary>
        </member>
        <member name="P:System.SR.Sch_MultipleGroupSelfRef">
            <summary>Multiple self-reference within a group is redefined.</summary>
        </member>
        <member name="P:System.SR.Sch_MultipleAttrGroupSelfRef">
            <summary>Multiple self-reference within an attribute group is redefined.</summary>
        </member>
        <member name="P:System.SR.Sch_InvalidTypeRedefine">
            <summary>If type is being redefined, the base type has to be self-referenced.</summary>
        </member>
        <member name="P:System.SR.Sch_InvalidElementRef">
            <summary>If ref is present, all of &lt;complexType&gt;, &lt;simpleType&gt;, &lt;key&gt;, &lt;keyref&gt;, &lt;unique&gt;, nillable, default, fixed, form, block, and type must be absent.</summary>
        </member>
        <member name="P:System.SR.Sch_MinGtMax">
            <summary>minOccurs value cannot be greater than maxOccurs value.</summary>
        </member>
        <member name="P:System.SR.Sch_DupSelector">
            <summary>Selector cannot appear twice in one identity constraint.</summary>
        </member>
        <member name="P:System.SR.Sch_IdConstraintNoSelector">
            <summary>Selector must be present.</summary>
        </member>
        <member name="P:System.SR.Sch_IdConstraintNoFields">
            <summary>At least one field must be present.</summary>
        </member>
        <member name="P:System.SR.Sch_IdConstraintNoRefer">
            <summary>The referring attribute must be present.</summary>
        </member>
        <member name="P:System.SR.Sch_SelectorBeforeFields">
            <summary>Cannot define fields before selector.</summary>
        </member>
        <member name="P:System.SR.Sch_NoSimpleTypeContent">
            <summary>SimpleType content is missing.</summary>
        </member>
        <member name="P:System.SR.Sch_SimpleTypeRestRefBase">
            <summary>SimpleType restriction should have either the base attribute or a simpleType child, but not both.</summary>
        </member>
        <member name="P:System.SR.Sch_SimpleTypeRestRefBaseNone">
            <summary>SimpleType restriction should have either the base attribute or a simpleType child to indicate the base type for the derivation.</summary>
        </member>
        <member name="P:System.SR.Sch_SimpleTypeListRefBase">
            <summary>SimpleType list should have either the itemType attribute or a simpleType child, but not both.</summary>
        </member>
        <member name="P:System.SR.Sch_SimpleTypeListRefBaseNone">
            <summary>SimpleType list should have either the itemType attribute or a simpleType child to indicate the itemType of the list.</summary>
        </member>
        <member name="P:System.SR.Sch_SimpleTypeUnionNoBase">
            <summary>Either the memberTypes attribute must be non-empty or there must be at least one simpleType child.</summary>
        </member>
        <member name="P:System.SR.Sch_NoRestOrExtQName">
            <summary>'restriction' or 'extension' child is required for complexType '{0}' in namespace '{1}', because it has a simpleContent or complexContent child.</summary>
        </member>
        <member name="P:System.SR.Sch_NoRestOrExt">
            <summary>'restriction' or 'extension' child is required for complexType with simpleContent or complexContent child.</summary>
        </member>
        <member name="P:System.SR.Sch_NoGroupParticle">
            <summary>'sequence', 'choice', or 'all' child is required.</summary>
        </member>
        <member name="P:System.SR.Sch_InvalidAllMin">
            <summary>'all' must have 'minOccurs' value of 0 or 1.</summary>
        </member>
        <member name="P:System.SR.Sch_InvalidAllMax">
            <summary>'all' must have a 'maxOccurs' value of 1.</summary>
        </member>
        <member name="P:System.SR.Sch_InvalidFacet">
            <summary>The 'value' attribute must be present in facet.</summary>
        </member>
        <member name="P:System.SR.Sch_AbstractElement">
            <summary>The element '{0}' is abstract or its type is abstract.</summary>
        </member>
        <member name="P:System.SR.Sch_XsiTypeBlockedEx">
            <summary>The xsi:type attribute value '{0}' is not valid for the element '{1}', either because it is not a type validly derived from the type in the schema, or because it has xsi:type derivation blocked.</summary>
        </member>
        <member name="P:System.SR.Sch_InvalidXsiNill">
            <summary>If the 'nillable' attribute is false in the schema, the 'xsi:nil' attribute must not be present in the instance.</summary>
        </member>
        <member name="P:System.SR.Sch_SubstitutionNotAllowed">
            <summary>Element '{0}' cannot substitute in place of head element '{1}' because it has block='substitution'.</summary>
        </member>
        <member name="P:System.SR.Sch_SubstitutionBlocked">
            <summary>Member element {0}'s type cannot be derived by restriction or extension from head element {1}'s type, because it has block='restriction' or 'extension'.</summary>
        </member>
        <member name="P:System.SR.Sch_InvalidElementInEmptyEx">
            <summary>The element '{0}' cannot contain child element '{1}' because the parent element's content model is empty.</summary>
        </member>
        <member name="P:System.SR.Sch_InvalidElementInTextOnlyEx">
            <summary>The element '{0}' cannot contain child element '{1}' because the parent element's content model is text only.</summary>
        </member>
        <member name="P:System.SR.Sch_InvalidTextInElement">
            <summary>The element {0} cannot contain text.</summary>
        </member>
        <member name="P:System.SR.Sch_InvalidElementContent">
            <summary>The element {0} has invalid child element {1}.</summary>
        </member>
        <member name="P:System.SR.Sch_InvalidElementContentComplex">
            <summary>The element {0} has invalid child element {1} - {2}</summary>
        </member>
        <member name="P:System.SR.Sch_IncompleteContent">
            <summary>The element {0} has incomplete content.</summary>
        </member>
        <member name="P:System.SR.Sch_IncompleteContentComplex">
            <summary>The element {0} has incomplete content - {2}</summary>
        </member>
        <member name="P:System.SR.Sch_InvalidTextInElementExpecting">
            <summary>The element {0} cannot contain text. List of possible elements expected: {1}.</summary>
        </member>
        <member name="P:System.SR.Sch_InvalidElementContentExpecting">
            <summary>The element {0} has invalid child element {1}. List of possible elements expected: {2}.</summary>
        </member>
        <member name="P:System.SR.Sch_InvalidElementContentExpectingComplex">
            <summary>The element {0} has invalid child element {1}. List of possible elements expected: {2}. {3}</summary>
        </member>
        <member name="P:System.SR.Sch_IncompleteContentExpecting">
            <summary>The element {0} has incomplete content. List of possible elements expected: {1}.</summary>
        </member>
        <member name="P:System.SR.Sch_IncompleteContentExpectingComplex">
            <summary>The element {0} has incomplete content. List of possible elements expected: {1}. {2}</summary>
        </member>
        <member name="P:System.SR.Sch_InvalidElementSubstitution">
            <summary>The element {0} cannot substitute for a local element {1} expected in that position.</summary>
        </member>
        <member name="P:System.SR.Sch_ElementNameAndNamespace">
            <summary>'{0}' in namespace '{1}'</summary>
        </member>
        <member name="P:System.SR.Sch_ElementName">
            <summary>'{0}'</summary>
        </member>
        <member name="P:System.SR.Sch_ContinuationString">
            <summary>{0}as well as</summary>
        </member>
        <member name="P:System.SR.Sch_AnyElementNS">
            <summary>any element in namespace '{0}'</summary>
        </member>
        <member name="P:System.SR.Sch_AnyElement">
            <summary>any element</summary>
        </member>
        <member name="P:System.SR.Sch_InvalidTextInEmpty">
            <summary>The element cannot contain text. Content model is empty.</summary>
        </member>
        <member name="P:System.SR.Sch_InvalidWhitespaceInEmpty">
            <summary>The element cannot contain whitespace. Content model is empty.</summary>
        </member>
        <member name="P:System.SR.Sch_InvalidPIComment">
            <summary>The element cannot contain comment or processing instruction. Content model is empty.</summary>
        </member>
        <member name="P:System.SR.Sch_InvalidAttributeRef">
            <summary>If ref is present, all of 'simpleType', 'form', 'type', and 'use' must be absent.</summary>
        </member>
        <member name="P:System.SR.Sch_OptionalDefaultAttribute">
            <summary>The 'use' attribute must be optional (or absent) if the default attribute is present.</summary>
        </member>
        <member name="P:System.SR.Sch_AttributeCircularRef">
            <summary>Circular attribute reference.</summary>
        </member>
        <member name="P:System.SR.Sch_IdentityConstraintCircularRef">
            <summary>Circular identity constraint reference.</summary>
        </member>
        <member name="P:System.SR.Sch_SubstitutionCircularRef">
            <summary>Circular substitution group affiliation.</summary>
        </member>
        <member name="P:System.SR.Sch_InvalidAnyAttribute">
            <summary>Invalid namespace in 'anyAttribute'.</summary>
        </member>
        <member name="P:System.SR.Sch_DupIdAttribute">
            <summary>Duplicate ID attribute.</summary>
        </member>
        <member name="P:System.SR.Sch_InvalidAllElementMax">
            <summary>The 'maxOccurs' attribute of all the particles of an 'all' group must be 0 or 1.</summary>
        </member>
        <member name="P:System.SR.Sch_InvalidAny">
            <summary>Invalid namespace in 'any'.</summary>
        </member>
        <member name="P:System.SR.Sch_InvalidAnyDetailed">
            <summary>The value of the namespace attribute of the element or attribute wildcard is invalid - {0}</summary>
        </member>
        <member name="P:System.SR.Sch_InvalidExamplar">
            <summary>Element '{0}' cannot be nominated as the 'substitutionGroup' of any other declaration.</summary>
        </member>
        <member name="P:System.SR.Sch_NoExamplar">
            <summary>Reference to undeclared substitution group affiliation.</summary>
        </member>
        <member name="P:System.SR.Sch_InvalidSubstitutionMember">
            <summary>'{0}' cannot be a member of substitution group with head element '{1}'.</summary>
        </member>
        <member name="P:System.SR.Sch_RedefineNoSchema">
            <summary>'SchemaLocation' must successfully resolve if &lt;redefine&gt; contains any child other than &lt;annotation&gt;.</summary>
        </member>
        <member name="P:System.SR.Sch_ProhibitedAttribute">
            <summary>The '{0}' attribute is not allowed.</summary>
        </member>
        <member name="P:System.SR.Sch_TypeCircularRef">
            <summary>Circular type reference.</summary>
        </member>
        <member name="P:System.SR.Sch_TwoIdAttrUses">
            <summary>Two distinct members of the attribute uses must not have type definitions which are both xs:ID or are derived from xs:ID.</summary>
        </member>
        <member name="P:System.SR.Sch_AttrUseAndWildId">
            <summary>It is an error if there is a member of the attribute uses of a type definition with type xs:ID or derived from xs:ID and another attribute with type xs:ID matches an attribute wildcard.</summary>
        </member>
        <member name="P:System.SR.Sch_MoreThanOneWildId">
            <summary>It is an error if more than one attribute whose type is xs:ID or is derived from xs:ID, matches an attribute wildcard on an element.</summary>
        </member>
        <member name="P:System.SR.Sch_BaseFinalExtension">
            <summary>The base type is the final extension.</summary>
        </member>
        <member name="P:System.SR.Sch_NotSimpleContent">
            <summary>The content type of the base type must be a simple type definition or it must be mixed, and simpleType child must be present.</summary>
        </member>
        <member name="P:System.SR.Sch_NotComplexContent">
            <summary>The content type of the base type must not be a simple type definition.</summary>
        </member>
        <member name="P:System.SR.Sch_BaseFinalRestriction">
            <summary>The base type is final restriction.</summary>
        </member>
        <member name="P:System.SR.Sch_BaseFinalList">
            <summary>The base type is the final list.</summary>
        </member>
        <member name="P:System.SR.Sch_BaseFinalUnion">
            <summary>The base type is the final union.</summary>
        </member>
        <member name="P:System.SR.Sch_UndefBaseRestriction">
            <summary>Undefined complexType '{0}' is used as a base for complex type restriction.</summary>
        </member>
        <member name="P:System.SR.Sch_UndefBaseExtension">
            <summary>Undefined complexType '{0}' is used as a base for complex type extension.</summary>
        </member>
        <member name="P:System.SR.Sch_DifContentType">
            <summary>The derived type and the base type must have the same content type.</summary>
        </member>
        <member name="P:System.SR.Sch_InvalidContentRestriction">
            <summary>Invalid content type derivation by restriction.</summary>
        </member>
        <member name="P:System.SR.Sch_InvalidContentRestrictionDetailed">
            <summary>Invalid content type derivation by restriction. {0}</summary>
        </member>
        <member name="P:System.SR.Sch_InvalidBaseToEmpty">
            <summary>If the derived content type is Empty, then the base content type should also be Empty or Mixed with Emptiable particle according to rule 5.3 of Schema Component Constraint: Derivation Valid (Restriction, Complex).</summary>
        </member>
        <member name="P:System.SR.Sch_InvalidBaseToMixed">
            <summary>If the derived content type is Mixed, then the base content type should also be Mixed according to rule 5.4 of Schema Component Constraint: Derivation Valid (Restriction, Complex).</summary>
        </member>
        <member name="P:System.SR.Sch_DupAttributeUse">
            <summary>The attribute '{0}' already exists.</summary>
        </member>
        <member name="P:System.SR.Sch_InvalidParticleRestriction">
            <summary>Invalid particle derivation by restriction.</summary>
        </member>
        <member name="P:System.SR.Sch_InvalidParticleRestrictionDetailed">
            <summary>Invalid particle derivation by restriction - '{0}'.</summary>
        </member>
        <member name="P:System.SR.Sch_ForbiddenDerivedParticleForAll">
            <summary>'Choice' or 'any' is forbidden as derived particle when the base particle is 'all'.</summary>
        </member>
        <member name="P:System.SR.Sch_ForbiddenDerivedParticleForElem">
            <summary>Only 'element' is valid as derived particle when the base particle is 'element'.</summary>
        </member>
        <member name="P:System.SR.Sch_ForbiddenDerivedParticleForChoice">
            <summary>'All' or 'any' is forbidden as derived particle when the base particle is 'choice'.</summary>
        </member>
        <member name="P:System.SR.Sch_ForbiddenDerivedParticleForSeq">
            <summary>'All', 'any', and 'choice' are forbidden as derived particles when the base particle is 'sequence'.</summary>
        </member>
        <member name="P:System.SR.Sch_ElementFromElement">
            <summary>Derived element '{0}' is not a valid restriction of base element '{1}' according to Elt:Elt -- NameAndTypeOK.</summary>
        </member>
        <member name="P:System.SR.Sch_ElementFromAnyRule1">
            <summary>The namespace of element '{0}'is not valid with respect to the wildcard's namespace constraint in the base, Elt:Any -- NSCompat Rule 1.</summary>
        </member>
        <member name="P:System.SR.Sch_ElementFromAnyRule2">
            <summary>The occurrence range of element '{0}'is not a valid restriction of the wildcard's occurrence range in the base, Elt:Any -- NSCompat Rule2.</summary>
        </member>
        <member name="P:System.SR.Sch_AnyFromAnyRule1">
            <summary>The derived wildcard's occurrence range is not a valid restriction of the base wildcard's occurrence range, Any:Any -- NSSubset Rule 1.</summary>
        </member>
        <member name="P:System.SR.Sch_AnyFromAnyRule2">
            <summary>The derived wildcard's namespace constraint must be an intensional subset of the base wildcard's namespace constraint, Any:Any -- NSSubset Rule2.</summary>
        </member>
        <member name="P:System.SR.Sch_AnyFromAnyRule3">
            <summary>The derived wildcard's 'processContents' must be identical to or stronger than the base wildcard's 'processContents', where 'strict' is stronger than 'lax' and 'lax' is stronger than 'skip', Any:Any -- NSSubset Rule 3.</summary>
        </member>
        <member name="P:System.SR.Sch_GroupBaseFromAny1">
            <summary>Every member of the derived group particle must be a valid restriction of the base wildcard, NSRecurseCheckCardinality Rule 1.</summary>
        </member>
        <member name="P:System.SR.Sch_GroupBaseFromAny2">
            <summary>The derived particle's occurrence range at ({0}, {1}) is not a valid restriction of the base wildcard's occurrence range at ({2}, {3}), NSRecurseCheckCardinality Rule 2.</summary>
        </member>
        <member name="P:System.SR.Sch_ElementFromGroupBase1">
            <summary>The derived element {0} at ({1}, {2}) is not a valid restriction of the base sequence particle at ({3}, {4}) according to Elt:All/Choice/Sequence -- RecurseAsIfGroup.</summary>
        </member>
        <member name="P:System.SR.Sch_ElementFromGroupBase2">
            <summary>The derived element {0} at ({1}, {2}) is not a valid restriction of the base choice particle at ({3}, {4}) according to Elt:All/Choice/Sequence -- RecurseAsIfGroup.</summary>
        </member>
        <member name="P:System.SR.Sch_ElementFromGroupBase3">
            <summary>The derived element {0} at ({1}, {2}) is not a valid restriction of the base all particle at ({3}, {4}) according to Elt:All/Choice/Sequence -- RecurseAsIfGroup.</summary>
        </member>
        <member name="P:System.SR.Sch_GroupBaseRestRangeInvalid">
            <summary>The derived particle's range is not a valid restriction of the base particle's range according to All:All,Sequence:Sequence -- Recurse Rule 1 or Choice:Choice -- RecurseLax.</summary>
        </member>
        <member name="P:System.SR.Sch_GroupBaseRestNoMap">
            <summary>The derived particle cannot have more members than the base particle - All:All,Sequence:Sequence -- Recurse Rule 2 / Choice:Choice -- RecurseLax.</summary>
        </member>
        <member name="P:System.SR.Sch_GroupBaseRestNotEmptiable">
            <summary>All particles in the particles of the base particle which are not mapped to by any particle in the particles of the derived particle should be emptiable - All:All,Sequence:Sequence -- Recurse Rule 2 / Choice:Choice -- RecurseLax.</summary>
        </member>
        <member name="P:System.SR.Sch_SeqFromAll">
            <summary>The derived sequence particle at ({0}, {1}) is not a valid restriction of the base all particle at ({2}, {3}) according to Sequence:All -- RecurseUnordered.</summary>
        </member>
        <member name="P:System.SR.Sch_SeqFromChoice">
            <summary>The derived sequence particle at ({0}, {1}) is not a valid restriction of the base choice particle at ({2}, {3}) according to Sequence:Choice -- MapAndSum.</summary>
        </member>
        <member name="P:System.SR.Sch_UndefGroupRef">
            <summary>Reference to undeclared model group '{0}'.</summary>
        </member>
        <member name="P:System.SR.Sch_GroupCircularRef">
            <summary>Circular group reference.</summary>
        </member>
        <member name="P:System.SR.Sch_AllRefNotRoot">
            <summary>The group ref to 'all' is not the root particle, or it is being used as an extension.</summary>
        </member>
        <member name="P:System.SR.Sch_AllRefMinMax">
            <summary>The group ref to 'all' must have 'minOccurs' = 0 or 1 and 'maxOccurs' = 1.</summary>
        </member>
        <member name="P:System.SR.Sch_NotAllAlone">
            <summary>'all' is not the only particle in a group, or is being used as an extension.</summary>
        </member>
        <member name="P:System.SR.Sch_AttributeGroupCircularRef">
            <summary>Circular attribute group reference.</summary>
        </member>
        <member name="P:System.SR.Sch_UndefAttributeGroupRef">
            <summary>Reference to undeclared attribute group '{0}'.</summary>
        </member>
        <member name="P:System.SR.Sch_InvalidAttributeExtension">
            <summary>Invalid attribute extension.</summary>
        </member>
        <member name="P:System.SR.Sch_InvalidAnyAttributeRestriction">
            <summary>The base any attribute must be a superset of the derived 'anyAttribute'.</summary>
        </member>
        <member name="P:System.SR.Sch_AttributeRestrictionProhibited">
            <summary>Invalid attribute restriction. Attribute restriction is prohibited in base type.</summary>
        </member>
        <member name="P:System.SR.Sch_AttributeRestrictionInvalid">
            <summary>Invalid attribute restriction. Derived attribute's type is not a valid restriction of the base attribute's type.</summary>
        </member>
        <member name="P:System.SR.Sch_AttributeFixedInvalid">
            <summary>Invalid attribute restriction. Derived attribute's fixed value must be the same as the base attribute's fixed value.</summary>
        </member>
        <member name="P:System.SR.Sch_AttributeUseInvalid">
            <summary>Derived attribute's use has to be required if base attribute's use is required.</summary>
        </member>
        <member name="P:System.SR.Sch_AttributeRestrictionInvalidFromWildcard">
            <summary>The base type definition must have an attribute wildcard and the target namespace of the attribute declaration in the 'redefine' must be valid with respect to that wildcard.</summary>
        </member>
        <member name="P:System.SR.Sch_NoDerivedAttribute">
            <summary>The base attribute '{0}' whose use = 'required' does not have a corresponding derived attribute while redefining attribute group '{1}'.</summary>
        </member>
        <member name="P:System.SR.Sch_UnexpressibleAnyAttribute">
            <summary>The 'anyAttribute' is not expressible.</summary>
        </member>
        <member name="P:System.SR.Sch_RefInvalidAttribute">
            <summary>Reference to invalid attribute '{0}'.</summary>
        </member>
        <member name="P:System.SR.Sch_ElementCircularRef">
            <summary>Circular element reference.</summary>
        </member>
        <member name="P:System.SR.Sch_RefInvalidElement">
            <summary>Reference to invalid element '{0}'.</summary>
        </member>
        <member name="P:System.SR.Sch_ElementCannotHaveValue">
            <summary>Element's type does not allow fixed or default value constraint.</summary>
        </member>
        <member name="P:System.SR.Sch_ElementInMixedWithFixed">
            <summary>Although the '{0}' element's content type is mixed, it cannot have element children, because it has a fixed value constraint in the schema.</summary>
        </member>
        <member name="P:System.SR.Sch_ElementTypeCollision">
            <summary>Elements with the same name and in the same scope must have the same type.</summary>
        </member>
        <member name="P:System.SR.Sch_InvalidIncludeLocation">
            <summary>Cannot resolve the 'schemaLocation' attribute.</summary>
        </member>
        <member name="P:System.SR.Sch_CannotLoadSchema">
            <summary>Cannot load the schema for the namespace '{0}' - {1}</summary>
        </member>
        <member name="P:System.SR.Sch_CannotLoadSchemaLocation">
            <summary>Cannot load the schema from the location '{0}' - {1}</summary>
        </member>
        <member name="P:System.SR.Sch_LengthGtBaseLength">
            <summary>It is an error if 'length' is among the members of the facets of the base type definition and its value is greater than the value of the parent 'length'.</summary>
        </member>
        <member name="P:System.SR.Sch_MinLengthGtBaseMinLength">
            <summary>It is an error if 'minLength' is among the members of the facets of the base type definition and its value is less than the value of the parent 'minLength'.</summary>
        </member>
        <member name="P:System.SR.Sch_MaxLengthGtBaseMaxLength">
            <summary>It is an error if 'maxLength' is among the members of the facets of the base type definition and its value is greater than the value of the parent 'maxLength'.</summary>
        </member>
        <member name="P:System.SR.Sch_MaxMinLengthBaseLength">
            <summary>It is an error for both 'length' and either 'minLength' or 'maxLength' to be members of facets, unless they are specified in different derivation steps. In which case the following must be true: the value of 'minLength' &lt;= the value of 'length' &lt;= the valu ...</summary>
        </member>
        <member name="P:System.SR.Sch_MaxInclusiveMismatch">
            <summary>It is an error if the derived 'maxInclusive' facet value is greater than the parent 'maxInclusive' facet value.</summary>
        </member>
        <member name="P:System.SR.Sch_MaxExclusiveMismatch">
            <summary>It is an error if the derived 'maxExclusive' facet value is greater than the parent 'maxExclusive' facet value.</summary>
        </member>
        <member name="P:System.SR.Sch_MinInclusiveMismatch">
            <summary>It is an error if the derived 'minInclusive' facet value is less than the parent 'minInclusive' facet value.</summary>
        </member>
        <member name="P:System.SR.Sch_MinExclusiveMismatch">
            <summary>It is an error if the derived 'minExclusive' facet value is less than the parent 'minExclusive' facet value.</summary>
        </member>
        <member name="P:System.SR.Sch_MinExlIncMismatch">
            <summary>It is an error if the derived 'minExclusive' facet value is less than or equal to the parent 'minInclusive' facet value.</summary>
        </member>
        <member name="P:System.SR.Sch_MinExlMaxExlMismatch">
            <summary>It is an error if the derived 'minExclusive' facet value is greater than or equal to the parent 'maxExclusive' facet value.</summary>
        </member>
        <member name="P:System.SR.Sch_MinIncMaxExlMismatch">
            <summary>It is an error if the derived 'minInclusive' facet value is greater than or equal to the parent 'maxExclusive' facet value.</summary>
        </member>
        <member name="P:System.SR.Sch_MinIncExlMismatch">
            <summary>It is an error if the derived 'minInclusive' facet value is less than or equal to the parent 'minExclusive' facet value.</summary>
        </member>
        <member name="P:System.SR.Sch_MaxIncExlMismatch">
            <summary>It is an error if the derived 'maxInclusive' facet value is greater than or equal to the parent 'maxExclusive' facet value.</summary>
        </member>
        <member name="P:System.SR.Sch_MaxExlIncMismatch">
            <summary>It is an error if the derived 'maxExclusive' facet value is greater than or equal to the parent 'maxInclusive' facet value.</summary>
        </member>
        <member name="P:System.SR.Sch_TotalDigitsMismatch">
            <summary>It is an error if the derived 'totalDigits' facet value is greater than the parent 'totalDigits' facet value.</summary>
        </member>
        <member name="P:System.SR.Sch_FractionDigitsMismatch">
            <summary>It is an error if the derived 'fractionDigits' facet value is greater than the parent 'fractionDigits' facet value.</summary>
        </member>
        <member name="P:System.SR.Sch_FacetBaseFixed">
            <summary>Values that are declared with fixed='true' in a base type can not be changed in a derived type.</summary>
        </member>
        <member name="P:System.SR.Sch_WhiteSpaceRestriction1">
            <summary>It is an error if 'whiteSpace' is among the facets of the type definition, its value is 'replace' or 'preserve', and the value of the parent 'whiteSpace' is 'collapse'.</summary>
        </member>
        <member name="P:System.SR.Sch_WhiteSpaceRestriction2">
            <summary>It is an error if 'whiteSpace' is among the facets of the type definition, its value is 'preserve', and the value of the parent 'whiteSpace' is 'replace'.</summary>
        </member>
        <member name="P:System.SR.Sch_XsiNilAndFixed">
            <summary>There must be no fixed value when an attribute is 'xsi:nil' and has a value of 'true'.</summary>
        </member>
        <member name="P:System.SR.Sch_MixSchemaTypes">
            <summary>Different schema types cannot be mixed.</summary>
        </member>
        <member name="P:System.SR.Sch_XSDSchemaOnly">
            <summary>'XmlSchemaSet' can load only W3C XML Schemas.</summary>
        </member>
        <member name="P:System.SR.Sch_InvalidPublicAttribute">
            <summary>Public attribute '{0}' is an invalid URI.</summary>
        </member>
        <member name="P:System.SR.Sch_InvalidSystemAttribute">
            <summary>System attribute '{0}' is an invalid URI.</summary>
        </member>
        <member name="P:System.SR.Sch_TypeAfterConstraints">
            <summary>'simpleType' or 'complexType' cannot follow 'unique', 'key' or 'keyref'.</summary>
        </member>
        <member name="P:System.SR.Sch_XsiNilAndType">
            <summary>There can be no type value when attribute is 'xsi:nil' and has value 'true'.</summary>
        </member>
        <member name="P:System.SR.Sch_DupSimpleTypeChild">
            <summary>'simpleType' should have only one child 'union', 'list', or 'restriction'.</summary>
        </member>
        <member name="P:System.SR.Sch_InvalidIdAttribute">
            <summary>Invalid 'id' attribute value: {0}</summary>
        </member>
        <member name="P:System.SR.Sch_InvalidNameAttributeEx">
            <summary>Invalid 'name' attribute value '{0}': '{1}'.</summary>
        </member>
        <member name="P:System.SR.Sch_InvalidAttribute">
            <summary>Invalid '{0}' attribute: '{1}'.</summary>
        </member>
        <member name="P:System.SR.Sch_EmptyChoice">
            <summary>Empty choice cannot be satisfied if 'minOccurs' is not equal to 0.</summary>
        </member>
        <member name="P:System.SR.Sch_DerivedNotFromBase">
            <summary>The data type of the simple content is not a valid restriction of the base complex type.</summary>
        </member>
        <member name="P:System.SR.Sch_NeedSimpleTypeChild">
            <summary>Simple content restriction must have a simple type child if the content type of the base type is not a simple type definition.</summary>
        </member>
        <member name="P:System.SR.Sch_InvalidCollection">
            <summary>The schema items collection cannot contain an object of type 'XmlSchemaInclude', 'XmlSchemaImport', or 'XmlSchemaRedefine'.</summary>
        </member>
        <member name="P:System.SR.Sch_UnrefNS">
            <summary>Namespace '{0}' is not available to be referenced in this schema.</summary>
        </member>
        <member name="P:System.SR.Sch_InvalidSimpleTypeRestriction">
            <summary>Restriction of 'anySimpleType' is not allowed.</summary>
        </member>
        <member name="P:System.SR.Sch_MultipleRedefine">
            <summary>Multiple redefines of the same schema will be ignored.</summary>
        </member>
        <member name="P:System.SR.Sch_NullValue">
            <summary>Value cannot be null.</summary>
        </member>
        <member name="P:System.SR.Sch_ComplexContentModel">
            <summary>Content model validation resulted in a large number of states, possibly due to large occurrence ranges. Therefore, content model may not be validated accurately.</summary>
        </member>
        <member name="P:System.SR.Sch_SchemaNotPreprocessed">
            <summary>All schemas in the set should be successfully preprocessed prior to compilation.</summary>
        </member>
        <member name="P:System.SR.Sch_SchemaNotRemoved">
            <summary>The schema could not be removed because other schemas in the set have dependencies on this schema or its imports.</summary>
        </member>
        <member name="P:System.SR.Sch_ComponentAlreadySeenForNS">
            <summary>An element or attribute information item has already been validated from the '{0}' namespace. It is an error if 'xsi:schemaLocation', 'xsi:noNamespaceSchemaLocation', or an inline schema occurs for that namespace.</summary>
        </member>
        <member name="P:System.SR.Sch_DefaultAttributeNotApplied">
            <summary>Default attribute '{0}' for element '{1}' could not be applied as the attribute namespace is not mapped to a prefix in the instance document.</summary>
        </member>
        <member name="P:System.SR.Sch_NotXsiAttribute">
            <summary>The attribute '{0}' does not match one of the four allowed attributes in the 'xsi' namespace.</summary>
        </member>
        <member name="P:System.SR.Sch_SchemaDoesNotExist">
            <summary>Schema does not exist in the set.</summary>
        </member>
        <member name="P:System.SR.XmlDocument_ValidateInvalidNodeType">
            <summary>Validate method can be called only on nodes of type Document, DocumentFragment, Element, or Attribute.</summary>
        </member>
        <member name="P:System.SR.XmlDocument_NodeNotFromDocument">
            <summary>Cannot validate '{0}' because its owner document is not the current document.</summary>
        </member>
        <member name="P:System.SR.XmlDocument_NoNodeSchemaInfo">
            <summary>Schema information could not be found for the node passed into Validate. The node may be invalid in its current position. Navigate to the ancestor that has schema information, then call Validate again.</summary>
        </member>
        <member name="P:System.SR.XmlDocument_NoSchemaInfo">
            <summary>The XmlSchemaSet on the document is either null or has no schemas in it. Provide schema information before calling Validate.</summary>
        </member>
        <member name="P:System.SR.Sch_InvalidStartTransition">
            <summary>It is invalid to call the '{0}' method in the current state of the validator. The '{1}' method must be called before proceeding with validation.</summary>
        </member>
        <member name="P:System.SR.Sch_InvalidStateTransition">
            <summary>The transition from the '{0}' method to the '{1}' method is not allowed.</summary>
        </member>
        <member name="P:System.SR.Sch_InvalidEndValidation">
            <summary>The 'EndValidation' method cannot not be called when all the elements have not been validated. 'ValidateEndElement' calls corresponding to 'ValidateElement' calls might be missing.</summary>
        </member>
        <member name="P:System.SR.Sch_InvalidEndElementCall">
            <summary>It is invalid to call the 'ValidateEndElement' overload that takes in a 'typedValue' after 'ValidateText' or 'ValidateWhitespace' methods have been called.</summary>
        </member>
        <member name="P:System.SR.Sch_InvalidEndElementCallTyped">
            <summary>It is invalid to call the 'ValidateEndElement' overload that takes in a 'typedValue' for elements with complex content.</summary>
        </member>
        <member name="P:System.SR.Sch_InvalidEndElementMultiple">
            <summary>The call to the '{0}' method does not match a corresponding call to 'ValidateElement' method.</summary>
        </member>
        <member name="P:System.SR.Sch_DuplicateAttribute">
            <summary>The '{0}' attribute has already been validated and is a duplicate attribute.</summary>
        </member>
        <member name="P:System.SR.Sch_InvalidPartialValidationType">
            <summary>The partial validation type has to be 'XmlSchemaElement', 'XmlSchemaAttribute', or 'XmlSchemaType'.</summary>
        </member>
        <member name="P:System.SR.Sch_SchemaElementNameMismatch">
            <summary>The element name '{0}' does not match the name '{1}' of the 'XmlSchemaElement' set as a partial validation type.</summary>
        </member>
        <member name="P:System.SR.Sch_SchemaAttributeNameMismatch">
            <summary>The attribute name '{0}' does not match the name '{1}' of the 'XmlSchemaAttribute' set as a partial validation type.</summary>
        </member>
        <member name="P:System.SR.Sch_ValidateAttributeInvalidCall">
            <summary>If the partial validation type is 'XmlSchemaElement' or 'XmlSchemaType', the 'ValidateAttribute' method cannot be called.</summary>
        </member>
        <member name="P:System.SR.Sch_ValidateElementInvalidCall">
            <summary>If the partial validation type is 'XmlSchemaAttribute', the 'ValidateElement' method cannot be called.</summary>
        </member>
        <member name="P:System.SR.Sch_EnumNotStarted">
            <summary>Enumeration has not started. Call MoveNext.</summary>
        </member>
        <member name="P:System.SR.Sch_EnumFinished">
            <summary>Enumeration has already finished.</summary>
        </member>
        <member name="P:System.SR.SchInf_schema">
            <summary>The supplied xml instance is a schema or contains an inline schema. This class cannot infer a schema for a schema.</summary>
        </member>
        <member name="P:System.SR.SchInf_entity">
            <summary>Inference cannot handle entity references. Pass in an 'XmlReader' that expands entities.</summary>
        </member>
        <member name="P:System.SR.SchInf_simplecontent">
            <summary>Expected simple content. Schema was not created using this tool.</summary>
        </member>
        <member name="P:System.SR.SchInf_extension">
            <summary>Expected 'Extension' within 'SimpleContent'. Schema was not created using this tool.</summary>
        </member>
        <member name="P:System.SR.SchInf_particle">
            <summary>Particle cannot exist along with 'ContentModel'.</summary>
        </member>
        <member name="P:System.SR.SchInf_ct">
            <summary>Complex type expected to exist with at least one 'Element' at this point.</summary>
        </member>
        <member name="P:System.SR.SchInf_seq">
            <summary>sequence expected to contain elements only. Schema was not created using this tool.</summary>
        </member>
        <member name="P:System.SR.SchInf_noseq">
            <summary>The supplied schema contains particles other than Sequence and Choice. Only schemas generated by this tool are supported.</summary>
        </member>
        <member name="P:System.SR.SchInf_noct">
            <summary>Expected ComplexType. Schema was not generated using this tool.</summary>
        </member>
        <member name="P:System.SR.SchInf_UnknownParticle">
            <summary>Expected Element. Schema was not generated using this tool.</summary>
        </member>
        <member name="P:System.SR.SchInf_schematype">
            <summary>Inference can only handle simple built-in types for 'SchemaType'.</summary>
        </member>
        <member name="P:System.SR.SchInf_NoElement">
            <summary>There is no element to infer schema.</summary>
        </member>
        <member name="P:System.SR.Xp_UnclosedString">
            <summary>This is an unclosed string.</summary>
        </member>
        <member name="P:System.SR.Xp_ExprExpected">
            <summary>'{0}' is an invalid expression.</summary>
        </member>
        <member name="P:System.SR.Xp_InvalidArgumentType">
            <summary>The argument to function '{0}' in '{1}' cannot be converted to a node-set.</summary>
        </member>
        <member name="P:System.SR.Xp_InvalidNumArgs">
            <summary>Function '{0}' in '{1}' has an invalid number of arguments.</summary>
        </member>
        <member name="P:System.SR.Xp_InvalidName">
            <summary>'{0}' has an invalid qualified name.</summary>
        </member>
        <member name="P:System.SR.Xp_InvalidToken">
            <summary>'{0}' has an invalid token.</summary>
        </member>
        <member name="P:System.SR.Xp_NodeSetExpected">
            <summary>Expression must evaluate to a node-set.</summary>
        </member>
        <member name="P:System.SR.Xp_NotSupported">
            <summary>The XPath query '{0}' is not supported.</summary>
        </member>
        <member name="P:System.SR.Xp_InvalidPattern">
            <summary>'{0}' is an invalid XSLT pattern.</summary>
        </member>
        <member name="P:System.SR.Xp_InvalidKeyPattern">
            <summary>'{0}' is an invalid key pattern. It either contains a variable reference or 'key()' function.</summary>
        </member>
        <member name="P:System.SR.Xp_BadQueryObject">
            <summary>This is an invalid object. Only objects returned from Compile() can be passed as input.</summary>
        </member>
        <member name="P:System.SR.Xp_UndefinedXsltContext">
            <summary>XsltContext is needed for this query because of an unknown function.</summary>
        </member>
        <member name="P:System.SR.Xp_NoContext">
            <summary>Namespace Manager or XsltContext needed. This query has a prefix, variable, or user-defined function.</summary>
        </member>
        <member name="P:System.SR.Xp_UndefVar">
            <summary>The variable '{0}' is undefined.</summary>
        </member>
        <member name="P:System.SR.Xp_UndefFunc">
            <summary>The function '{0}()' is undefined.</summary>
        </member>
        <member name="P:System.SR.Xp_FunctionFailed">
            <summary>Function '{0}()' has failed.</summary>
        </member>
        <member name="P:System.SR.Xp_CurrentNotAllowed">
            <summary>The 'current()' function cannot be used in a pattern.</summary>
        </member>
        <member name="P:System.SR.Xp_QueryTooComplex">
            <summary>The xpath query is too complex.</summary>
        </member>
        <member name="P:System.SR.Xdom_DualDocumentTypeNode">
            <summary>This document already has a 'DocumentType' node.</summary>
        </member>
        <member name="P:System.SR.Xdom_DualDocumentElementNode">
            <summary>This document already has a 'DocumentElement' node.</summary>
        </member>
        <member name="P:System.SR.Xdom_DualDeclarationNode">
            <summary>This document already has an 'XmlDeclaration' node.</summary>
        </member>
        <member name="P:System.SR.Xdom_Import">
            <summary>Cannot import nodes of type '{0}'.</summary>
        </member>
        <member name="P:System.SR.Xdom_Import_NullNode">
            <summary>Cannot import a null node.</summary>
        </member>
        <member name="P:System.SR.Xdom_NoRootEle">
            <summary>The document does not have a root element.</summary>
        </member>
        <member name="P:System.SR.Xdom_Attr_Name">
            <summary>The attribute local name cannot be empty.</summary>
        </member>
        <member name="P:System.SR.Xdom_AttrCol_Object">
            <summary>An 'Attributes' collection can only contain 'Attribute' objects.</summary>
        </member>
        <member name="P:System.SR.Xdom_AttrCol_Insert">
            <summary>The reference node must be a child of the current node.</summary>
        </member>
        <member name="P:System.SR.Xdom_NamedNode_Context">
            <summary>The named node is from a different document context.</summary>
        </member>
        <member name="P:System.SR.Xdom_Version">
            <summary>Wrong XML version information. The XML must match production "VersionNum ::= '1.' [0-9]+".</summary>
        </member>
        <member name="P:System.SR.Xdom_standalone">
            <summary>Wrong value for the XML declaration standalone attribute of '{0}'.</summary>
        </member>
        <member name="P:System.SR.Xdom_Ent_Innertext">
            <summary>The 'InnerText' of an 'Entity' node is read-only and cannot be set.</summary>
        </member>
        <member name="P:System.SR.Xdom_EntRef_SetVal">
            <summary>'EntityReference' nodes have no support for setting value.</summary>
        </member>
        <member name="P:System.SR.Xdom_WS_Char">
            <summary>The string for whitespace contains an invalid character.</summary>
        </member>
        <member name="P:System.SR.Xdom_Node_SetVal">
            <summary>Cannot set a value on node type '{0}'.</summary>
        </member>
        <member name="P:System.SR.Xdom_Empty_LocalName">
            <summary>The local name for elements or attributes cannot be null or an empty string.</summary>
        </member>
        <member name="P:System.SR.Xdom_Set_InnerXml">
            <summary>Cannot set the 'InnerXml' for the current node because it is either read-only or cannot have children.</summary>
        </member>
        <member name="P:System.SR.Xdom_Attr_InUse">
            <summary>The 'Attribute' node cannot be inserted because it is already an attribute of another element.</summary>
        </member>
        <member name="P:System.SR.Xdom_Enum_ElementList">
            <summary>The element list has changed. The enumeration operation failed to continue.</summary>
        </member>
        <member name="P:System.SR.Xdom_Invalid_NT_String">
            <summary>'{0}' does not represent any 'XmlNodeType'.</summary>
        </member>
        <member name="P:System.SR.Xdom_InvalidCharacter_EntityReference">
            <summary>Cannot create an 'EntityReference' node with a name starting with '#'.</summary>
        </member>
        <member name="P:System.SR.Xdom_IndexOutOfRange">
            <summary>The index being passed in is out of range.</summary>
        </member>
        <member name="P:System.SR.Xdom_Document_Innertext">
            <summary>The 'InnerText' of a 'Document' node is read-only and cannot be set.</summary>
        </member>
        <member name="P:System.SR.Xpn_BadPosition">
            <summary>Operation is not valid due to the current position of the navigator.</summary>
        </member>
        <member name="P:System.SR.Xpn_MissingParent">
            <summary>The current position of the navigator is missing a valid parent.</summary>
        </member>
        <member name="P:System.SR.Xpn_NoContent">
            <summary>No content generated as the result of the operation.</summary>
        </member>
        <member name="P:System.SR.Xdom_Load_NoDocument">
            <summary>The document to be loaded could not be found.</summary>
        </member>
        <member name="P:System.SR.Xdom_Load_NoReader">
            <summary>There is no reader from which to load the document.</summary>
        </member>
        <member name="P:System.SR.Xdom_Node_Null_Doc">
            <summary>Cannot create a node without an owner document.</summary>
        </member>
        <member name="P:System.SR.Xdom_Node_Insert_Child">
            <summary>Cannot insert a node or any ancestor of that node as a child of itself.</summary>
        </member>
        <member name="P:System.SR.Xdom_Node_Insert_Contain">
            <summary>The current node cannot contain other nodes.</summary>
        </member>
        <member name="P:System.SR.Xdom_Node_Insert_Path">
            <summary>The reference node is not a child of this node.</summary>
        </member>
        <member name="P:System.SR.Xdom_Node_Insert_Context">
            <summary>The node to be inserted is from a different document context.</summary>
        </member>
        <member name="P:System.SR.Xdom_Node_Insert_Location">
            <summary>Cannot insert the node in the specified location.</summary>
        </member>
        <member name="P:System.SR.Xdom_Node_Insert_TypeConflict">
            <summary>The specified node cannot be inserted as the valid child of this node, because the specified node is the wrong type.</summary>
        </member>
        <member name="P:System.SR.Xdom_Node_Remove_Contain">
            <summary>The current node cannot contain other nodes, so the node to be removed is not its child.</summary>
        </member>
        <member name="P:System.SR.Xdom_Node_Remove_Child">
            <summary>The node to be removed is not a child of this node.</summary>
        </member>
        <member name="P:System.SR.Xdom_Node_Modify_ReadOnly">
            <summary>This node is read-only. It cannot be modified.</summary>
        </member>
        <member name="P:System.SR.Xdom_TextNode_SplitText">
            <summary>The 'Text' node is not connected in the DOM live tree. No 'SplitText' operation could be performed.</summary>
        </member>
        <member name="P:System.SR.Xdom_Attr_Reserved_XmlNS">
            <summary>The namespace declaration attribute has an incorrect 'namespaceURI': '{0}'.</summary>
        </member>
        <member name="P:System.SR.Xdom_Node_Cloning">
            <summary>'Entity' and 'Notation' nodes cannot be cloned.</summary>
        </member>
        <member name="P:System.SR.Xnr_ResolveEntity">
            <summary>The node is not an expandable 'EntityReference' node.</summary>
        </member>
        <member name="P:System.SR.XPathDocument_MissingSchemas">
            <summary>An XmlSchemaSet must be provided to validate the document.</summary>
        </member>
        <member name="P:System.SR.XPathDocument_NotEnoughSchemaInfo">
            <summary>Element should have prior schema information to call this method.</summary>
        </member>
        <member name="P:System.SR.XPathDocument_ValidateInvalidNodeType">
            <summary>Validate and CheckValidity are only allowed on Root or Element nodes.</summary>
        </member>
        <member name="P:System.SR.XPathDocument_SchemaSetNotAllowed">
            <summary>An XmlSchemaSet is only allowed as a parameter on the Root node.</summary>
        </member>
        <member name="P:System.SR.XmlBin_MissingEndCDATA">
            <summary>CDATA end token is missing.</summary>
        </member>
        <member name="P:System.SR.XmlBin_InvalidQNameID">
            <summary>Invalid QName ID.</summary>
        </member>
        <member name="P:System.SR.XmlBinary_UnexpectedToken">
            <summary>Unexpected BinaryXml token.</summary>
        </member>
        <member name="P:System.SR.XmlBinary_InvalidSqlDecimal">
            <summary>Unable to parse data as SQL_DECIMAL.</summary>
        </member>
        <member name="P:System.SR.XmlBinary_InvalidSignature">
            <summary>Invalid BinaryXml signature.</summary>
        </member>
        <member name="P:System.SR.XmlBinary_InvalidProtocolVersion">
            <summary>Invalid BinaryXml protocol version.</summary>
        </member>
        <member name="P:System.SR.XmlBinary_UnsupportedCodePage">
            <summary>Unsupported BinaryXml codepage.</summary>
        </member>
        <member name="P:System.SR.XmlBinary_InvalidStandalone">
            <summary>Invalid BinaryXml standalone token.</summary>
        </member>
        <member name="P:System.SR.XmlBinary_NoParserContext">
            <summary>BinaryXml Parser does not support initialization with XmlParserContext.</summary>
        </member>
        <member name="P:System.SR.XmlBinary_ListsOfValuesNotSupported">
            <summary>Lists of BinaryXml value tokens not supported.</summary>
        </member>
        <member name="P:System.SR.XmlBinary_CastNotSupported">
            <summary>Token '{0}' does not support a conversion to Clr type '{1}'.</summary>
        </member>
        <member name="P:System.SR.XmlBinary_NoRemapPrefix">
            <summary>Prefix '{0}' is already assigned to namespace '{1}' and cannot be reassigned to '{2}' on this tag.</summary>
        </member>
        <member name="P:System.SR.XmlBinary_AttrWithNsNoPrefix">
            <summary>Attribute '{0}' has namespace '{1}' but no prefix.</summary>
        </member>
        <member name="P:System.SR.XmlBinary_ValueTooBig">
            <summary>The value is too big to fit into an Int32. The arithmetic operation resulted in an overflow.</summary>
        </member>
        <member name="P:System.SR.SqlTypes_ArithOverflow">
            <summary>Arithmetic Overflow.</summary>
        </member>
        <member name="P:System.SR.XmlMissingType">
            <summary>Invalid serialization assembly: Required type {0} cannot be found in the generated assembly '{1}'.</summary>
        </member>
        <member name="P:System.SR.XmlSerializerUnsupportedType">
            <summary>{0} is an unsupported type. Please use [XmlIgnore] attribute to exclude members of this type from serialization graph.</summary>
        </member>
        <member name="P:System.SR.XmlSerializerUnsupportedMember">
            <summary>Cannot serialize member '{0}' of type '{1}', see inner exception for more details.</summary>
        </member>
        <member name="P:System.SR.XmlUnsupportedTypeKind">
            <summary>The type {0} may not be serialized.</summary>
        </member>
        <member name="P:System.SR.XmlUnsupportedSoapTypeKind">
            <summary>The type {0} may not be serialized with SOAP-encoded messages. Set the Use for your message to Literal.</summary>
        </member>
        <member name="P:System.SR.XmlUnsupportedIDictionary">
            <summary>The type {0} is not supported because it implements IDictionary.</summary>
        </member>
        <member name="P:System.SR.XmlUnsupportedIDictionaryDetails">
            <summary>Cannot serialize member {0} of type {1}, because it implements IDictionary.</summary>
        </member>
        <member name="P:System.SR.XmlDuplicateTypeName">
            <summary>A type with the name {0} has already been added in namespace {1}.</summary>
        </member>
        <member name="P:System.SR.XmlSerializableNameMissing1">
            <summary>Schema Id is missing. The schema returned from {0}.GetSchema() must have an Id.</summary>
        </member>
        <member name="P:System.SR.XmlConstructorInaccessible">
            <summary>{0} cannot be serialized because it does not have a parameterless constructor.</summary>
        </member>
        <member name="P:System.SR.XmlTypeInaccessible">
            <summary>{0} is inaccessible due to its protection level. Only public types can be processed.</summary>
        </member>
        <member name="P:System.SR.XmlTypeStatic">
            <summary>{0} cannot be serialized. Static types cannot be used as parameters or return types.</summary>
        </member>
        <member name="P:System.SR.XmlNoDefaultAccessors">
            <summary>You must implement a default accessor on {0} because it inherits from ICollection.</summary>
        </member>
        <member name="P:System.SR.XmlNoAddMethod">
            <summary>To be XML serializable, types which inherit from {2} must have an implementation of Add({1}) at all levels of their inheritance hierarchy. {0} does not implement Add({1}).</summary>
        </member>
        <member name="P:System.SR.XmlReadOnlyPropertyError">
            <summary>Cannot deserialize type '{0}' because it contains property '{1}' which has no public setter.</summary>
        </member>
        <member name="P:System.SR.XmlAttributeSetAgain">
            <summary>'{0}.{1}' already has attributes.</summary>
        </member>
        <member name="P:System.SR.XmlIllegalWildcard">
            <summary>Cannot use wildcards at the top level of a schema.</summary>
        </member>
        <member name="P:System.SR.XmlIllegalArrayElement">
            <summary>An element declared at the top level of a schema cannot have maxOccurs &gt; 1. Provide a wrapper element for '{0}' by using XmlArray or XmlArrayItem instead of XmlElementAttribute, or by using the Wrapped parameter style.</summary>
        </member>
        <member name="P:System.SR.XmlIllegalForm">
            <summary>There was an error exporting '{0}': elements declared at the top level of a schema cannot be unqualified.</summary>
        </member>
        <member name="P:System.SR.XmlBareTextMember">
            <summary>There was an error exporting '{0}': bare members cannot contain text content.</summary>
        </member>
        <member name="P:System.SR.XmlBareAttributeMember">
            <summary>There was an error exporting '{0}': bare members cannot be attributes.</summary>
        </member>
        <member name="P:System.SR.XmlReflectionError">
            <summary>There was an error reflecting '{0}'.</summary>
        </member>
        <member name="P:System.SR.XmlTypeReflectionError">
            <summary>There was an error reflecting type '{0}'.</summary>
        </member>
        <member name="P:System.SR.XmlPropertyReflectionError">
            <summary>There was an error reflecting property '{0}'.</summary>
        </member>
        <member name="P:System.SR.XmlFieldReflectionError">
            <summary>There was an error reflecting field '{0}'.</summary>
        </member>
        <member name="P:System.SR.XmlInvalidDataTypeUsage">
            <summary>'{0}' is an invalid value for the {1} property. The property may only be specified for primitive types.</summary>
        </member>
        <member name="P:System.SR.XmlInvalidXsdDataType">
            <summary>Value '{0}' cannot be used for the {1} property. The datatype '{2}' is missing.</summary>
        </member>
        <member name="P:System.SR.XmlDataTypeMismatch">
            <summary>'{0}' is an invalid value for the {1} property. {0} cannot be converted to {2}.</summary>
        </member>
        <member name="P:System.SR.XmlIllegalTypeContext">
            <summary>{0} cannot be used as: 'xml {1}'.</summary>
        </member>
        <member name="P:System.SR.XmlUdeclaredXsdType">
            <summary>The type, {0}, is undeclared.</summary>
        </member>
        <member name="P:System.SR.XmlInvalidConstantAttribute">
            <summary>Only XmlEnum may be used on enumerated constants.</summary>
        </member>
        <member name="P:System.SR.XmlIllegalAttributesArrayAttribute">
            <summary>XmlAttribute and XmlAnyAttribute cannot be used in conjunction with XmlElement, XmlText, XmlAnyElement, XmlArray, or XmlArrayItem.</summary>
        </member>
        <member name="P:System.SR.XmlIllegalElementsArrayAttribute">
            <summary>XmlElement, XmlText, and XmlAnyElement cannot be used in conjunction with XmlAttribute, XmlAnyAttribute, XmlArray, or XmlArrayItem.</summary>
        </member>
        <member name="P:System.SR.XmlIllegalArrayArrayAttribute">
            <summary>XmlArray and XmlArrayItem cannot be used in conjunction with XmlAttribute, XmlAnyAttribute, XmlElement, XmlText, or XmlAnyElement.</summary>
        </member>
        <member name="P:System.SR.XmlIllegalAttribute">
            <summary>For non-array types, you may use the following attributes: XmlAttribute, XmlText, XmlElement, or XmlAnyElement.</summary>
        </member>
        <member name="P:System.SR.XmlIllegalType">
            <summary>The type for {0} may not be specified for primitive types.</summary>
        </member>
        <member name="P:System.SR.XmlIllegalAttrOrText">
            <summary>Cannot serialize member '{0}' of type {1}. XmlAttribute/XmlText cannot be used to encode complex types.</summary>
        </member>
        <member name="P:System.SR.XmlIllegalSoapAttribute">
            <summary>Cannot serialize member '{0}' of type {1}. SoapAttribute cannot be used to encode complex types.</summary>
        </member>
        <member name="P:System.SR.XmlIllegalAttrOrTextInterface">
            <summary>Cannot serialize member '{0}' of type {1}. XmlAttribute/XmlText cannot be used to encode types implementing {2}.</summary>
        </member>
        <member name="P:System.SR.XmlIllegalAttributeFlagsArray">
            <summary>XmlAttribute cannot be used to encode array of {1}, because it is marked with FlagsAttribute.</summary>
        </member>
        <member name="P:System.SR.XmlIllegalAnyElement">
            <summary>Cannot serialize member of type {0}: XmlAnyElement can only be used with classes of type XmlNode or a type deriving from XmlNode.</summary>
        </member>
        <member name="P:System.SR.XmlInvalidIsNullable">
            <summary>IsNullable may not be 'true' for value type {0}.  Please consider using Nullable&lt;{0}&gt; instead.</summary>
        </member>
        <member name="P:System.SR.XmlInvalidNotNullable">
            <summary>IsNullable may not be set to 'false' for a Nullable&lt;{0}&gt; type. Consider using '{0}' type or removing the IsNullable property from the {1} attribute.</summary>
        </member>
        <member name="P:System.SR.XmlInvalidFormUnqualified">
            <summary>The Form property may not be 'Unqualified' when an explicit Namespace property is present.</summary>
        </member>
        <member name="P:System.SR.XmlDuplicateNamespace">
            <summary>The namespace, {0}, is a duplicate.</summary>
        </member>
        <member name="P:System.SR.XmlElementHasNoName">
            <summary>This element has no name. Please review schema type '{0}' from namespace '{1}'.</summary>
        </member>
        <member name="P:System.SR.XmlAttributeHasNoName">
            <summary>This attribute has no name.</summary>
        </member>
        <member name="P:System.SR.XmlElementImportedTwice">
            <summary>The element, {0}, from namespace, {1}, was imported in two different contexts: ({2}, {3}).</summary>
        </member>
        <member name="P:System.SR.XmlHiddenMember">
            <summary>Member {0}.{1} of type {2} hides base class member {3}.{4} of type {5}. Use XmlElementAttribute or XmlAttributeAttribute to specify a new name.</summary>
        </member>
        <member name="P:System.SR.XmlInvalidXmlOverride">
            <summary>Member '{0}.{1}' hides inherited member '{2}.{3}', but has different custom attributes.</summary>
        </member>
        <member name="P:System.SR.XmlMembersDeriveError">
            <summary>These members may not be derived.</summary>
        </member>
        <member name="P:System.SR.XmlTypeUsedTwice">
            <summary>The type '{0}' from namespace '{1}' was used in two different ways.</summary>
        </member>
        <member name="P:System.SR.XmlMissingGroup">
            <summary>Group {0} is missing.</summary>
        </member>
        <member name="P:System.SR.XmlMissingAttributeGroup">
            <summary>The attribute group {0} is missing.</summary>
        </member>
        <member name="P:System.SR.XmlMissingDataType">
            <summary>The datatype '{0}' is missing.</summary>
        </member>
        <member name="P:System.SR.XmlInvalidEncoding">
            <summary>Referenced type '{0}' is only valid for encoded SOAP.</summary>
        </member>
        <member name="P:System.SR.XmlMissingElement">
            <summary>The element '{0}' is missing.</summary>
        </member>
        <member name="P:System.SR.XmlMissingAttribute">
            <summary>The attribute {0} is missing.</summary>
        </member>
        <member name="P:System.SR.XmlMissingMethodEnum">
            <summary>The method for enum {0} is missing.</summary>
        </member>
        <member name="P:System.SR.XmlNoAttributeHere">
            <summary>Cannot write a node of type XmlAttribute as an element value. Use XmlAnyAttributeAttribute with an array of XmlNode or XmlAttribute to write the node as an attribute.</summary>
        </member>
        <member name="P:System.SR.XmlNeedAttributeHere">
            <summary>The node must be either type XmlAttribute or a derived type.</summary>
        </member>
        <member name="P:System.SR.XmlElementNameMismatch">
            <summary>This element was named '{0}' from namespace '{1}' but should have been named '{2}' from namespace '{3}'.</summary>
        </member>
        <member name="P:System.SR.XmlUnsupportedDefaultType">
            <summary>The default value type, {0}, is unsupported.</summary>
        </member>
        <member name="P:System.SR.XmlUnsupportedDefaultValue">
            <summary>The formatter {0} cannot be used for default values.</summary>
        </member>
        <member name="P:System.SR.XmlInvalidDefaultValue">
            <summary>Value '{0}' cannot be converted to {1}.</summary>
        </member>
        <member name="P:System.SR.XmlInvalidDefaultEnumValue">
            <summary>Enum {0} cannot be converted to {1}.</summary>
        </member>
        <member name="P:System.SR.XmlUnknownNode">
            <summary>{0} was not expected.</summary>
        </member>
        <member name="P:System.SR.XmlUnknownConstant">
            <summary>Instance validation error: '{0}' is not a valid value for {1}.</summary>
        </member>
        <member name="P:System.SR.XmlSerializeError">
            <summary>There is an error in the XML document.</summary>
        </member>
        <member name="P:System.SR.XmlSerializeErrorDetails">
            <summary>There is an error in XML document ({0}, {1}).</summary>
        </member>
        <member name="P:System.SR.XmlSchemaDuplicateNamespace">
            <summary>There are more then one schema with targetNamespace='{0}'.</summary>
        </member>
        <member name="P:System.SR.XmlSchemaCompiled">
            <summary>Cannot add schema to compiled schemas collection.</summary>
        </member>
        <member name="P:System.SR.XmlInvalidArrayDimentions">
            <summary>SOAP-ENC:arrayType with multidimensional array found at {0}. Only single-dimensional arrays are supported. Consider using an array of arrays instead.</summary>
        </member>
        <member name="P:System.SR.XmlInvalidArrayTypeName">
            <summary>The SOAP-ENC:arrayType references type is named '{0}'; a type named '{1}' was expected at {2}.</summary>
        </member>
        <member name="P:System.SR.XmlInvalidArrayTypeNamespace">
            <summary>The SOAP-ENC:arrayType references type is from namespace '{0}'; the namespace '{1}' was expected at {2}.</summary>
        </member>
        <member name="P:System.SR.XmlMissingArrayType">
            <summary>SOAP-ENC:arrayType was missing at {0}.</summary>
        </member>
        <member name="P:System.SR.XmlEmptyArrayType">
            <summary>SOAP-ENC:arrayType was empty at {0}.</summary>
        </member>
        <member name="P:System.SR.XmlInvalidArraySyntax">
            <summary>SOAP-ENC:arrayType must end with a ']' character.</summary>
        </member>
        <member name="P:System.SR.XmlInvalidArrayTypeSyntax">
            <summary>Invalid wsd:arrayType syntax: '{0}'.</summary>
        </member>
        <member name="P:System.SR.XmlMismatchedArrayBrackets">
            <summary>SOAP-ENC:arrayType has mismatched brackets.</summary>
        </member>
        <member name="P:System.SR.XmlInvalidArrayLength">
            <summary>SOAP-ENC:arrayType could not handle '{1}' as the length of the array.</summary>
        </member>
        <member name="P:System.SR.XmlMissingHref">
            <summary>The referenced element with ID '{0}' is located outside the current document and cannot be retrieved.</summary>
        </member>
        <member name="P:System.SR.XmlInvalidHref">
            <summary>The referenced element with ID '{0}' was not found in the document.</summary>
        </member>
        <member name="P:System.SR.XmlUnknownType">
            <summary>The specified type was not recognized: name='{0}', namespace='{1}', at {2}.</summary>
        </member>
        <member name="P:System.SR.XmlAbstractType">
            <summary>The specified type is abstract: name='{0}', namespace='{1}', at {2}.</summary>
        </member>
        <member name="P:System.SR.XmlMappingsScopeMismatch">
            <summary>Exported mappings must come from the same importer.</summary>
        </member>
        <member name="P:System.SR.XmlMethodTypeNameConflict">
            <summary>The XML element '{0}' from namespace '{1}' references a method and a type. Change the method's message name using WebMethodAttribute or change the type's root element using the XmlRootAttribute.</summary>
        </member>
        <member name="P:System.SR.XmlCannotReconcileAccessor">
            <summary>The top XML element '{0}' from namespace '{1}' references distinct types {2} and {3}. Use XML attributes to specify another XML name or namespace for the element or types.</summary>
        </member>
        <member name="P:System.SR.XmlCannotReconcileAttributeAccessor">
            <summary>The global XML attribute '{0}' from namespace '{1}' references distinct types {2} and {3}. Use XML attributes to specify another XML name or namespace for the attribute or types.</summary>
        </member>
        <member name="P:System.SR.XmlCannotReconcileAccessorDefault">
            <summary>The global XML item '{0}' from namespace '{1}' has mismatch default value attributes: '{2}' and '{3}' and cannot be mapped to the same schema item. Use XML attributes to specify another XML name or namespace for one of the items, or make sure that the defa ...</summary>
        </member>
        <member name="P:System.SR.XmlInvalidTypeAttributes">
            <summary>XmlRoot and XmlType attributes may not be specified for the type {0}.</summary>
        </member>
        <member name="P:System.SR.XmlInvalidAttributeUse">
            <summary>XML attributes may not be specified for the type {0}.</summary>
        </member>
        <member name="P:System.SR.XmlTypesDuplicate">
            <summary>Types '{0}' and '{1}' both use the XML type name, '{2}', from namespace '{3}'. Use XML attributes to specify a unique XML name and/or namespace for the type.</summary>
        </member>
        <member name="P:System.SR.XmlInvalidSoapArray">
            <summary>An array of type {0} may not be used with XmlArrayType.Soap.</summary>
        </member>
        <member name="P:System.SR.XmlCannotIncludeInSchema">
            <summary>The type {0} may not be exported to a schema because the IncludeInSchema property of the XmlType attribute is 'false'.</summary>
        </member>
        <member name="P:System.SR.XmlInvalidSerializable">
            <summary>The type {0} may not be used in this context. To use {0} as a parameter, return type, or member of a class or struct, the parameter, return type, or member must be declared as type {0} (it cannot be object). Objects of type {0} may not be used in un-typed  ...</summary>
        </member>
        <member name="P:System.SR.XmlInvalidUseOfType">
            <summary>The type {0} may not be used in this context.</summary>
        </member>
        <member name="P:System.SR.XmlUnxpectedType">
            <summary>The type {0} was not expected. Use the XmlInclude or SoapInclude attribute to specify types that are not known statically.</summary>
        </member>
        <member name="P:System.SR.XmlUnknownAnyElement">
            <summary>The XML element '{0}' from namespace '{1}' was not expected. The XML element name and namespace must match those provided via XmlAnyElementAttribute(s).</summary>
        </member>
        <member name="P:System.SR.XmlMultipleAttributeOverrides">
            <summary>{0}. {1} already has attributes.</summary>
        </member>
        <member name="P:System.SR.XmlInvalidEnumAttribute">
            <summary>Only SoapEnum may be used on enum constants.</summary>
        </member>
        <member name="P:System.SR.XmlInvalidReturnPosition">
            <summary>The return value must be the first member.</summary>
        </member>
        <member name="P:System.SR.XmlInvalidElementAttribute">
            <summary>Only SoapElementAttribute or SoapAttributeAttribute may be used on members.</summary>
        </member>
        <member name="P:System.SR.XmlInvalidVoid">
            <summary>The type Void is not valid in this context.</summary>
        </member>
        <member name="P:System.SR.XmlInvalidContent">
            <summary>Invalid content {0}.</summary>
        </member>
        <member name="P:System.SR.XmlInvalidAttributeType">
            <summary>{0} may not be used on parameters or return values when they are not wrapped.</summary>
        </member>
        <member name="P:System.SR.XmlInvalidBaseType">
            <summary>Type {0} cannot derive from {1} because it already has base type {2}.</summary>
        </member>
        <member name="P:System.SR.XmlInvalidIdentifier">
            <summary>Identifier '{0}' is not CLS-compliant.</summary>
        </member>
        <member name="P:System.SR.XmlGenError">
            <summary>There was an error generating the XML document.</summary>
        </member>
        <member name="P:System.SR.XmlInvalidXmlns">
            <summary>Invalid namespace attribute: xmlns:{0}="".</summary>
        </member>
        <member name="P:System.SR.XmlCircularReference">
            <summary>A circular reference was detected while serializing an object of type {0}.</summary>
        </member>
        <member name="P:System.SR.XmlCircularReference2">
            <summary>A circular type reference was detected in anonymous type '{0}'.  Please change '{0}' to be a named type by setting {1}={2} in the type definition.</summary>
        </member>
        <member name="P:System.SR.XmlAnonymousBaseType">
            <summary>Illegal type derivation: Type '{0}' derives from anonymous type '{1}'. Please change '{1}' to be a named type by setting {2}={3} in the type definition.</summary>
        </member>
        <member name="P:System.SR.XmlMissingSchema">
            <summary>Missing schema targetNamespace="{0}".</summary>
        </member>
        <member name="P:System.SR.XmlNoSerializableMembers">
            <summary>Cannot serialize object of type '{0}'. The object does not have serializable members.</summary>
        </member>
        <member name="P:System.SR.XmlIllegalOverride">
            <summary>Error: Type '{0}' could not be imported because it redefines inherited member '{1}' with a different type. '{1}' is declared as type '{3}' on '{0}', but as type '{2}' on base class '{4}'.</summary>
        </member>
        <member name="P:System.SR.XmlReadOnlyCollection">
            <summary>Could not deserialize {0}. Parameterless constructor is required for collections and enumerators.</summary>
        </member>
        <member name="P:System.SR.XmlRpcNestedValueType">
            <summary>Cannot serialize {0}. Nested structs are not supported with encoded SOAP.</summary>
        </member>
        <member name="P:System.SR.XmlRpcRefsInValueType">
            <summary>Cannot serialize {0}. References in structs are not supported with encoded SOAP.</summary>
        </member>
        <member name="P:System.SR.XmlRpcArrayOfValueTypes">
            <summary>Cannot serialize {0}. Arrays of structs are not supported with encoded SOAP.</summary>
        </member>
        <member name="P:System.SR.XmlDuplicateElementName">
            <summary>The XML element '{0}' from namespace '{1}' is already present in the current scope. Use XML attributes to specify another XML name or namespace for the element.</summary>
        </member>
        <member name="P:System.SR.XmlDuplicateAttributeName">
            <summary>The XML attribute '{0}' from namespace '{1}' is already present in the current scope. Use XML attributes to specify another XML name or namespace for the attribute.</summary>
        </member>
        <member name="P:System.SR.XmlBadBaseElement">
            <summary>Element '{0}' from namespace '{1}' is not a complex type and cannot be used as a {2}.</summary>
        </member>
        <member name="P:System.SR.XmlBadBaseType">
            <summary>Type '{0}' from namespace '{1}' is not a complex type and cannot be used as a {2}.</summary>
        </member>
        <member name="P:System.SR.XmlUndefinedAlias">
            <summary>Namespace prefix '{0}' is not defined.</summary>
        </member>
        <member name="P:System.SR.XmlChoiceIdentifierType">
            <summary>Type of choice identifier '{0}' is inconsistent with type of '{1}'. Please use {2}.</summary>
        </member>
        <member name="P:System.SR.XmlChoiceIdentifierArrayType">
            <summary>Type of choice identifier '{0}' is inconsistent with type of '{1}'. Please use array of {2}.</summary>
        </member>
        <member name="P:System.SR.XmlChoiceIdentifierTypeEnum">
            <summary>Choice identifier '{0}' must be an enum.</summary>
        </member>
        <member name="P:System.SR.XmlChoiceIdentifierMemberMissing">
            <summary>Missing '{0}' member needed for serialization of choice '{1}'.</summary>
        </member>
        <member name="P:System.SR.XmlChoiceIdentifierAmbiguous">
            <summary>Ambiguous choice identifier. There are several members named '{0}'.</summary>
        </member>
        <member name="P:System.SR.XmlChoiceIdentifierMissing">
            <summary>You need to add {0} to the '{1}' member.</summary>
        </member>
        <member name="P:System.SR.XmlChoiceMissingValue">
            <summary>Type {0} is missing enumeration value '{1}' for element '{2}' from namespace '{3}'.</summary>
        </member>
        <member name="P:System.SR.XmlChoiceMissingAnyValue">
            <summary>Type {0} is missing enumeration value '##any:' corresponding to XmlAnyElementAttribute.</summary>
        </member>
        <member name="P:System.SR.XmlChoiceMismatchChoiceException">
            <summary>Value of {0} mismatches the type of {1}; you need to set it to {2}.</summary>
        </member>
        <member name="P:System.SR.XmlArrayItemAmbiguousTypes">
            <summary>Ambiguous types specified for member '{0}'.  Items '{1}' and '{2}' have the same type.  Please consider using {3} with {4} instead.</summary>
        </member>
        <member name="P:System.SR.XmlUnsupportedInterface">
            <summary>Cannot serialize interface {0}.</summary>
        </member>
        <member name="P:System.SR.XmlUnsupportedInterfaceDetails">
            <summary>Cannot serialize member {0} of type {1} because it is an interface.</summary>
        </member>
        <member name="P:System.SR.XmlUnsupportedRank">
            <summary>Cannot serialize object of type {0}. Multidimensional arrays are not supported.</summary>
        </member>
        <member name="P:System.SR.XmlUnsupportedInheritance">
            <summary>Using {0} as a base type for a class is not supported by XmlSerializer.</summary>
        </member>
        <member name="P:System.SR.XmlIllegalMultipleText">
            <summary>Cannot serialize object of type '{0}' because it has multiple XmlText attributes. Consider using an array of strings with XmlTextAttribute for serialization of a mixed complex type.</summary>
        </member>
        <member name="P:System.SR.XmlIllegalMultipleTextMembers">
            <summary>XmlText may not be used on multiple parameters or return values.</summary>
        </member>
        <member name="P:System.SR.XmlIllegalArrayTextAttribute">
            <summary>Member '{0}' cannot be encoded using the XmlText attribute. You may use the XmlText attribute to encode primitives, enumerations, arrays of strings, or arrays of XmlNode.</summary>
        </member>
        <member name="P:System.SR.XmlIllegalTypedTextAttribute">
            <summary>Cannot serialize object of type '{0}'. Consider changing type of XmlText member '{0}.{1}' from {2} to string or string array.</summary>
        </member>
        <member name="P:System.SR.XmlIllegalSimpleContentExtension">
            <summary>Cannot serialize object of type '{0}'. Base type '{1}' has simpleContent and can only be extended by adding XmlAttribute elements. Please consider changing XmlText member of the base class to string array.</summary>
        </member>
        <member name="P:System.SR.XmlInvalidCast">
            <summary>Cannot assign object of type {0} to an object of type {1}.</summary>
        </member>
        <member name="P:System.SR.XmlInvalidCastWithId">
            <summary>Cannot assign object of type {0} to an object of type {1}. The error occurred while reading node with id='{2}'.</summary>
        </member>
        <member name="P:System.SR.XmlInvalidArrayRef">
            <summary>Invalid reference id='{0}'. Object of type {1} cannot be stored in an array of this type. Details: array index={2}.</summary>
        </member>
        <member name="P:System.SR.XmlInvalidNullCast">
            <summary>Cannot assign null value to an object of type {1}.</summary>
        </member>
        <member name="P:System.SR.XmlMultipleXmlns">
            <summary>Cannot serialize object of type '{0}' because it has multiple XmlNamespaceDeclarations attributes.</summary>
        </member>
        <member name="P:System.SR.XmlMultipleXmlnsMembers">
            <summary>XmlNamespaceDeclarations may not be used on multiple parameters or return values.</summary>
        </member>
        <member name="P:System.SR.XmlXmlnsInvalidType">
            <summary>Cannot use XmlNamespaceDeclarations attribute on member '{0}' of type {1}.  This attribute is only valid on members of type {2}.</summary>
        </member>
        <member name="P:System.SR.XmlSoleXmlnsAttribute">
            <summary>XmlNamespaceDeclarations attribute cannot be used in conjunction with any other custom attributes.</summary>
        </member>
        <member name="P:System.SR.XmlConstructorHasSecurityAttributes">
            <summary>The type '{0}' cannot be serialized because its parameterless constructor is decorated with declarative security permission attributes. Consider using imperative asserts or demands in the constructor.</summary>
        </member>
        <member name="P:System.SR.XmlInvalidChoiceIdentifierValue">
            <summary>Invalid or missing value of the choice identifier '{1}' of type '{0}[]'.</summary>
        </member>
        <member name="P:System.SR.XmlAnyElementDuplicate">
            <summary>The element '{0}' has been attributed with duplicate XmlAnyElementAttribute(Name="{1}", Namespace="{2}").</summary>
        </member>
        <member name="P:System.SR.XmlChoiceIdDuplicate">
            <summary>Enum values in the XmlChoiceIdentifier '{0}' have to be unique.  Value '{1}' already present.</summary>
        </member>
        <member name="P:System.SR.XmlChoiceIdentifierMismatch">
            <summary>Value '{0}' of the choice identifier '{1}' does not match element '{2}' from namespace '{3}'.</summary>
        </member>
        <member name="P:System.SR.XmlUnsupportedRedefine">
            <summary>Cannot import schema for type '{0}' from namespace '{1}'. Redefine not supported.</summary>
        </member>
        <member name="P:System.SR.XmlDuplicateElementInScope">
            <summary>The XML element named '{0}' from namespace '{1}' is already present in the current scope.</summary>
        </member>
        <member name="P:System.SR.XmlDuplicateElementInScope1">
            <summary>The XML element named '{0}' from namespace '{1}' is already present in the current scope. Elements with the same name in the same scope must have the same type.</summary>
        </member>
        <member name="P:System.SR.XmlNoPartialTrust">
            <summary>One or more assemblies referenced by the XmlSerializer cannot be called from partially trusted code.</summary>
        </member>
        <member name="P:System.SR.XmlInvalidEncodingNotEncoded1">
            <summary>The encoding style '{0}' is not valid for this call because this XmlSerializer instance does not support encoding. Use the SoapReflectionImporter to initialize an XmlSerializer that supports encoding.</summary>
        </member>
        <member name="P:System.SR.XmlInvalidEncoding3">
            <summary>The encoding style '{0}' is not valid for this call. Valid values are '{1}' for SOAP 1.1 encoding or '{2}' for SOAP 1.2 encoding.</summary>
        </member>
        <member name="P:System.SR.XmlInvalidSpecifiedType">
            <summary>Member '{0}' of type {1} cannot be serialized.  Members with names ending on 'Specified' suffix have special meaning to the XmlSerializer: they control serialization of optional ValueType members and have to be of type {2}.</summary>
        </member>
        <member name="P:System.SR.XmlUnsupportedOpenGenericType">
            <summary>Type {0} is not supported because it has unbound generic parameters.  Only instantiated generic types can be serialized.</summary>
        </member>
        <member name="P:System.SR.XmlMismatchSchemaObjects">
            <summary>Warning: Cannot share {0} named '{1}' from '{2}' namespace. Several mismatched schema declarations were found.</summary>
        </member>
        <member name="P:System.SR.XmlCircularTypeReference">
            <summary>Type '{0}' from targetNamespace='{1}' has invalid definition: Circular type reference.</summary>
        </member>
        <member name="P:System.SR.XmlCircularGroupReference">
            <summary>Group '{0}' from targetNamespace='{1}' has invalid definition: Circular group reference.</summary>
        </member>
        <member name="P:System.SR.XmlRpcLitElementNamespace">
            <summary>{0}='{1}' is not supported with rpc\literal SOAP. The wrapper element has to be unqualified.</summary>
        </member>
        <member name="P:System.SR.XmlRpcLitElementNullable">
            <summary>{0}='{1}' is not supported with rpc\literal SOAP. The wrapper element cannot be nullable.</summary>
        </member>
        <member name="P:System.SR.XmlRpcLitElements">
            <summary>Multiple accessors are not supported with rpc\literal SOAP, you may use the following attributes: XmlArray, XmlArrayItem, or single XmlElement.</summary>
        </member>
        <member name="P:System.SR.XmlRpcLitArrayElement">
            <summary>Input or output values of an rpc\literal method cannot have maxOccurs &gt; 1. Provide a wrapper element for '{0}' by using XmlArray or XmlArrayItem instead of XmlElement attribute.</summary>
        </member>
        <member name="P:System.SR.XmlRpcLitAttributeAttributes">
            <summary>XmlAttribute and XmlAnyAttribute cannot be used with rpc\literal SOAP, you may use the following attributes: XmlArray, XmlArrayItem, or single XmlElement.</summary>
        </member>
        <member name="P:System.SR.XmlRpcLitAttributes">
            <summary>XmlText, XmlAnyElement, or XmlChoiceIdentifier cannot be used with rpc\literal SOAP, you may use the following attributes: XmlArray, XmlArrayItem, or single XmlElement.</summary>
        </member>
        <member name="P:System.SR.XmlSequenceMembers">
            <summary>Explicit sequencing may not be used on parameters or return values.  Please remove {0} property from custom attributes.</summary>
        </member>
        <member name="P:System.SR.XmlRpcLitXmlns">
            <summary>Input or output values of an rpc\literal method cannot have an XmlNamespaceDeclarations attribute (member '{0}').</summary>
        </member>
        <member name="P:System.SR.XmlDuplicateNs">
            <summary>Illegal namespace declaration xmlns:{0}='{1}'. Namespace alias '{0}' already defined in the current scope.</summary>
        </member>
        <member name="P:System.SR.XmlAnonymousInclude">
            <summary>Cannot include anonymous type '{0}'.</summary>
        </member>
        <member name="P:System.SR.XmlSchemaIncludeLocation">
            <summary>Schema attribute schemaLocation='{1}' is not supported on objects of type {0}.  Please set {0}.Schema property.</summary>
        </member>
        <member name="P:System.SR.XmlSerializableSchemaError">
            <summary>Schema type information provided by {0} is invalid: {1}</summary>
        </member>
        <member name="P:System.SR.XmlGetSchemaMethodName">
            <summary>'{0}' is an invalid language identifier.</summary>
        </member>
        <member name="P:System.SR.XmlGetSchemaMethodMissing">
            <summary>You must implement public static {0}({1}) method on {2}.</summary>
        </member>
        <member name="P:System.SR.XmlGetSchemaMethodReturnType">
            <summary>Method {0}.{1}() specified by {2} has invalid signature: return type must be compatible with {3}.</summary>
        </member>
        <member name="P:System.SR.XmlGetSchemaEmptyTypeName">
            <summary>{0}.{1}() must return a valid type name.</summary>
        </member>
        <member name="P:System.SR.XmlGetSchemaTypeMissing">
            <summary>{0}.{1}() must return a valid type name. Type '{2}' cannot be found in the targetNamespace='{3}'.</summary>
        </member>
        <member name="P:System.SR.XmlGetSchemaInclude">
            <summary>Multiple schemas with targetNamespace='{0}' returned by {1}.{2}().  Please use only the main (parent) schema, and add the others to the schema Includes.</summary>
        </member>
        <member name="P:System.SR.XmlSerializableAttributes">
            <summary>Only XmlRoot attribute may be specified for the type {0}. Please use {1} to specify schema type.</summary>
        </member>
        <member name="P:System.SR.XmlSerializableMergeItem">
            <summary>Cannot merge schemas with targetNamespace='{0}'. Several mismatched declarations were found: {1}</summary>
        </member>
        <member name="P:System.SR.XmlSerializableBadDerivation">
            <summary>Type '{0}' from namespace '{1}' declared as derivation of type '{2}' from namespace '{3}, but corresponding CLR types are not compatible.  Cannot convert type '{4}' to '{5}'.</summary>
        </member>
        <member name="P:System.SR.XmlSerializableMissingClrType">
            <summary>Type '{0}' from namespace '{1}' does not have corresponding IXmlSerializable type. Please consider adding {2} to '{3}'.</summary>
        </member>
        <member name="P:System.SR.XmlCircularDerivation">
            <summary>Circular reference in derivation of IXmlSerializable type '{0}'.</summary>
        </member>
        <member name="P:System.SR.XmlMelformMapping">
            <summary>This mapping was not crated by reflection importer and cannot be used in this context.</summary>
        </member>
        <member name="P:System.SR.XmlSchemaSyntaxErrorDetails">
            <summary>Schema with targetNamespace='{0}' has invalid syntax. {1} Line {2}, position {3}.</summary>
        </member>
        <member name="P:System.SR.XmlSchemaElementReference">
            <summary>Element reference '{0}' declared in schema type '{1}' from namespace '{2}'.</summary>
        </member>
        <member name="P:System.SR.XmlSchemaAttributeReference">
            <summary>Attribute reference '{0}' declared in schema type '{1}' from namespace '{2}'.</summary>
        </member>
        <member name="P:System.SR.XmlSchemaItem">
            <summary>Schema item '{1}' from namespace '{0}'. {2}</summary>
        </member>
        <member name="P:System.SR.XmlSchemaNamedItem">
            <summary>Schema item '{1}' named '{2}' from namespace '{0}'. {3}</summary>
        </member>
        <member name="P:System.SR.XmlSchemaContentDef">
            <summary>Check content definition of schema type '{0}' from namespace '{1}'. {2}</summary>
        </member>
        <member name="P:System.SR.XmlSchema">
            <summary>Schema with targetNamespace='{0}' has invalid syntax. {1}</summary>
        </member>
        <member name="P:System.SR.XmlSerializableRootDupName">
            <summary>Cannot reconcile schema for '{0}'. Please use [XmlRoot] attribute to change default name or namespace of the top-level element to avoid duplicate element declarations: element name='{1}' namespace='{2}'.</summary>
        </member>
        <member name="P:System.SR.XmlNotSerializable">
            <summary>Type '{0}' is not serializable.</summary>
        </member>
        <member name="P:System.SR.XmlTypeInBadLoadContext">
            <summary>Type '{0}' is from an AssemblyLoadContext which is incompatible with that which contains this XmlSerializer.</summary>
        </member>
        <member name="P:System.SR.XmlPregenInvalidXmlSerializerAssemblyAttribute">
            <summary>Invalid XmlSerializerAssemblyAttribute usage. Please use {0} property or {1} property.</summary>
        </member>
        <member name="P:System.SR.XmlSequenceInconsistent">
            <summary>Inconsistent sequencing: if used on one of the class's members, the '{0}' property is required on all particle-like members, please explicitly set '{0}' using XmlElement, XmlAnyElement or XmlArray custom attribute on class member '{1}'.</summary>
        </member>
        <member name="P:System.SR.XmlSequenceUnique">
            <summary>'{1}' values must be unique within the same scope. Value '{0}' is in use. Please change '{1}' property on '{2}'.</summary>
        </member>
        <member name="P:System.SR.XmlSequenceHierarchy">
            <summary>There was an error processing type '{0}'. Type member '{1}' declared in '{2}' is missing required '{3}' property. If one class in the class hierarchy uses explicit sequencing feature ({3}), then its base class and all derived classes have to do the same.</summary>
        </member>
        <member name="P:System.SR.XmlSequenceMatch">
            <summary>If multiple custom attributes specified on a single member only one of them have to have explicit '{0}' property, however if more that one attribute has the explicit '{0}', all values have to match.</summary>
        </member>
        <member name="P:System.SR.XmlDisallowNegativeValues">
            <summary>Negative values are prohibited.</summary>
        </member>
        <member name="P:System.SR.Xml_UnexpectedToken">
            <summary>This is an unexpected token. The expected token is '{0}'.</summary>
        </member>
        <member name="P:System.SR.Sch_AttributeValueDataType">
            <summary>The '{0}' attribute has an invalid value according to its data type.</summary>
        </member>
        <member name="P:System.SR.Sch_ElementValueDataType">
            <summary>The '{0}' element has an invalid value according to its data type.</summary>
        </member>
        <member name="P:System.SR.XmlInternalError">
            <summary>Internal error.</summary>
        </member>
        <member name="P:System.SR.XmlInternalErrorDetails">
            <summary>Internal error: {0}.</summary>
        </member>
        <member name="P:System.SR.XmlInternalErrorMethod">
            <summary>Internal error: missing generated method for {0}.</summary>
        </member>
        <member name="P:System.SR.Arg_NeverValueType">
            <summary>Only TypeKind.Root can be set for typeof(object) which is never value type.</summary>
        </member>
        <member name="P:System.SR.Enc_InvalidByteInEncoding">
            <summary>Invalid byte was found at index {0}.</summary>
        </member>
        <member name="P:System.SR.Arg_ExpectingXmlTextReader">
            <summary>The XmlReader passed in to construct this XmlValidatingReaderImpl must be an instance of a System.Xml.XmlTextReader.</summary>
        </member>
        <member name="P:System.SR.Arg_CannotCreateNode">
            <summary>Cannot create node of type {0}.</summary>
        </member>
        <member name="P:System.SR.Arg_IncompatibleParamType">
            <summary>Type is incompatible.</summary>
        </member>
        <member name="P:System.SR.Xml_EndOfInnerExceptionStack">
            <summary>--- End of inner exception stack trace ---</summary>
        </member>
        <member name="P:System.SR.XPath_UnclosedString">
            <summary>String literal was not closed.</summary>
        </member>
        <member name="P:System.SR.XPath_ScientificNotation">
            <summary>Scientific notation is not allowed.</summary>
        </member>
        <member name="P:System.SR.XPath_UnexpectedToken">
            <summary>Unexpected token '{0}' in the expression.</summary>
        </member>
        <member name="P:System.SR.XPath_NodeTestExpected">
            <summary>Expected a node test, found '{0}'.</summary>
        </member>
        <member name="P:System.SR.XPath_EofExpected">
            <summary>Expected end of the expression, found '{0}'.</summary>
        </member>
        <member name="P:System.SR.XPath_TokenExpected">
            <summary>Expected token '{0}', found '{1}'.</summary>
        </member>
        <member name="P:System.SR.XPath_InvalidAxisInPattern">
            <summary>Only 'child' and 'attribute' axes are allowed in a pattern outside predicates.</summary>
        </member>
        <member name="P:System.SR.XPath_PredicateAfterDot">
            <summary>Abbreviated step '.' cannot be followed by a predicate. Use the full form 'self::node()[predicate]' instead.</summary>
        </member>
        <member name="P:System.SR.XPath_PredicateAfterDotDot">
            <summary>Abbreviated step '..' cannot be followed by a predicate. Use the full form 'parent::node()[predicate]' instead.</summary>
        </member>
        <member name="P:System.SR.XPath_NArgsExpected">
            <summary>Function '{0}()' must have {1} argument(s).</summary>
        </member>
        <member name="P:System.SR.XPath_NOrMArgsExpected">
            <summary>Function '{0}()' must have {1} or {2} argument(s).</summary>
        </member>
        <member name="P:System.SR.XPath_AtLeastNArgsExpected">
            <summary>Function '{0}()' must have at least {1} argument(s).</summary>
        </member>
        <member name="P:System.SR.XPath_AtMostMArgsExpected">
            <summary>Function '{0}()' must have no more than {2} arguments.</summary>
        </member>
        <member name="P:System.SR.XPath_NodeSetArgumentExpected">
            <summary>Argument {1} of function '{0}()' cannot be converted to a node-set.</summary>
        </member>
        <member name="P:System.SR.XPath_NodeSetExpected">
            <summary>Expression must evaluate to a node-set.</summary>
        </member>
        <member name="P:System.SR.XPath_RtfInPathExpr">
            <summary>To use a result tree fragment in a path expression, first convert it to a node-set using the msxsl:node-set() function.</summary>
        </member>
        <member name="P:System.SR.Xslt_WarningAsError">
            <summary>Warning as Error: {0}</summary>
        </member>
        <member name="P:System.SR.Xslt_InputTooComplex">
            <summary>The stylesheet is too complex.</summary>
        </member>
        <member name="P:System.SR.Xslt_CannotLoadStylesheet">
            <summary>Cannot load the stylesheet object referenced by URI '{0}', because the provided XmlResolver returned an object of type '{1}'. One of Stream, XmlReader, and IXPathNavigable types was expected.</summary>
        </member>
        <member name="P:System.SR.Xslt_WrongStylesheetElement">
            <summary>Stylesheet must start either with an 'xsl:stylesheet' or an 'xsl:transform' element, or with a literal result element that has an 'xsl:version' attribute, where prefix 'xsl' denotes the 'http://www.w3.org/1999/XSL/Transform' namespace.</summary>
        </member>
        <member name="P:System.SR.Xslt_WdXslNamespace">
            <summary>The 'http://www.w3.org/TR/WD-xsl' namespace is no longer supported.</summary>
        </member>
        <member name="P:System.SR.Xslt_NotAtTop">
            <summary>'{0}' element children must precede all other children of the '{1}' element.</summary>
        </member>
        <member name="P:System.SR.Xslt_UnexpectedElement">
            <summary>'{0}' cannot be a child of the '{1}' element.</summary>
        </member>
        <member name="P:System.SR.Xslt_NullNsAtTopLevel">
            <summary>Top-level element '{0}' may not have a null namespace URI.</summary>
        </member>
        <member name="P:System.SR.Xslt_TextNodesNotAllowed">
            <summary>'{0}' element cannot have text node children.</summary>
        </member>
        <member name="P:System.SR.Xslt_NotEmptyContents">
            <summary>The contents of '{0}' must be empty.</summary>
        </member>
        <member name="P:System.SR.Xslt_InvalidAttribute">
            <summary>'{0}' is an invalid attribute for the '{1}' element.</summary>
        </member>
        <member name="P:System.SR.Xslt_MissingAttribute">
            <summary>Missing mandatory attribute '{0}'.</summary>
        </member>
        <member name="P:System.SR.Xslt_InvalidAttrValue">
            <summary>'{1}' is an invalid value for the '{0}' attribute.</summary>
        </member>
        <member name="P:System.SR.Xslt_BistateAttribute">
            <summary>The value of the '{0}' attribute must be '{1}' or '{2}'.</summary>
        </member>
        <member name="P:System.SR.Xslt_CharAttribute">
            <summary>The value of the '{0}' attribute must be a single character.</summary>
        </member>
        <member name="P:System.SR.Xslt_CircularInclude">
            <summary>Stylesheet '{0}' cannot directly or indirectly include or import itself.</summary>
        </member>
        <member name="P:System.SR.Xslt_SingleRightBraceInAvt">
            <summary>The right curly brace in an attribute value template '{0}' outside an expression must be doubled.</summary>
        </member>
        <member name="P:System.SR.Xslt_VariableCntSel2">
            <summary>The variable or parameter '{0}' cannot have both a 'select' attribute and non-empty content.</summary>
        </member>
        <member name="P:System.SR.Xslt_KeyCntUse">
            <summary>'xsl:key' has a 'use' attribute and has non-empty content, or it has empty content and no 'use' attribute.</summary>
        </member>
        <member name="P:System.SR.Xslt_DupTemplateName">
            <summary>'{0}' is a duplicate template name.</summary>
        </member>
        <member name="P:System.SR.Xslt_BothMatchNameAbsent">
            <summary>'xsl:template' must have either a 'match' attribute or a 'name' attribute, or both.</summary>
        </member>
        <member name="P:System.SR.Xslt_InvalidVariable">
            <summary>The variable or parameter '{0}' is either not defined or it is out of scope.</summary>
        </member>
        <member name="P:System.SR.Xslt_DupGlobalVariable">
            <summary>The variable or parameter '{0}' was duplicated with the same import precedence.</summary>
        </member>
        <member name="P:System.SR.Xslt_DupLocalVariable">
            <summary>The variable or parameter '{0}' was duplicated within the same scope.</summary>
        </member>
        <member name="P:System.SR.Xslt_DupNsAlias">
            <summary>Namespace URI '{0}' is declared to be an alias for multiple different namespace URIs with the same import precedence.</summary>
        </member>
        <member name="P:System.SR.Xslt_EmptyAttrValue">
            <summary>The value of the '{0}' attribute cannot be empty.</summary>
        </member>
        <member name="P:System.SR.Xslt_EmptyNsAlias">
            <summary>The value of the '{0}' attribute cannot be empty. Use '#default' to specify the default namespace.</summary>
        </member>
        <member name="P:System.SR.Xslt_UnknownXsltFunction">
            <summary>'{0}()' is an unknown XSLT function.</summary>
        </member>
        <member name="P:System.SR.Xslt_UnsupportedXsltFunction">
            <summary>'{0}()' is an unsupported XSLT function.</summary>
        </member>
        <member name="P:System.SR.Xslt_NoAttributeSet">
            <summary>A reference to attribute set '{0}' cannot be resolved. An 'xsl:attribute-set' of this name must be declared at the top level of the stylesheet.</summary>
        </member>
        <member name="P:System.SR.Xslt_UndefinedKey">
            <summary>A reference to key '{0}' cannot be resolved. An 'xsl:key' of this name must be declared at the top level of the stylesheet.</summary>
        </member>
        <member name="P:System.SR.Xslt_CircularAttributeSet">
            <summary>Circular reference in the definition of attribute set '{0}'.</summary>
        </member>
        <member name="P:System.SR.Xslt_InvalidCallTemplate">
            <summary>The named template '{0}' does not exist.</summary>
        </member>
        <member name="P:System.SR.Xslt_InvalidPrefix">
            <summary>Prefix '{0}' is not defined.</summary>
        </member>
        <member name="P:System.SR.Xslt_ScriptXsltNamespace">
            <summary>Script block cannot implement the XSLT namespace.</summary>
        </member>
        <member name="P:System.SR.Xslt_ScriptInvalidLanguage">
            <summary>Scripting language '{0}' is not supported.</summary>
        </member>
        <member name="P:System.SR.Xslt_ScriptMixedLanguages">
            <summary>All script blocks implementing the namespace '{0}' must use the same language.</summary>
        </member>
        <member name="P:System.SR.Xslt_ScriptAndExtensionClash">
            <summary>Cannot have both an extension object and a script implementing the same namespace '{0}'.</summary>
        </member>
        <member name="P:System.SR.Xslt_NoDecimalFormat">
            <summary>Decimal format '{0}' is not defined.</summary>
        </member>
        <member name="P:System.SR.Xslt_DecimalFormatSignsNotDistinct">
            <summary>The '{0}' and '{1}' attributes of 'xsl:decimal-format' must have distinct values.</summary>
        </member>
        <member name="P:System.SR.Xslt_DecimalFormatRedefined">
            <summary>The '{0}' attribute of 'xsl:decimal-format' cannot be redefined with a value of '{1}'.</summary>
        </member>
        <member name="P:System.SR.Xslt_UnknownExtensionElement">
            <summary>'{0}' is not a recognized extension element.</summary>
        </member>
        <member name="P:System.SR.Xslt_ModeWithoutMatch">
            <summary>An 'xsl:template' element without a 'match' attribute cannot have a 'mode' attribute.</summary>
        </member>
        <member name="P:System.SR.Xslt_ModeListEmpty">
            <summary>List of modes in 'xsl:template' element can't be empty.</summary>
        </member>
        <member name="P:System.SR.Xslt_ModeListDup">
            <summary>List of modes in 'xsl:template' element can't contain duplicates ('{0}').</summary>
        </member>
        <member name="P:System.SR.Xslt_ModeListAll">
            <summary>List of modes in 'xsl:template' element can't contain token '#all' together with any other value.</summary>
        </member>
        <member name="P:System.SR.Xslt_PriorityWithoutMatch">
            <summary>An 'xsl:template' element without a 'match' attribute cannot have a 'priority' attribute.</summary>
        </member>
        <member name="P:System.SR.Xslt_InvalidApplyImports">
            <summary>An 'xsl:apply-imports' element can only occur within an 'xsl:template' element with a 'match' attribute, and cannot occur within an 'xsl:for-each' element.</summary>
        </member>
        <member name="P:System.SR.Xslt_DuplicateWithParam">
            <summary>Value of parameter '{0}' cannot be specified more than once within a single 'xsl:call-template' or 'xsl:apply-templates' element.</summary>
        </member>
        <member name="P:System.SR.Xslt_ReservedNS">
            <summary>Elements and attributes cannot belong to the reserved namespace '{0}'.</summary>
        </member>
        <member name="P:System.SR.Xslt_XmlnsAttr">
            <summary>An attribute with a local name 'xmlns' and a null namespace URI cannot be created.</summary>
        </member>
        <member name="P:System.SR.Xslt_NoWhen">
            <summary>An 'xsl:choose' element must have at least one 'xsl:when' child.</summary>
        </member>
        <member name="P:System.SR.Xslt_WhenAfterOtherwise">
            <summary>'xsl:when' must precede the 'xsl:otherwise' element.</summary>
        </member>
        <member name="P:System.SR.Xslt_DupOtherwise">
            <summary>An 'xsl:choose' element can have only one 'xsl:otherwise' child.</summary>
        </member>
        <member name="P:System.SR.Xslt_AttributeRedefinition">
            <summary>Attribute '{0}' of 'xsl:output' cannot be defined more than once with the same import precedence.</summary>
        </member>
        <member name="P:System.SR.Xslt_InvalidMethod">
            <summary>'{0}' is not a supported output method. Supported methods are 'xml', 'html', and 'text'.</summary>
        </member>
        <member name="P:System.SR.Xslt_InvalidEncoding">
            <summary>'{0}' is not a supported encoding name.</summary>
        </member>
        <member name="P:System.SR.Xslt_InvalidLanguage">
            <summary>'{0}' is not a supported language identifier.</summary>
        </member>
        <member name="P:System.SR.Xslt_InvalidCompareOption">
            <summary>String comparison option(s) '{0}' are either invalid or cannot be used together.</summary>
        </member>
        <member name="P:System.SR.Xslt_KeyNotAllowed">
            <summary>The 'key()' function cannot be used in 'use' and 'match' attributes of 'xsl:key' element.</summary>
        </member>
        <member name="P:System.SR.Xslt_VariablesNotAllowed">
            <summary>Variables cannot be used within this expression.</summary>
        </member>
        <member name="P:System.SR.Xslt_CurrentNotAllowed">
            <summary>The 'current()' function cannot be used in a pattern.</summary>
        </member>
        <member name="P:System.SR.Xslt_DocumentFuncProhibited">
            <summary>Execution of the 'document()' function was prohibited. Use the XsltSettings.EnableDocumentFunction property to enable it.</summary>
        </member>
        <member name="P:System.SR.Xslt_ScriptsProhibited">
            <summary>Execution of scripts was prohibited. Use the XsltSettings.EnableScript property to enable it.</summary>
        </member>
        <member name="P:System.SR.Xslt_ItemNull">
            <summary>Extension functions cannot return null values.</summary>
        </member>
        <member name="P:System.SR.Xslt_NodeSetNotNode">
            <summary>Cannot convert a node-set which contains zero nodes or more than one node to a single node.</summary>
        </member>
        <member name="P:System.SR.Xslt_UnsupportedClrType">
            <summary>Extension function parameters or return values which have Clr type '{0}' are not supported.</summary>
        </member>
        <member name="P:System.SR.Xslt_NotYetImplemented">
            <summary>'{0}' is not yet implemented.</summary>
        </member>
        <member name="P:System.SR.Xslt_SchemaDeclaration">
            <summary>'{0}' declaration is not permitted in non-schema aware processor.</summary>
        </member>
        <member name="P:System.SR.Xslt_SchemaAttribute">
            <summary>Attribute '{0}' is not permitted in basic XSLT processor (http://www.w3.org/TR/xslt20/#dt-basic-xslt-processor).</summary>
        </member>
        <member name="P:System.SR.Xslt_SchemaAttributeValue">
            <summary>Value '{1}' of attribute '{0}' is not permitted in basic XSLT processor (http://www.w3.org/TR/xslt20/#dt-basic-xslt-processor).</summary>
        </member>
        <member name="P:System.SR.Xslt_ElementCntSel">
            <summary>The element '{0}' cannot have both a 'select' attribute and non-empty content.</summary>
        </member>
        <member name="P:System.SR.Xslt_PerformSortCntSel">
            <summary>The element 'xsl:perform-sort' cannot have 'select' attribute any content other than 'xsl:sort' and 'xsl:fallback' instructions.</summary>
        </member>
        <member name="P:System.SR.Xslt_RequiredAndSelect">
            <summary>Mandatory parameter '{0}' must be empty and must not have a 'select' attribute.</summary>
        </member>
        <member name="P:System.SR.Xslt_NoSelectNoContent">
            <summary>Element '{0}' must have either 'select' attribute or non-empty content.</summary>
        </member>
        <member name="P:System.SR.Xslt_NonTemplateTunnel">
            <summary>Stylesheet or function parameter '{0}' cannot have attribute 'tunnel'.</summary>
        </member>
        <member name="P:System.SR.Xslt_ExcludeDefault">
            <summary>Value '#default' is used within the 'exclude-result-prefixes' attribute and the parent element of this attribute has no default namespace.</summary>
        </member>
        <member name="P:System.SR.Xslt_CollationSyntax">
            <summary>The value of an 'default-collation' attribute contains no recognized collation URI.</summary>
        </member>
        <member name="P:System.SR.Xslt_AnalyzeStringDupChild">
            <summary>'xsl:analyze-string' cannot have second child with name '{0}'.</summary>
        </member>
        <member name="P:System.SR.Xslt_AnalyzeStringChildOrder">
            <summary>When both 'xsl:matching-string' and 'xsl:non-matching-string' elements are present, 'xsl:matching-string' element must come first.</summary>
        </member>
        <member name="P:System.SR.Xslt_AnalyzeStringEmpty">
            <summary>'xsl:analyze-string' must contain either 'xsl:matching-string' or 'xsl:non-matching-string' elements or both.</summary>
        </member>
        <member name="P:System.SR.Xslt_SortStable">
            <summary>Only the first 'xsl:sort' element may have 'stable' attribute.</summary>
        </member>
        <member name="P:System.SR.Xslt_InputTypeAnnotations">
            <summary>It is an error if there is a stylesheet module in the stylesheet that specifies 'input-type-annotations'="strip" and another stylesheet module that specifies 'input-type-annotations'="preserve".</summary>
        </member>
        <member name="P:System.SR.Coll_BadOptFormat">
            <summary>Collation option '{0}' is invalid. Options must have the following format: &lt;option-name&gt;=&lt;option-value&gt;.</summary>
        </member>
        <member name="P:System.SR.Coll_Unsupported">
            <summary>The collation '{0}' is not supported.</summary>
        </member>
        <member name="P:System.SR.Coll_UnsupportedLanguage">
            <summary>Collation language '{0}' is not supported.</summary>
        </member>
        <member name="P:System.SR.Coll_UnsupportedOpt">
            <summary>Unsupported option '{0}' in collation.</summary>
        </member>
        <member name="P:System.SR.Coll_UnsupportedOptVal">
            <summary>Collation option '{0}' cannot have the value '{1}'.</summary>
        </member>
        <member name="P:System.SR.Coll_UnsupportedSortOpt">
            <summary>Unsupported sort option '{0}' in collation.</summary>
        </member>
        <member name="P:System.SR.Qil_Validation">
            <summary>QIL Validation Error! '{0}'.</summary>
        </member>
        <member name="P:System.SR.XmlIl_TooManyParameters">
            <summary>Functions may not have more than 65535 parameters.</summary>
        </member>
        <member name="P:System.SR.XmlIl_BadXmlState">
            <summary>An item of type '{0}' cannot be constructed within a node of type '{1}'.</summary>
        </member>
        <member name="P:System.SR.XmlIl_BadXmlStateAttr">
            <summary>Attribute and namespace nodes cannot be added to the parent element after a text, comment, pi, or sub-element node has already been added.</summary>
        </member>
        <member name="P:System.SR.XmlIl_NmspAfterAttr">
            <summary>Namespace nodes cannot be added to the parent element after an attribute node has already been added.</summary>
        </member>
        <member name="P:System.SR.XmlIl_NmspConflict">
            <summary>Cannot construct namespace declaration xmlns{0}{1}='{2}'. Prefix '{1}' is already mapped to namespace '{3}'.</summary>
        </member>
        <member name="P:System.SR.XmlIl_CantResolveEntity">
            <summary>Cannot query the data source object referenced by URI '{0}', because the provided XmlResolver returned an object of type '{1}'. Only Stream, XmlReader, and IXPathNavigable data source objects are currently supported.</summary>
        </member>
        <member name="P:System.SR.XmlIl_NoDefaultDocument">
            <summary>Query requires a default data source, but no default was supplied to the query engine.</summary>
        </member>
        <member name="P:System.SR.XmlIl_UnknownDocument">
            <summary>Data source '{0}' cannot be located.</summary>
        </member>
        <member name="P:System.SR.XmlIl_UnknownParam">
            <summary>Supplied XsltArgumentList does not contain a parameter with local name '{0}' and namespace '{1}'.</summary>
        </member>
        <member name="P:System.SR.XmlIl_UnknownExtObj">
            <summary>Cannot find a script or an extension object associated with namespace '{0}'.</summary>
        </member>
        <member name="P:System.SR.XmlIl_CantStripNav">
            <summary>Whitespace cannot be stripped from input documents that have already been loaded. Provide the input document as an XmlReader instead.</summary>
        </member>
        <member name="P:System.SR.XmlIl_ExtensionError">
            <summary>An error occurred during a call to extension function '{0}'. See InnerException for a complete description of the error.</summary>
        </member>
        <member name="P:System.SR.XmlIl_TopLevelAttrNmsp">
            <summary>XmlWriter cannot process the sequence returned by the query, because it contains an attribute or namespace node.</summary>
        </member>
        <member name="P:System.SR.XmlIl_NoExtensionMethod">
            <summary>Extension object '{0}' does not contain a matching '{1}' method that has {2} parameter(s).</summary>
        </member>
        <member name="P:System.SR.XmlIl_AmbiguousExtensionMethod">
            <summary>Ambiguous method call. Extension object '{0}' contains multiple '{1}' methods that have {2} parameter(s).</summary>
        </member>
        <member name="P:System.SR.XmlIl_NonPublicExtensionMethod">
            <summary>Method '{1}' of extension object '{0}' cannot be called because it is not public.</summary>
        </member>
        <member name="P:System.SR.XmlIl_GenericExtensionMethod">
            <summary>Method '{1}' of extension object '{0}' cannot be called because it is generic.</summary>
        </member>
        <member name="P:System.SR.XmlIl_ByRefType">
            <summary>Method '{1}' of extension object '{0}' cannot be called because it has one or more ByRef parameters.</summary>
        </member>
        <member name="P:System.SR.XmlIl_DocumentLoadError">
            <summary>An error occurred while loading document '{0}'. See InnerException for a complete description of the error.</summary>
        </member>
        <member name="P:System.SR.Xslt_CompileError">
            <summary>XSLT compile error at {0}({1},{2}). See InnerException for details.</summary>
        </member>
        <member name="P:System.SR.Xslt_CompileError2">
            <summary>XSLT compile error.</summary>
        </member>
        <member name="P:System.SR.Xslt_UnsuppFunction">
            <summary>'{0}()' is an unsupported XSLT function.</summary>
        </member>
        <member name="P:System.SR.Xslt_NotFirstImport">
            <summary>'xsl:import' instructions must precede all other element children of an 'xsl:stylesheet' element.</summary>
        </member>
        <member name="P:System.SR.Xslt_UnexpectedKeyword">
            <summary>'{0}' cannot be a child of the '{1}' element.</summary>
        </member>
        <member name="P:System.SR.Xslt_InvalidContents">
            <summary>The contents of '{0}' are invalid.</summary>
        </member>
        <member name="P:System.SR.Xslt_CantResolve">
            <summary>Cannot resolve the referenced document '{0}'.</summary>
        </member>
        <member name="P:System.SR.Xslt_SingleRightAvt">
            <summary>Right curly brace in the attribute value template '{0}' must be doubled.</summary>
        </member>
        <member name="P:System.SR.Xslt_OpenBracesAvt">
            <summary>The braces are not closed in AVT expression '{0}'.</summary>
        </member>
        <member name="P:System.SR.Xslt_OpenLiteralAvt">
            <summary>The literal in AVT expression is not correctly closed '{0}'.</summary>
        </member>
        <member name="P:System.SR.Xslt_NestedAvt">
            <summary>AVT cannot be nested in AVT '{0}'.</summary>
        </member>
        <member name="P:System.SR.Xslt_EmptyAvtExpr">
            <summary>XPath Expression in AVT cannot be empty: '{0}'.</summary>
        </member>
        <member name="P:System.SR.Xslt_InvalidXPath">
            <summary>'{0}' is an invalid XPath expression.</summary>
        </member>
        <member name="P:System.SR.Xslt_InvalidQName">
            <summary>'{0}' is an invalid QName.</summary>
        </member>
        <member name="P:System.SR.Xslt_TemplateNoAttrib">
            <summary>The 'xsl:template' instruction must have the 'match' and/or 'name' attribute present.</summary>
        </member>
        <member name="P:System.SR.Xslt_DupVarName">
            <summary>Variable or parameter '{0}' was duplicated within the same scope.</summary>
        </member>
        <member name="P:System.SR.Xslt_WrongNumberArgs">
            <summary>XSLT function '{0}()' has the wrong number of arguments.</summary>
        </member>
        <member name="P:System.SR.Xslt_NoNodeSetConversion">
            <summary>Cannot convert the operand to a node-set.</summary>
        </member>
        <member name="P:System.SR.Xslt_NoNavigatorConversion">
            <summary>Cannot convert the operand to 'Result tree fragment'.</summary>
        </member>
        <member name="P:System.SR.Xslt_InvalidFormat">
            <summary>Format cannot be empty.</summary>
        </member>
        <member name="P:System.SR.Xslt_InvalidFormat1">
            <summary>Format '{0}' cannot have digit symbol after zero digit symbol before a decimal point.</summary>
        </member>
        <member name="P:System.SR.Xslt_InvalidFormat2">
            <summary>Format '{0}' cannot have zero digit symbol after digit symbol after decimal point.</summary>
        </member>
        <member name="P:System.SR.Xslt_InvalidFormat3">
            <summary>Format '{0}' has two pattern separators.</summary>
        </member>
        <member name="P:System.SR.Xslt_InvalidFormat5">
            <summary>Format '{0}' cannot have two decimal separators.</summary>
        </member>
        <member name="P:System.SR.Xslt_InvalidFormat8">
            <summary>Format string should have at least one digit or zero digit.</summary>
        </member>
        <member name="P:System.SR.Xslt_ScriptInvalidPrefix">
            <summary>Cannot find the script or external object that implements prefix '{0}'.</summary>
        </member>
        <member name="P:System.SR.Xslt_ScriptEmpty">
            <summary>The 'msxsl:script' element cannot be empty.</summary>
        </member>
        <member name="P:System.SR.Xslt_DupDecimalFormat">
            <summary>Decimal format '{0}' has a duplicate declaration.</summary>
        </member>
        <member name="P:System.SR.Xslt_CircularReference">
            <summary>Circular reference in the definition of variable '{0}'.</summary>
        </member>
        <member name="P:System.SR.Xslt_InvalidExtensionNamespace">
            <summary>Extension namespace cannot be 'null' or an XSLT namespace URI.</summary>
        </member>
        <member name="P:System.SR.Xslt_InvalidModeAttribute">
            <summary>An 'xsl:template' element without a 'match' attribute cannot have a 'mode' attribute.</summary>
        </member>
        <member name="P:System.SR.Xslt_MultipleRoots">
            <summary>There are multiple root elements in the output XML.</summary>
        </member>
        <member name="P:System.SR.Xslt_ApplyImports">
            <summary>The 'xsl:apply-imports' instruction cannot be included within the content of an 'xsl:for-each' instruction or within an 'xsl:template' instruction without the 'match' attribute.</summary>
        </member>
        <member name="P:System.SR.Xslt_Terminate">
            <summary>Transform terminated: '{0}'.</summary>
        </member>
        <member name="P:System.SR.Xslt_InvalidPattern">
            <summary>'{0}' is an invalid XSLT pattern.</summary>
        </member>
        <member name="P:System.SR.XmlInvalidCharSchemaPrimitive">
            <summary>Char is not a valid schema primitive and should be treated as int in DataContract</summary>
        </member>
        <member name="P:System.SR.UnknownConstantType">
            <summary>Internal Error: Unrecognized constant type {0}.</summary>
        </member>
        <member name="P:System.SR.ArrayTypeIsNotSupported">
            <summary>Array of type {0} is not supported.</summary>
        </member>
        <member name="P:System.SR.Xslt_UpperCaseFirstNotSupported">
            <summary>Uppercase-First sorting option is not supported.</summary>
        </member>
        <member name="P:System.SR.XmlPregenTypeDynamic">
            <summary>Cannot pre-generate serialization code for type '{0}'. Pre-generation of serialization assemblies is not supported for dynamic types. Save the assembly and load it from disk to use it with XmlSerialization.</summary>
        </member>
        <member name="P:System.SR.XmlPregenOrphanType">
            <summary>Cannot pre-generate serializer for multiple assemblies. Type '{0}' does not belong to assembly {1}.</summary>
        </member>
        <member name="P:System.SR.ErrSerializerExists">
            <summary>Cannot generate serialization code {0} because the code file already exists. Use /{1} to force an overwrite of the existing file.</summary>
        </member>
        <member name="P:System.SR.ErrDirectoryExists">
            <summary>Cannot generate serialization code '{0}' because a directory with the same name already exists.</summary>
        </member>
        <member name="P:System.SR.ErrDirectoryNotExists">
            <summary>Cannot generate serialization code because directory {0} doesn't exist.</summary>
        </member>
        <member name="P:System.SR.ErrInvalidArgument">
            <summary>Ignoring invalid command line argument: '{0}'.</summary>
        </member>
        <member name="P:System.SR.Warning">
            <summary>Warning: {0}.</summary>
        </member>
        <member name="P:System.SR.ErrMissingRequiredArgument">
            <summary>Missing required command-line argument: {0}.</summary>
        </member>
        <member name="P:System.SR.ErrAssembly">
            <summary>The name of the source assembly.</summary>
        </member>
        <member name="P:System.SR.InfoGeneratedFile">
            <summary>Generated serialization code for assembly {0} --&gt; '{1}'.</summary>
        </member>
        <member name="P:System.SR.InfoFileName">
            <summary>Serialization Code File Name: {0}.</summary>
        </member>
        <member name="P:System.SR.ErrGenerationFailed">
            <summary>Sgen utility failed to pregenerate serialization code for {0}.</summary>
        </member>
        <member name="P:System.SR.ErrorDetails">
            <summary>Error: {0}.</summary>
        </member>
        <member name="P:System.SR.ErrLoadType">
            <summary>Type '{0}' was not found in the assembly '{1}'.</summary>
        </member>
        <member name="P:System.SR.DirectoryAccessDenied">
            <summary>Access to directory {0} is denied.  The process under which XmlSerializer is running does not have sufficient permission to access the directory.</summary>
        </member>
        <member name="P:System.SR.ErrLoadAssembly">
            <summary>File or assembly name '{0}', or one of its dependencies, was not found.</summary>
        </member>
        <member name="P:System.SR.InfoNoSerializableTypes">
            <summary>Assembly '{0}' does not contain any types that can be serialized using XmlSerializer.</summary>
        </member>
        <member name="P:System.SR.InfoIgnoreType">
            <summary>Ignoring '{0}'.</summary>
        </member>
        <member name="P:System.SR.FailLoadAssemblyUnderPregenMode">
            <summary>"Fail to load assembly {0} or {0} doesn't exist under PreGen Mode.</summary>
        </member>
        <member name="P:System.SR.HelpDescription">
            <summary>Generates serialization code for use with XmlSerializer.
            The utility allows developers to pre-generate code for serialization
            building and deploying the assemblies with the application.</summary>
        </member>
        <member name="P:System.SR.HelpUsage">
            <summary>Usage: dotnet {0} [--assembly &lt;assembly file path&gt;] [--type &lt;type name&gt;]</summary>
        </member>
        <member name="P:System.SR.HelpDevOptions">
            <summary>Developer options:</summary>
        </member>
        <member name="P:System.SR.HelpAssembly">
            <summary>{0}|{1}   Assembly location or display name.</summary>
        </member>
        <member name="P:System.SR.HelpType">
            <summary>{0}          Generate code for serialization/deserialization of the specified type from the input assembly.</summary>
        </member>
        <member name="P:System.SR.HelpForce">
            <summary>{0}         Forces overwrite of a previously generated assembly.</summary>
        </member>
        <member name="P:System.SR.HelpProxy">
            <summary>{0}    Generate serialization code only for proxy classes and web method parameters.</summary>
        </member>
        <member name="P:System.SR.HelpOut">
            <summary>{0}|{1}        Output directory name (default: target assembly location).</summary>
        </member>
        <member name="P:System.SR.HelpMiscOptions">
            <summary>Miscellaneous options:</summary>
        </member>
        <member name="P:System.SR.HelpHelp">
            <summary>{0}|{1}       Show help.</summary>
        </member>
        <member name="P:System.SR.GenerateSerializerNotFound">
            <summary>Method 'System.Xml.Serialization.XmlSerializer.GenerateSerializer' was not found. This is likely because you are using an older version of the framework. Please update to .NET Core v2.1 or later.</summary>
        </member>
        <member name="P:System.SR.CodeGenConvertError">
            <summary>CodeGenError({0}): Cannot convert source type [{1}] to target type [{2}].</summary>
        </member>
        <member name="P:System.SR.CompilingScriptsNotSupported">
            <summary>Compiling JScript/CSharp scripts is not supported</summary>
        </member>
        <member name="P:System.SR.ImportInfo">
            <summary>Importing {0} ({1}/{2})</summary>
        </member>
        <member name="T:MS.Internal.Xml.Cache.TextBlockType">
            <summary>
            Although the XPath data model does not differentiate between text and whitespace, Managed Xml 1.0
            does.  Therefore, when building from an XmlReader, we must preserve these designations in order
            to remain backwards-compatible.
            </summary>
        </member>
        <member name="T:MS.Internal.Xml.Cache.XPathDocumentBuilder">
            <summary>
            Implementation of XmlRawWriter that builds nodes in an XPathDocument.
            </summary>
        </member>
        <member name="M:MS.Internal.Xml.Cache.XPathDocumentBuilder.#ctor(System.Xml.XPath.XPathDocument,System.Xml.IXmlLineInfo,System.String,System.Xml.XPath.XPathDocument.LoadFlags)">
            <summary>
            Create a new XPathDocumentBuilder which creates nodes in "doc".
            </summary>
        </member>
        <member name="M:MS.Internal.Xml.Cache.XPathDocumentBuilder.Initialize(System.Xml.XPath.XPathDocument,System.Xml.IXmlLineInfo,System.String,System.Xml.XPath.XPathDocument.LoadFlags)">
            <summary>
            Start construction of a new document.  This must be called before any other methods are called.
            It may also be called after Close(), in order to build further documents.
            </summary>
        </member>
        <member name="M:MS.Internal.Xml.Cache.XPathDocumentBuilder.WriteDocType(System.String,System.String,System.String,System.String)">
            <summary>
            XPathDocument ignores the DocType information.
            </summary>
        </member>
        <member name="M:MS.Internal.Xml.Cache.XPathDocumentBuilder.WriteStartElement(System.String,System.String,System.String)">
            <summary>
            Shortcut for calling WriteStartElement with elemType == null.
            </summary>
        </member>
        <member name="M:MS.Internal.Xml.Cache.XPathDocumentBuilder.WriteStartElement(System.String,System.String,System.String,System.String)">
            <summary>
            Build an element node and attach it to its parent, if one exists.  Make the element the new parent node.
            </summary>
        </member>
        <member name="M:MS.Internal.Xml.Cache.XPathDocumentBuilder.WriteEndElement">
            <summary>
            Must be called when an element node's children have been fully enumerated.
            </summary>
        </member>
        <member name="M:MS.Internal.Xml.Cache.XPathDocumentBuilder.WriteFullEndElement">
            <summary>
            Must be called when an element node's children have been fully enumerated.
            </summary>
        </member>
        <member name="M:MS.Internal.Xml.Cache.XPathDocumentBuilder.WriteEndElement(System.String,System.String,System.String)">
            <summary>
            Must be called when an element node's children have been fully enumerated.
            </summary>
        </member>
        <member name="M:MS.Internal.Xml.Cache.XPathDocumentBuilder.WriteFullEndElement(System.String,System.String,System.String)">
            <summary>
            Must be called when an element node's children have been fully enumerated.
            </summary>
        </member>
        <member name="M:MS.Internal.Xml.Cache.XPathDocumentBuilder.WriteEndElement(System.Boolean)">
            <summary>
            Must be called when an element node's children have been fully enumerated.
            </summary>
        </member>
        <member name="M:MS.Internal.Xml.Cache.XPathDocumentBuilder.WriteStartAttribute(System.String,System.String,System.String)">
            <summary>
            Shortcut for calling WriteStartAttribute with attrfType == null.
            </summary>
        </member>
        <member name="M:MS.Internal.Xml.Cache.XPathDocumentBuilder.WriteEndAttribute">
            <summary>
            Attach the attribute's text or typed value to the previously constructed attribute node.
            </summary>
        </member>
        <member name="M:MS.Internal.Xml.Cache.XPathDocumentBuilder.WriteCData(System.String)">
            <summary>
            Map CData text into regular text.
            </summary>
        </member>
        <member name="M:MS.Internal.Xml.Cache.XPathDocumentBuilder.WriteComment(System.String)">
            <summary>
            Construct comment node.
            </summary>
        </member>
        <member name="M:MS.Internal.Xml.Cache.XPathDocumentBuilder.WriteProcessingInstruction(System.String,System.String)">
            <summary>
            Shortcut for calling WriteProcessingInstruction with baseUri = string.Empty.
            </summary>
        </member>
        <member name="M:MS.Internal.Xml.Cache.XPathDocumentBuilder.WriteProcessingInstruction(System.String,System.String,System.String)">
            <summary>
            Construct pi node.
            </summary>
        </member>
        <member name="M:MS.Internal.Xml.Cache.XPathDocumentBuilder.WriteWhitespace(System.String)">
            <summary>
            Write a whitespace text block.
            </summary>
        </member>
        <member name="M:MS.Internal.Xml.Cache.XPathDocumentBuilder.WriteString(System.String)">
            <summary>
            Write an attribute or element text block.
            </summary>
        </member>
        <member name="M:MS.Internal.Xml.Cache.XPathDocumentBuilder.WriteRaw(System.String)">
            <summary>
            Map RawText to Text.  This will lose entitization and won't roundtrip.
            </summary>
        </member>
        <member name="M:MS.Internal.Xml.Cache.XPathDocumentBuilder.WriteString(System.String,MS.Internal.Xml.Cache.TextBlockType)">
            <summary>
            Write an element text block with the specified text type (whitespace, significant whitespace, or text).
            </summary>
        </member>
        <member name="M:MS.Internal.Xml.Cache.XPathDocumentBuilder.WriteEntityRef(System.String)">
            <summary>
            Cache does not handle entity references.
            </summary>
        </member>
        <member name="M:MS.Internal.Xml.Cache.XPathDocumentBuilder.WriteCharEntity(System.Char)">
            <summary>
            Don't entitize, since the cache cannot represent character entities.
            </summary>
        </member>
        <member name="M:MS.Internal.Xml.Cache.XPathDocumentBuilder.WriteSurrogateCharEntity(System.Char,System.Char)">
            <summary>
            Don't entitize, since the cache cannot represent character entities.
            </summary>
        </member>
        <member name="M:MS.Internal.Xml.Cache.XPathDocumentBuilder.Close">
            <summary>
            Signals the end of tree construction.
            </summary>
        </member>
        <member name="M:MS.Internal.Xml.Cache.XPathDocumentBuilder.Flush">
            <summary>
            Since output is not forwarded to another object, this does nothing.
            </summary>
        </member>
        <member name="M:MS.Internal.Xml.Cache.XPathDocumentBuilder.WriteXmlDeclaration(System.Xml.XmlStandalone)">
            <summary>
            Write the xml declaration.  This must be the first call after Open.
            </summary>
        </member>
        <member name="M:MS.Internal.Xml.Cache.XPathDocumentBuilder.StartElementContent">
            <summary>
            Called as element node's children are about to be enumerated.
            </summary>
        </member>
        <member name="M:MS.Internal.Xml.Cache.XPathDocumentBuilder.WriteNamespaceDeclaration(System.String,System.String)">
            <summary>
            Build a namespace declaration node.  Attach it to an element parent, if one was previously constructed.
            All namespace declarations are linked together in an in-scope namespace tree.
            </summary>
        </member>
        <member name="M:MS.Internal.Xml.Cache.XPathDocumentBuilder.CreateIdTables(System.Xml.IDtdInfo)">
            <summary>
            Build ID lookup tables from the XSD schema or DTD.
            </summary>
        </member>
        <member name="M:MS.Internal.Xml.Cache.XPathDocumentBuilder.LinkSimilarElements(MS.Internal.Xml.Cache.XPathNode[],System.Int32,MS.Internal.Xml.Cache.XPathNode[],System.Int32)">
            <summary>
            Link "prev" element with "next" element, which has a "similar" name.  This increases the performance of searches by element name.
            </summary>
        </member>
        <member name="M:MS.Internal.Xml.Cache.XPathDocumentBuilder.NewNamespaceNode(MS.Internal.Xml.Cache.XPathNode[]@,System.String,System.String,MS.Internal.Xml.Cache.XPathNode[],System.Int32)">
            <summary>
            Helper method that constructs a new Namespace XPathNode.
            </summary>
        </member>
        <member name="M:MS.Internal.Xml.Cache.XPathDocumentBuilder.NewNode(MS.Internal.Xml.Cache.XPathNode[]@,System.Xml.XPath.XPathNodeType,System.String,System.String,System.String,System.String)">
            <summary>
            Helper method that constructs a new XPathNode.
            </summary>
        </member>
        <member name="M:MS.Internal.Xml.Cache.XPathDocumentBuilder.ComputeLineInfo(System.Boolean,System.Int32@,System.Int32@)">
            <summary>
            Compute current node's line number information.
            </summary>
        </member>
        <member name="M:MS.Internal.Xml.Cache.XPathDocumentBuilder.AddSibling(System.Xml.XPath.XPathNodeType,System.String,System.String,System.String,System.String)">
            <summary>
            Add a sibling node.  If no previous sibling exists, add the node as the first child of the parent.
            If no parent exists, make this node the root of the document.
            </summary>
        </member>
        <member name="M:MS.Internal.Xml.Cache.XPathDocumentBuilder.CachedTextNode">
            <summary>
            Creates a text node from cached text parts.
            </summary>
        </member>
        <member name="T:MS.Internal.Xml.Cache.XPathDocumentBuilder.NodePageFactory">
            <summary>
            Allocates pages of nodes for the XPathDocumentBuilder.  The initial pages and arrays are
            fairly small.  As each page fills, a new page that is twice as big is allocated.
            The max size of a page is 65536 nodes, since XPathNode indexes are 16-bits.
            </summary>
        </member>
        <member name="M:MS.Internal.Xml.Cache.XPathDocumentBuilder.NodePageFactory.Init(System.Int32)">
            <summary>
            Allocates and returns the initial node page.
            </summary>
        </member>
        <member name="P:MS.Internal.Xml.Cache.XPathDocumentBuilder.NodePageFactory.NextNodePage">
            <summary>
            Return the page on which the next node will be allocated.
            </summary>
        </member>
        <member name="P:MS.Internal.Xml.Cache.XPathDocumentBuilder.NodePageFactory.NextNodeIndex">
            <summary>
            Return the page index that the next node will be given.
            </summary>
        </member>
        <member name="M:MS.Internal.Xml.Cache.XPathDocumentBuilder.NodePageFactory.AllocateSlot(MS.Internal.Xml.Cache.XPathNode[]@,System.Int32@)">
            <summary>
            Allocate the next slot in the current node page.  Return a reference to the page and the index
            of the allocated slot.
            </summary>
        </member>
        <member name="T:MS.Internal.Xml.Cache.XPathDocumentBuilder.TextBlockBuilder">
            <summary>
            This class concatenates adjacent text blocks and tracks TextBlockType and line number information.
            </summary>
        </member>
        <member name="M:MS.Internal.Xml.Cache.XPathDocumentBuilder.TextBlockBuilder.Initialize(System.Xml.IXmlLineInfo)">
            <summary>
            Constructor.
            </summary>
        </member>
        <member name="P:MS.Internal.Xml.Cache.XPathDocumentBuilder.TextBlockBuilder.TextType">
            <summary>
            Return the type of the cached text block.
            </summary>
        </member>
        <member name="P:MS.Internal.Xml.Cache.XPathDocumentBuilder.TextBlockBuilder.HasText">
            <summary>
            Returns true if text has been cached.
            </summary>
        </member>
        <member name="P:MS.Internal.Xml.Cache.XPathDocumentBuilder.TextBlockBuilder.LineNumber">
            <summary>
            Returns the line number of the last text block to be cached.
            </summary>
        </member>
        <member name="P:MS.Internal.Xml.Cache.XPathDocumentBuilder.TextBlockBuilder.LinePosition">
            <summary>
            Returns the line position of the last text block to be cached.
            </summary>
        </member>
        <member name="M:MS.Internal.Xml.Cache.XPathDocumentBuilder.TextBlockBuilder.WriteTextBlock(System.String,MS.Internal.Xml.Cache.TextBlockType)">
            <summary>
            Append a text block with the specified type.
            </summary>
        </member>
        <member name="M:MS.Internal.Xml.Cache.XPathDocumentBuilder.TextBlockBuilder.ReadText">
            <summary>
            Read all cached text, or string.Empty if no text has been cached, and clear the text block type.
            </summary>
        </member>
        <member name="T:MS.Internal.Xml.Cache.XPathDocumentBaseIterator">
            <summary>
            Base internal class of all XPathDocument XPathNodeIterator implementations.
            </summary>
        </member>
        <member name="M:MS.Internal.Xml.Cache.XPathDocumentBaseIterator.#ctor(MS.Internal.Xml.Cache.XPathDocumentNavigator)">
            <summary>
            Create a new iterator that is initially positioned on the "ctxt" node.
            </summary>
        </member>
        <member name="M:MS.Internal.Xml.Cache.XPathDocumentBaseIterator.#ctor(MS.Internal.Xml.Cache.XPathDocumentBaseIterator)">
            <summary>
            Create a new iterator that is a copy of "iter".
            </summary>
        </member>
        <member name="P:MS.Internal.Xml.Cache.XPathDocumentBaseIterator.Current">
            <summary>
            Return the current navigator.
            </summary>
        </member>
        <member name="P:MS.Internal.Xml.Cache.XPathDocumentBaseIterator.CurrentPosition">
            <summary>
            Return the iterator's current position.
            </summary>
        </member>
        <member name="T:MS.Internal.Xml.Cache.XPathDocumentElementChildIterator">
            <summary>
            Iterate over all element children with a particular QName.
            </summary>
        </member>
        <member name="M:MS.Internal.Xml.Cache.XPathDocumentElementChildIterator.#ctor(MS.Internal.Xml.Cache.XPathDocumentNavigator,System.String,System.String)">
            <summary>
            Create an iterator that ranges over all element children of "parent" having the specified QName.
            </summary>
        </member>
        <member name="M:MS.Internal.Xml.Cache.XPathDocumentElementChildIterator.#ctor(MS.Internal.Xml.Cache.XPathDocumentElementChildIterator)">
            <summary>
            Create a new iterator that is a copy of "iter".
            </summary>
        </member>
        <member name="M:MS.Internal.Xml.Cache.XPathDocumentElementChildIterator.Clone">
            <summary>
            Create a copy of this iterator.
            </summary>
        </member>
        <member name="M:MS.Internal.Xml.Cache.XPathDocumentElementChildIterator.MoveNext">
            <summary>
            Position the iterator to the next matching child.
            </summary>
        </member>
        <member name="T:MS.Internal.Xml.Cache.XPathDocumentKindChildIterator">
            <summary>
            Iterate over all content children with a particular XPathNodeType.
            </summary>
        </member>
        <member name="M:MS.Internal.Xml.Cache.XPathDocumentKindChildIterator.#ctor(MS.Internal.Xml.Cache.XPathDocumentNavigator,System.Xml.XPath.XPathNodeType)">
            <summary>
            Create an iterator that ranges over all content children of "parent" having the specified XPathNodeType.
            </summary>
        </member>
        <member name="M:MS.Internal.Xml.Cache.XPathDocumentKindChildIterator.#ctor(MS.Internal.Xml.Cache.XPathDocumentKindChildIterator)">
            <summary>
            Create a new iterator that is a copy of "iter".
            </summary>
        </member>
        <member name="M:MS.Internal.Xml.Cache.XPathDocumentKindChildIterator.Clone">
            <summary>
            Create a copy of this iterator.
            </summary>
        </member>
        <member name="M:MS.Internal.Xml.Cache.XPathDocumentKindChildIterator.MoveNext">
            <summary>
            Position the iterator to the next descendant.
            </summary>
        </member>
        <member name="T:MS.Internal.Xml.Cache.XPathDocumentElementDescendantIterator">
            <summary>
            Iterate over all element descendants with a particular QName.
            </summary>
        </member>
        <member name="M:MS.Internal.Xml.Cache.XPathDocumentElementDescendantIterator.#ctor(MS.Internal.Xml.Cache.XPathDocumentNavigator,System.String,System.String,System.Boolean)">
            <summary>
            Create an iterator that ranges over all element descendants of "root" having the specified QName.
            </summary>
        </member>
        <member name="M:MS.Internal.Xml.Cache.XPathDocumentElementDescendantIterator.#ctor(MS.Internal.Xml.Cache.XPathDocumentElementDescendantIterator)">
            <summary>
            Create a new iterator that is a copy of "iter".
            </summary>
        </member>
        <member name="M:MS.Internal.Xml.Cache.XPathDocumentElementDescendantIterator.Clone">
            <summary>
            Create a copy of this iterator.
            </summary>
        </member>
        <member name="M:MS.Internal.Xml.Cache.XPathDocumentElementDescendantIterator.MoveNext">
            <summary>
            Position the iterator to the next descendant.
            </summary>
        </member>
        <member name="T:MS.Internal.Xml.Cache.XPathDocumentKindDescendantIterator">
            <summary>
            Iterate over all content descendants with a particular XPathNodeType.
            </summary>
        </member>
        <member name="M:MS.Internal.Xml.Cache.XPathDocumentKindDescendantIterator.#ctor(MS.Internal.Xml.Cache.XPathDocumentNavigator,System.Xml.XPath.XPathNodeType,System.Boolean)">
            <summary>
            Create an iterator that ranges over all content descendants of "root" having the specified XPathNodeType.
            </summary>
        </member>
        <member name="M:MS.Internal.Xml.Cache.XPathDocumentKindDescendantIterator.#ctor(MS.Internal.Xml.Cache.XPathDocumentKindDescendantIterator)">
            <summary>
            Create a new iterator that is a copy of "iter".
            </summary>
        </member>
        <member name="M:MS.Internal.Xml.Cache.XPathDocumentKindDescendantIterator.Clone">
            <summary>
            Create a copy of this iterator.
            </summary>
        </member>
        <member name="M:MS.Internal.Xml.Cache.XPathDocumentKindDescendantIterator.MoveNext">
            <summary>
            Position the iterator to the next descendant.
            </summary>
        </member>
        <member name="T:MS.Internal.Xml.Cache.XPathDocumentNavigator">
            <summary>
            This is the default XPath/XQuery data model cache implementation.  It will be used whenever
            the user does not supply their own XPathNavigator implementation.
            </summary>
        </member>
        <member name="M:MS.Internal.Xml.Cache.XPathDocumentNavigator.#ctor(MS.Internal.Xml.Cache.XPathNode[],System.Int32,MS.Internal.Xml.Cache.XPathNode[],System.Int32)">
            <summary>
            Create a new navigator positioned on the specified current node.  If the current node is a namespace or a collapsed
            text node, then the parent is a virtualized parent (may be different than .Parent on the current node).
            </summary>
        </member>
        <member name="M:MS.Internal.Xml.Cache.XPathDocumentNavigator.#ctor(MS.Internal.Xml.Cache.XPathDocumentNavigator)">
            <summary>
            Copy constructor.
            </summary>
        </member>
        <member name="P:MS.Internal.Xml.Cache.XPathDocumentNavigator.Value">
            <summary>
            Get the string value of the current node, computed using data model dm:string-value rules.
            If the node has a typed value, return the string representation of the value.  If the node
            is not a parent type (comment, text, pi, etc.), get its simple text value.  Otherwise,
            concatenate all text node descendants of the current node.
            </summary>
        </member>
        <member name="M:MS.Internal.Xml.Cache.XPathDocumentNavigator.Clone">
            <summary>
            Create a copy of this navigator, positioned to the same node in the tree.
            </summary>
        </member>
        <member name="P:MS.Internal.Xml.Cache.XPathDocumentNavigator.NodeType">
            <summary>
            Get the XPath node type of the current node.
            </summary>
        </member>
        <member name="P:MS.Internal.Xml.Cache.XPathDocumentNavigator.LocalName">
            <summary>
            Get the local name portion of the current node's name.
            </summary>
        </member>
        <member name="P:MS.Internal.Xml.Cache.XPathDocumentNavigator.NamespaceURI">
            <summary>
            Get the namespace portion of the current node's name.
            </summary>
        </member>
        <member name="P:MS.Internal.Xml.Cache.XPathDocumentNavigator.Name">
            <summary>
            Get the name of the current node.
            </summary>
        </member>
        <member name="P:MS.Internal.Xml.Cache.XPathDocumentNavigator.Prefix">
            <summary>
            Get the prefix portion of the current node's name.
            </summary>
        </member>
        <member name="P:MS.Internal.Xml.Cache.XPathDocumentNavigator.BaseURI">
            <summary>
            Get the base URI of the current node.
            </summary>
        </member>
        <member name="P:MS.Internal.Xml.Cache.XPathDocumentNavigator.IsEmptyElement">
            <summary>
            Return true if this is an element which used a shortcut tag in its Xml 1.0 serialized form.
            </summary>
        </member>
        <member name="P:MS.Internal.Xml.Cache.XPathDocumentNavigator.NameTable">
            <summary>
            Return the xml name table which was used to atomize all prefixes, local-names, and
            namespace uris in the document.
            </summary>
        </member>
        <member name="M:MS.Internal.Xml.Cache.XPathDocumentNavigator.MoveToFirstAttribute">
            <summary>
            Position the navigator on the first attribute of the current node and return true.  If no attributes
            can be found, return false.
            </summary>
        </member>
        <member name="M:MS.Internal.Xml.Cache.XPathDocumentNavigator.MoveToNextAttribute">
            <summary>
            If positioned on an attribute, move to its next sibling attribute.  If no attributes can be found,
            return false.
            </summary>
        </member>
        <member name="P:MS.Internal.Xml.Cache.XPathDocumentNavigator.HasAttributes">
            <summary>
            True if the current node has one or more attributes.
            </summary>
        </member>
        <member name="M:MS.Internal.Xml.Cache.XPathDocumentNavigator.MoveToAttribute(System.String,System.String)">
            <summary>
            Position the navigator on the attribute with the specified name and return true.  If no matching
            attribute can be found, return false.  Don't assume the name parts are atomized with respect
            to this document.
            </summary>
        </member>
        <member name="M:MS.Internal.Xml.Cache.XPathDocumentNavigator.MoveToFirstNamespace(System.Xml.XPath.XPathNamespaceScope)">
            <summary>
            Position the navigator on the namespace within the specified scope.  If no matching namespace
            can be found, return false.
            </summary>
        </member>
        <member name="M:MS.Internal.Xml.Cache.XPathDocumentNavigator.MoveToNextNamespace(System.Xml.XPath.XPathNamespaceScope)">
            <summary>
            Position the navigator on the next namespace within the specified scope.  If no matching namespace
            can be found, return false.
            </summary>
        </member>
        <member name="M:MS.Internal.Xml.Cache.XPathDocumentNavigator.MoveToNext">
            <summary>
            If the current node is an attribute or namespace (not content), return false.  Otherwise,
            move to the next content node.  Return false if there are no more content nodes.
            </summary>
        </member>
        <member name="M:MS.Internal.Xml.Cache.XPathDocumentNavigator.MoveToPrevious">
            <summary>
            If the current node is an attribute or namespace (not content), return false.  Otherwise,
            move to the previous (sibling) content node.  Return false if there are no previous content nodes.
            </summary>
        </member>
        <member name="M:MS.Internal.Xml.Cache.XPathDocumentNavigator.MoveToFirstChild">
            <summary>
            Move to the first content-typed child of the current node.  Return false if the current
            node has no content children.
            </summary>
        </member>
        <member name="M:MS.Internal.Xml.Cache.XPathDocumentNavigator.MoveToParent">
            <summary>
            Position the navigator on the parent of the current node.  If the current node has no parent,
            return false.
            </summary>
        </member>
        <member name="M:MS.Internal.Xml.Cache.XPathDocumentNavigator.MoveTo(System.Xml.XPath.XPathNavigator)">
            <summary>
            Position this navigator to the same position as the "other" navigator.  If the "other" navigator
            is not of the same type as this navigator, then return false.
            </summary>
        </member>
        <member name="M:MS.Internal.Xml.Cache.XPathDocumentNavigator.MoveToId(System.String)">
            <summary>
            Position to the navigator to the element whose id is equal to the specified "id" string.
            </summary>
        </member>
        <member name="M:MS.Internal.Xml.Cache.XPathDocumentNavigator.IsSamePosition(System.Xml.XPath.XPathNavigator)">
            <summary>
            Returns true if this navigator is positioned to the same node as the "other" navigator.  Returns false
            if not, or if the "other" navigator is not the same type as this navigator.
            </summary>
        </member>
        <member name="P:MS.Internal.Xml.Cache.XPathDocumentNavigator.HasChildren">
            <summary>
            Returns true if the current node has children.
            </summary>
        </member>
        <member name="M:MS.Internal.Xml.Cache.XPathDocumentNavigator.MoveToRoot">
            <summary>
            Position the navigator on the root node of the current document.
            </summary>
        </member>
        <member name="M:MS.Internal.Xml.Cache.XPathDocumentNavigator.MoveToChild(System.String,System.String)">
            <summary>
            Move to the first element child of the current node with the specified name.  Return false
            if the current node has no matching element children.
            </summary>
        </member>
        <member name="M:MS.Internal.Xml.Cache.XPathDocumentNavigator.MoveToNext(System.String,System.String)">
            <summary>
            Move to the first element sibling of the current node with the specified name.  Return false
            if the current node has no matching element siblings.
            </summary>
        </member>
        <member name="M:MS.Internal.Xml.Cache.XPathDocumentNavigator.MoveToChild(System.Xml.XPath.XPathNodeType)">
            <summary>
            Move to the first content child of the current node with the specified type.  Return false
            if the current node has no matching children.
            </summary>
        </member>
        <member name="M:MS.Internal.Xml.Cache.XPathDocumentNavigator.MoveToNext(System.Xml.XPath.XPathNodeType)">
            <summary>
            Move to the first content sibling of the current node with the specified type.  Return false
            if the current node has no matching siblings.
            </summary>
        </member>
        <member name="M:MS.Internal.Xml.Cache.XPathDocumentNavigator.MoveToFollowing(System.String,System.String,System.Xml.XPath.XPathNavigator)">
            <summary>
            Move to the next element that:
              1. Follows the current node in document order (includes descendants, unlike XPath following axis)
              2. Precedes "end" in document order (if end is null, then all following nodes in the document are considered)
              3. Has the specified QName
            Return false if the current node has no matching following elements.
            </summary>
        </member>
        <member name="M:MS.Internal.Xml.Cache.XPathDocumentNavigator.MoveToFollowing(System.Xml.XPath.XPathNodeType,System.Xml.XPath.XPathNavigator)">
            <summary>
            Move to the next node that:
              1. Follows the current node in document order (includes descendants, unlike XPath following axis)
              2. Precedes "end" in document order (if end is null, then all following nodes in the document are considered)
              3. Has the specified XPathNodeType
            Return false if the current node has no matching following nodes.
            </summary>
        </member>
        <member name="M:MS.Internal.Xml.Cache.XPathDocumentNavigator.SelectChildren(System.Xml.XPath.XPathNodeType)">
            <summary>
            Return an iterator that ranges over all children of the current node that match the specified XPathNodeType.
            </summary>
        </member>
        <member name="M:MS.Internal.Xml.Cache.XPathDocumentNavigator.SelectChildren(System.String,System.String)">
            <summary>
            Return an iterator that ranges over all children of the current node that match the specified QName.
            </summary>
        </member>
        <member name="M:MS.Internal.Xml.Cache.XPathDocumentNavigator.SelectDescendants(System.Xml.XPath.XPathNodeType,System.Boolean)">
            <summary>
            Return an iterator that ranges over all descendants of the current node that match the specified
            XPathNodeType.  If matchSelf is true, then also perform the match on the current node.
            </summary>
        </member>
        <member name="M:MS.Internal.Xml.Cache.XPathDocumentNavigator.SelectDescendants(System.String,System.String,System.Boolean)">
            <summary>
            Return an iterator that ranges over all descendants of the current node that match the specified
            QName.  If matchSelf is true, then also perform the match on the current node.
            </summary>
        </member>
        <member name="M:MS.Internal.Xml.Cache.XPathDocumentNavigator.ComparePosition(System.Xml.XPath.XPathNavigator)">
            <summary>
            Returns:
                XmlNodeOrder.Unknown -- This navigator and the "other" navigator are not of the same type, or the
                                        navigator's are not positioned on nodes in the same document.
                XmlNodeOrder.Before -- This navigator's current node is before the "other" navigator's current node
                                       in document order.
                XmlNodeOrder.After -- This navigator's current node is after the "other" navigator's current node
                                      in document order.
                XmlNodeOrder.Same -- This navigator is positioned on the same node as the "other" navigator.
            </summary>
        </member>
        <member name="M:MS.Internal.Xml.Cache.XPathDocumentNavigator.IsDescendant(System.Xml.XPath.XPathNavigator)">
            <summary>
            Return true if the "other" navigator's current node is a descendant of this navigator's current node.
            </summary>
        </member>
        <member name="M:MS.Internal.Xml.Cache.XPathDocumentNavigator.GetPrimaryLocation">
            <summary>
            Construct a primary location for this navigator.  The location is an integer that can be
            easily compared with other locations in the same document in order to determine the relative
            document order of two nodes.  If two locations compare equal, then secondary locations should
            be compared.
            </summary>
        </member>
        <member name="M:MS.Internal.Xml.Cache.XPathDocumentNavigator.GetSecondaryLocation">
            <summary>
            Construct a secondary location for this navigator.  This location should only be used if
            primary locations previously compared equal.
            </summary>
        </member>
        <member name="P:MS.Internal.Xml.Cache.XPathDocumentNavigator.UniqueId">
            <summary>
            Create a unique id for the current node.  This is used by the generate-id() function.
            </summary>
        </member>
        <member name="M:MS.Internal.Xml.Cache.XPathDocumentNavigator.HasLineInfo">
            <summary>
            Return true if line number information is recorded in the cache.
            </summary>
        </member>
        <member name="P:MS.Internal.Xml.Cache.XPathDocumentNavigator.LineNumber">
            <summary>
            Return the source line number of the current node.
            </summary>
        </member>
        <member name="P:MS.Internal.Xml.Cache.XPathDocumentNavigator.LinePosition">
            <summary>
            Return the source line position of the current node.
            </summary>
        </member>
        <member name="M:MS.Internal.Xml.Cache.XPathDocumentNavigator.GetPositionHashCode">
            <summary>
            Get hashcode based on current position of the navigator.
            </summary>
        </member>
        <member name="M:MS.Internal.Xml.Cache.XPathDocumentNavigator.IsElementMatch(System.String,System.String)">
            <summary>
            Return true if navigator is positioned to an element having the specified name.
            </summary>
        </member>
        <member name="M:MS.Internal.Xml.Cache.XPathDocumentNavigator.IsKindMatch(System.Xml.XPath.XPathNodeType)">
            <summary>
            Return true if navigator is positioned to a node of the specified kind.  Whitespace/SignificantWhitespace/Text are
            all treated the same (i.e. they all match each other).
            </summary>
        </member>
        <member name="M:MS.Internal.Xml.Cache.XPathDocumentNavigator.GetFollowingEnd(MS.Internal.Xml.Cache.XPathDocumentNavigator,System.Boolean,MS.Internal.Xml.Cache.XPathNode[]@)">
            <summary>
            "end" is positioned on a node which terminates a following scan.  Return the page and index of "end" if it
            is positioned to a non-virtual node.  If "end" is positioned to a virtual node:
               1. If useParentOfVirtual is true, then return the page and index of the virtual node's parent
               2. If useParentOfVirtual is false, then return the page and index of the virtual node's parent + 1.
            </summary>
        </member>
        <member name="T:MS.Internal.Xml.Cache.XPathNode">
            <summary>
            Implementation of a Node in the XPath/XQuery data model.
            1.  All nodes are stored in variable-size pages (max 65536 nodes/page) of XPathNode structuSR.
            2.  Pages are sequentially numbered.  Nodes are allocated in strict document order.
            3.  Node references take the form of a (page, index) pair.
            4.  Each node explicitly stores a parent and a sibling reference.
            5.  If a node has one or more attributes and/or non-collapsed content children, then its first
                child is stored in the next slot.  If the node is in the last slot of a page, then its first
                child is stored in the first slot of the next page.
            6.  Attributes are linked together at the start of the child list.
            7.  Namespaces are allocated in totally separate pages.  Elements are associated with
                declared namespaces via a hashtable map in the document.
            8.  Name parts are always non-null (string.Empty for nodes without names)
            9.  XPathNodeInfoAtom contains all information that is common to many nodes in a
                document, and therefore is atomized to save space.  This includes the document, the name,
                the child, sibling, parent, and value pages, and the schema type.
            10. The node structure is 20 bytes in length.  Out-of-line overhead is typically 2-4 bytes per node.
            </summary>
        </member>
        <member name="P:MS.Internal.Xml.Cache.XPathNode.NodeType">
            <summary>
            Returns the type of this node
            </summary>
        </member>
        <member name="P:MS.Internal.Xml.Cache.XPathNode.Prefix">
            <summary>
            Returns the namespace prefix of this node.  If this node has no prefix, then the empty string
            will be returned (never null).
            </summary>
        </member>
        <member name="P:MS.Internal.Xml.Cache.XPathNode.LocalName">
            <summary>
            Returns the local name of this node.  If this node has no name, then the empty string
            will be returned (never null).
            </summary>
        </member>
        <member name="P:MS.Internal.Xml.Cache.XPathNode.Name">
            <summary>
            Returns the name of this node.  If this node has no name, then the empty string
            will be returned (never null).
            </summary>
        </member>
        <member name="P:MS.Internal.Xml.Cache.XPathNode.NamespaceUri">
            <summary>
            Returns the namespace part of this node's name.  If this node has no name, then the empty string
            will be returned (never null).
            </summary>
        </member>
        <member name="P:MS.Internal.Xml.Cache.XPathNode.Document">
            <summary>
            Returns this node's document.
            </summary>
        </member>
        <member name="P:MS.Internal.Xml.Cache.XPathNode.BaseUri">
            <summary>
            Returns this node's base Uri.  This is string.Empty for all node kinds except Element, Root, and PI.
            </summary>
        </member>
        <member name="P:MS.Internal.Xml.Cache.XPathNode.LineNumber">
            <summary>
            Returns this node's source line number.
            </summary>
        </member>
        <member name="P:MS.Internal.Xml.Cache.XPathNode.LinePosition">
            <summary>
            Return this node's source line position.
            </summary>
        </member>
        <member name="P:MS.Internal.Xml.Cache.XPathNode.CollapsedLinePosition">
            <summary>
            If this node is an element with collapsed text, then return the source line position of the node (the
            source line number is the same as LineNumber).
            </summary>
        </member>
        <member name="P:MS.Internal.Xml.Cache.XPathNode.PageInfo">
            <summary>
            Returns information about the node page.  Only the 0th node on each page has this property defined.
            </summary>
        </member>
        <member name="M:MS.Internal.Xml.Cache.XPathNode.GetRoot(MS.Internal.Xml.Cache.XPathNode[]@)">
            <summary>
            Returns the root node of the current document.  This always succeeds.
            </summary>
        </member>
        <member name="M:MS.Internal.Xml.Cache.XPathNode.GetParent(MS.Internal.Xml.Cache.XPathNode[]@)">
            <summary>
            Returns the parent of this node.  If this node has no parent, then 0 is returned.
            </summary>
        </member>
        <member name="M:MS.Internal.Xml.Cache.XPathNode.GetSibling(MS.Internal.Xml.Cache.XPathNode[]@)">
            <summary>
            Returns the next sibling of this node.  If this node has no next sibling, then 0 is returned.
            </summary>
        </member>
        <member name="M:MS.Internal.Xml.Cache.XPathNode.GetSimilarElement(MS.Internal.Xml.Cache.XPathNode[]@)">
            <summary>
            Returns the next element in document order that has the same local name hashcode as this element.
            If there are no similar elements, then 0 is returned.
            </summary>
        </member>
        <member name="M:MS.Internal.Xml.Cache.XPathNode.NameMatch(System.String,System.String)">
            <summary>
            Returns true if this node's name matches the specified localName and namespaceName.  Assume
            that localName has been atomized, but namespaceName has not.
            </summary>
        </member>
        <member name="M:MS.Internal.Xml.Cache.XPathNode.ElementMatch(System.String,System.String)">
            <summary>
            Returns true if this is an Element node with a name that matches the specified localName and
            namespaceName.  Assume that localName has been atomized, but namespaceName has not.
            </summary>
        </member>
        <member name="P:MS.Internal.Xml.Cache.XPathNode.IsXmlNamespaceNode">
            <summary>
            Return true if this node is an xmlns:xml node.
            </summary>
        </member>
        <member name="P:MS.Internal.Xml.Cache.XPathNode.HasSibling">
            <summary>
            Returns true if this node has a sibling.
            </summary>
        </member>
        <member name="P:MS.Internal.Xml.Cache.XPathNode.HasCollapsedText">
            <summary>
            Returns true if this node has a collapsed text node as its only content-typed child.
            </summary>
        </member>
        <member name="P:MS.Internal.Xml.Cache.XPathNode.HasAttribute">
            <summary>
            Returns true if this node has at least one attribute.
            </summary>
        </member>
        <member name="P:MS.Internal.Xml.Cache.XPathNode.HasContentChild">
            <summary>
            Returns true if this node has at least one content-typed child (attributes and namespaces
            don't count).
            </summary>
        </member>
        <member name="P:MS.Internal.Xml.Cache.XPathNode.HasElementChild">
            <summary>
            Returns true if this node has at least one element child.
            </summary>
        </member>
        <member name="P:MS.Internal.Xml.Cache.XPathNode.IsAttrNmsp">
            <summary>
            Returns true if this is an attribute or namespace node.
            </summary>
        </member>
        <member name="P:MS.Internal.Xml.Cache.XPathNode.IsText">
            <summary>
            Returns true if this is a text or whitespace node.
            </summary>
        </member>
        <member name="P:MS.Internal.Xml.Cache.XPathNode.HasNamespaceDecls">
            <summary>
            Returns true if this node has local namespace declarations associated with it.  Since all
            namespace declarations are stored out-of-line in the owner Document, this property
            can be consulted in order to avoid a lookup in the common case where this node has no
            local namespace declarations.
            </summary>
        </member>
        <member name="P:MS.Internal.Xml.Cache.XPathNode.AllowShortcutTag">
            <summary>
            Returns true if this node is an empty element that allows shortcut tag syntax.
            </summary>
        </member>
        <member name="P:MS.Internal.Xml.Cache.XPathNode.LocalNameHashCode">
            <summary>
            Cached hashcode computed over the local name of this element.
            </summary>
        </member>
        <member name="P:MS.Internal.Xml.Cache.XPathNode.Value">
            <summary>
            Return the precomputed String value of this node (null if no value exists, i.e. document node, element node with complex content, etc).
            </summary>
        </member>
        <member name="M:MS.Internal.Xml.Cache.XPathNode.Create(MS.Internal.Xml.Cache.XPathNodePageInfo)">
            <summary>
            Constructs the 0th XPathNode in each page, which contains only page information.
            </summary>
        </member>
        <member name="M:MS.Internal.Xml.Cache.XPathNode.Create(MS.Internal.Xml.Cache.XPathNodeInfoAtom,System.Xml.XPath.XPathNodeType,System.Int32)">
            <summary>
            Constructs a XPathNode.  Later, the idxSibling and value fields may be fixed up.
            </summary>
        </member>
        <member name="M:MS.Internal.Xml.Cache.XPathNode.SetLineInfoOffsets(System.Int32,System.Int32)">
            <summary>
            Set this node's line number information.
            </summary>
        </member>
        <member name="M:MS.Internal.Xml.Cache.XPathNode.SetCollapsedLineInfoOffset(System.Int32)">
            <summary>
            Set the position offset of this element's collapsed text.
            </summary>
        </member>
        <member name="M:MS.Internal.Xml.Cache.XPathNode.SetValue(System.String)">
            <summary>
            Set this node's value.
            </summary>
        </member>
        <member name="M:MS.Internal.Xml.Cache.XPathNode.SetEmptyValue(System.Boolean)">
            <summary>
            Create an empty element value.
            </summary>
        </member>
        <member name="M:MS.Internal.Xml.Cache.XPathNode.SetCollapsedValue(System.String)">
            <summary>
            Create a collapsed text node on this element having the specified value.
            </summary>
        </member>
        <member name="M:MS.Internal.Xml.Cache.XPathNode.SetParentProperties(System.Xml.XPath.XPathNodeType)">
            <summary>
            This method is called when a new child is appended to this node's list of attributes and children.
            The type of the new child is used to determine how various parent properties should be set.
            </summary>
        </member>
        <member name="M:MS.Internal.Xml.Cache.XPathNode.SetSibling(MS.Internal.Xml.Cache.XPathNodeInfoTable,MS.Internal.Xml.Cache.XPathNode[],System.Int32)">
            <summary>
            Link this node to its next sibling.  If "pageSibling" is different than the one stored in the InfoAtom, re-atomize.
            </summary>
        </member>
        <member name="M:MS.Internal.Xml.Cache.XPathNode.SetSimilarElement(MS.Internal.Xml.Cache.XPathNodeInfoTable,MS.Internal.Xml.Cache.XPathNode[],System.Int32)">
            <summary>
            Link this element to the next element in document order that shares a local name having the same hash code.
            If "pageSimilar" is different than the one stored in the InfoAtom, re-atomize.
            </summary>
        </member>
        <member name="T:MS.Internal.Xml.Cache.XPathNodeRef">
            <summary>
            A reference to a XPathNode is composed of two values: the page on which the node is located, and the node's
            index in the page.
            </summary>
        </member>
        <member name="T:MS.Internal.Xml.Cache.XPathNodeHelper">
            <summary>
            Library of XPathNode helper routines.
            </summary>
        </member>
        <member name="M:MS.Internal.Xml.Cache.XPathNodeHelper.GetLocalNamespaces(MS.Internal.Xml.Cache.XPathNode[],System.Int32,MS.Internal.Xml.Cache.XPathNode[]@)">
            <summary>
            Return chain of namespace nodes.  If specified node has no local namespaces, then 0 will be
            returned.  Otherwise, the first node in the chain is guaranteed to be a local namespace (its
            parent is this node).  Subsequent nodes may not have the same node as parent, so the caller will
            need to test the parent in order to terminate a search that processes only local namespaces.
            </summary>
        </member>
        <member name="M:MS.Internal.Xml.Cache.XPathNodeHelper.GetInScopeNamespaces(MS.Internal.Xml.Cache.XPathNode[],System.Int32,MS.Internal.Xml.Cache.XPathNode[]@)">
            <summary>
            Return chain of in-scope namespace nodes for nodes of type Element.  Nodes in the chain might not
            have this element as their parent.  Since the xmlns:xml namespace node is always in scope, this
            method will never return 0 if the specified node is an element.
            </summary>
        </member>
        <member name="M:MS.Internal.Xml.Cache.XPathNodeHelper.GetFirstAttribute(MS.Internal.Xml.Cache.XPathNode[]@,System.Int32@)">
            <summary>
            Return the first attribute of the specified node.  If no attribute exist, do not
            set pageNode or idxNode and return false.
            </summary>
        </member>
        <member name="M:MS.Internal.Xml.Cache.XPathNodeHelper.GetNextAttribute(MS.Internal.Xml.Cache.XPathNode[]@,System.Int32@)">
            <summary>
            Return the next attribute sibling of the specified node.  If the node is not itself an
            attribute, or if there are no siblings, then do not set pageNode or idxNode and return false.
            </summary>
        </member>
        <member name="M:MS.Internal.Xml.Cache.XPathNodeHelper.GetContentChild(MS.Internal.Xml.Cache.XPathNode[]@,System.Int32@)">
            <summary>
            Return the first content-typed child of the specified node.  If the node has no children, or
            if the node is not content-typed, then do not set pageNode or idxNode and return false.
            </summary>
        </member>
        <member name="M:MS.Internal.Xml.Cache.XPathNodeHelper.GetContentSibling(MS.Internal.Xml.Cache.XPathNode[]@,System.Int32@)">
            <summary>
            Return the next content-typed sibling of the specified node.  If the node has no siblings, or
            if the node is not content-typed, then do not set pageNode or idxNode and return false.
            </summary>
        </member>
        <member name="M:MS.Internal.Xml.Cache.XPathNodeHelper.GetParent(MS.Internal.Xml.Cache.XPathNode[]@,System.Int32@)">
            <summary>
            Return the parent of the specified node.  If the node has no parent, do not set pageNode
            or idxNode and return false.
            </summary>
        </member>
        <member name="M:MS.Internal.Xml.Cache.XPathNodeHelper.GetLocation(MS.Internal.Xml.Cache.XPathNode[],System.Int32)">
            <summary>
            Return a location integer that can be easily compared with other locations from the same document
            in order to determine the relative document order of two nodes.
            </summary>
        </member>
        <member name="M:MS.Internal.Xml.Cache.XPathNodeHelper.GetElementChild(MS.Internal.Xml.Cache.XPathNode[]@,System.Int32@,System.String,System.String)">
            <summary>
            Return the first element child of the specified node that has the specified name.  If no such child exists,
            then do not set pageNode or idxNode and return false.  Assume that the localName has been atomized with respect
            to this document's name table, but not the namespaceName.
            </summary>
        </member>
        <member name="M:MS.Internal.Xml.Cache.XPathNodeHelper.GetElementSibling(MS.Internal.Xml.Cache.XPathNode[]@,System.Int32@,System.String,System.String)">
            <summary>
            Return a following sibling element of the specified node that has the specified name.  If no such
            sibling exists, or if the node is not content-typed, then do not set pageNode or idxNode and
            return false.  Assume that the localName has been atomized with respect to this document's name table,
            but not the namespaceName.
            </summary>
        </member>
        <member name="M:MS.Internal.Xml.Cache.XPathNodeHelper.GetContentChild(MS.Internal.Xml.Cache.XPathNode[]@,System.Int32@,System.Xml.XPath.XPathNodeType)">
            <summary>
            Return the first child of the specified node that has the specified type (must be a content type).  If no such
            child exists, then do not set pageNode or idxNode and return false.
            </summary>
        </member>
        <member name="M:MS.Internal.Xml.Cache.XPathNodeHelper.GetContentSibling(MS.Internal.Xml.Cache.XPathNode[]@,System.Int32@,System.Xml.XPath.XPathNodeType)">
            <summary>
            Return a following sibling of the specified node that has the specified type.  If no such
            sibling exists, then do not set pageNode or idxNode and return false.
            </summary>
        </member>
        <member name="M:MS.Internal.Xml.Cache.XPathNodeHelper.GetPreviousContentSibling(MS.Internal.Xml.Cache.XPathNode[]@,System.Int32@)">
            <summary>
            Return the first preceding sibling of the specified node.  If no such sibling exists, then do not set
            pageNode or idxNode and return false.
            </summary>
        </member>
        <member name="M:MS.Internal.Xml.Cache.XPathNodeHelper.GetAttribute(MS.Internal.Xml.Cache.XPathNode[]@,System.Int32@,System.String,System.String)">
            <summary>
            Return the attribute of the specified node that has the specified name.  If no such attribute exists,
            then do not set pageNode or idxNode and return false.  Assume that the localName has been atomized with respect
            to this document's name table, but not the namespaceName.
            </summary>
        </member>
        <member name="M:MS.Internal.Xml.Cache.XPathNodeHelper.GetElementFollowing(MS.Internal.Xml.Cache.XPathNode[]@,System.Int32@,MS.Internal.Xml.Cache.XPathNode[],System.Int32,System.String,System.String)">
            <summary>
            Get the next element node that:
              1. Follows the current node in document order (includes descendants, unlike XPath following axis)
              2. Precedes the ending node in document order (if pageEnd is null, then all following nodes in the document are considered)
              3. Has the specified QName
            If no such element exists, then do not set pageCurrent or idxCurrent and return false.
            Assume that the localName has been atomized with respect to this document's name table, but not the namespaceName.
            </summary>
        </member>
        <member name="M:MS.Internal.Xml.Cache.XPathNodeHelper.GetContentFollowing(MS.Internal.Xml.Cache.XPathNode[]@,System.Int32@,MS.Internal.Xml.Cache.XPathNode[],System.Int32,System.Xml.XPath.XPathNodeType)">
            <summary>
            Get the next node that:
              1. Follows the current node in document order (includes descendants, unlike XPath following axis)
              2. Precedes the ending node in document order (if pageEnd is null, then all following nodes in the document are considered)
              3. Has the specified XPathNodeType (but Attributes and Namespaces never match)
            If no such node exists, then do not set pageCurrent or idxCurrent and return false.
            </summary>
        </member>
        <member name="M:MS.Internal.Xml.Cache.XPathNodeHelper.GetTextFollowing(MS.Internal.Xml.Cache.XPathNode[]@,System.Int32@,MS.Internal.Xml.Cache.XPathNode[],System.Int32)">
            <summary>
            Scan all nodes that follow the current node in document order, but precede the ending node in document order.
            Return two types of nodes with non-null text:
              1. Element parents of collapsed text nodes (since it is the element parent that has the collapsed text)
              2. Non-collapsed text nodes
            If no such node exists, then do not set pageCurrent or idxCurrent and return false.
            </summary>
        </member>
        <member name="M:MS.Internal.Xml.Cache.XPathNodeHelper.GetNonDescendant(MS.Internal.Xml.Cache.XPathNode[]@,System.Int32@)">
            <summary>
            Get the next non-virtual (not collapsed text, not namespaces) node that follows the specified node in document order,
            but is not a descendant.  If no such node exists, then do not set pageNode or idxNode and return false.
            </summary>
        </member>
        <member name="M:MS.Internal.Xml.Cache.XPathNodeHelper.GetChild(MS.Internal.Xml.Cache.XPathNode[]@,System.Int32@)">
            <summary>
            Return the page and index of the first child (attribute or content) of the specified node.
            </summary>
        </member>
        <member name="T:MS.Internal.Xml.Cache.XPathNodePageInfo">
            <summary>
            The 0th node in each page contains a non-null reference to an XPathNodePageInfo internal class that provides
            information about that node's page.  The other fields in the 0th node are undefined and should never
            be used.
            </summary>
        </member>
        <member name="M:MS.Internal.Xml.Cache.XPathNodePageInfo.#ctor(MS.Internal.Xml.Cache.XPathNode[],System.Int32)">
            <summary>
            Constructor.
            </summary>
        </member>
        <member name="P:MS.Internal.Xml.Cache.XPathNodePageInfo.PageNumber">
            <summary>
            Return the sequential page number of the page containing nodes that share this information atom.
            </summary>
        </member>
        <member name="P:MS.Internal.Xml.Cache.XPathNodePageInfo.NodeCount">
            <summary>
            Return the number of nodes allocated in this page.
            </summary>
        </member>
        <member name="P:MS.Internal.Xml.Cache.XPathNodePageInfo.PreviousPage">
            <summary>
            Return the previous node page in the document.
            </summary>
        </member>
        <member name="P:MS.Internal.Xml.Cache.XPathNodePageInfo.NextPage">
            <summary>
            Return the next node page in the document.
            </summary>
        </member>
        <member name="T:MS.Internal.Xml.Cache.XPathNodeInfoAtom">
            <summary>
            There is a great deal of redundancy in typical Xml documents.  Even in documents with thousands or millions
            of nodes, there are a small number of common names and types.  And since nodes are allocated in pages in
            document order, nodes on the same page with the same name and type are likely to have the same sibling and
            parent pages as well.
            Redundant information is shared by creating immutable, atomized objects.  This is analogous to the
            string.Intern() operation.  If a node's name, type, or parent/sibling pages are modified, then a new
            InfoAtom needs to be obtained, since other nodes may still be referencing the old InfoAtom.
            </summary>
        </member>
        <member name="M:MS.Internal.Xml.Cache.XPathNodeInfoAtom.#ctor(MS.Internal.Xml.Cache.XPathNodePageInfo)">
            <summary>
            Construct information for the 0th node in each page.  The only field which is defined is this.pageInfo,
            and it contains information about that page (pageNum, nextPage, etc.).
            </summary>
        </member>
        <member name="M:MS.Internal.Xml.Cache.XPathNodeInfoAtom.#ctor(System.String,System.String,System.String,System.String,MS.Internal.Xml.Cache.XPathNode[],MS.Internal.Xml.Cache.XPathNode[],MS.Internal.Xml.Cache.XPathNode[],System.Xml.XPath.XPathDocument,System.Int32,System.Int32)">
            <summary>
            Construct a new shared information atom.  This method should only be used by the XNodeInfoTable.
            </summary>
        </member>
        <member name="M:MS.Internal.Xml.Cache.XPathNodeInfoAtom.Init(System.String,System.String,System.String,System.String,MS.Internal.Xml.Cache.XPathNode[],MS.Internal.Xml.Cache.XPathNode[],MS.Internal.Xml.Cache.XPathNode[],System.Xml.XPath.XPathDocument,System.Int32,System.Int32)">
            <summary>
            Initialize an existing shared information atom.  This method should only be used by the XNodeInfoTable.
            </summary>
        </member>
        <member name="P:MS.Internal.Xml.Cache.XPathNodeInfoAtom.PageInfo">
            <summary>
            Returns information about the node page.  Only the 0th node on each page has this property defined.
            </summary>
        </member>
        <member name="P:MS.Internal.Xml.Cache.XPathNodeInfoAtom.LocalName">
            <summary>
            Return the local name part of nodes that share this information atom.
            </summary>
        </member>
        <member name="P:MS.Internal.Xml.Cache.XPathNodeInfoAtom.NamespaceUri">
            <summary>
            Return the namespace name part of nodes that share this information atom.
            </summary>
        </member>
        <member name="P:MS.Internal.Xml.Cache.XPathNodeInfoAtom.Prefix">
            <summary>
            Return the prefix name part of nodes that share this information atom.
            </summary>
        </member>
        <member name="P:MS.Internal.Xml.Cache.XPathNodeInfoAtom.BaseUri">
            <summary>
            Return the base Uri of nodes that share this information atom.
            </summary>
        </member>
        <member name="P:MS.Internal.Xml.Cache.XPathNodeInfoAtom.SiblingPage">
            <summary>
            Return the page containing the next sibling of nodes that share this information atom.
            </summary>
        </member>
        <member name="P:MS.Internal.Xml.Cache.XPathNodeInfoAtom.SimilarElementPage">
            <summary>
            Return the page containing the next element having a name which has same hashcode as this element.
            </summary>
        </member>
        <member name="P:MS.Internal.Xml.Cache.XPathNodeInfoAtom.ParentPage">
            <summary>
            Return the page containing the parent of nodes that share this information atom.
            </summary>
        </member>
        <member name="P:MS.Internal.Xml.Cache.XPathNodeInfoAtom.Document">
            <summary>
            Return the page containing the owner document of nodes that share this information atom.
            </summary>
        </member>
        <member name="P:MS.Internal.Xml.Cache.XPathNodeInfoAtom.LineNumberBase">
            <summary>
            Return the line number to which a line number offset stored in the XPathNode is added.
            </summary>
        </member>
        <member name="P:MS.Internal.Xml.Cache.XPathNodeInfoAtom.LinePositionBase">
            <summary>
            Return the line position to which a line position offset stored in the XPathNode is added.
            </summary>
        </member>
        <member name="P:MS.Internal.Xml.Cache.XPathNodeInfoAtom.LocalNameHashCode">
            <summary>
            Return cached hash code of the local name of nodes which share this information atom.
            </summary>
        </member>
        <member name="P:MS.Internal.Xml.Cache.XPathNodeInfoAtom.Next">
            <summary>
            Link together InfoAtoms that hash to the same hashtable bucket (should only be used by XPathNodeInfoTable)
            </summary>
        </member>
        <member name="M:MS.Internal.Xml.Cache.XPathNodeInfoAtom.GetHashCode">
            <summary>
            Return this information atom's hash code, previously computed for performance.
            </summary>
        </member>
        <member name="M:MS.Internal.Xml.Cache.XPathNodeInfoAtom.Equals(System.Object)">
            <summary>
            Return true if this InfoAtom has the same values as another InfoAtom.
            </summary>
        </member>
        <member name="M:MS.Internal.Xml.Cache.XPathNodeInfoAtom.ToString">
            <summary>
            Return InfoAtom formatted as a string:
                hash=xxx, {http://my.com}foo:bar, parent=1, sibling=1, lineNum=0, linePos=0
            </summary>
        </member>
        <member name="T:MS.Internal.Xml.Cache.XPathNodeInfoTable">
            <summary>
            An atomization table for XPathNodeInfoAtom.
            </summary>
        </member>
        <member name="M:MS.Internal.Xml.Cache.XPathNodeInfoTable.#ctor">
            <summary>
            Constructor.
            </summary>
        </member>
        <member name="M:MS.Internal.Xml.Cache.XPathNodeInfoTable.Create(System.String,System.String,System.String,System.String,MS.Internal.Xml.Cache.XPathNode[],MS.Internal.Xml.Cache.XPathNode[],MS.Internal.Xml.Cache.XPathNode[],System.Xml.XPath.XPathDocument,System.Int32,System.Int32)">
            <summary>
            Create a new XNodeInfoAtom and ensure it is atomized in the table.
            </summary>
        </member>
        <member name="M:MS.Internal.Xml.Cache.XPathNodeInfoTable.Atomize(MS.Internal.Xml.Cache.XPathNodeInfoAtom)">
            <summary>
            Add a shared information item to the atomization table.  If a matching item already exists, then that
            instance is returned.  Otherwise, a new item is created.  Thus, if itemX and itemY have both been added
            to the same InfoTable:
            1. itemX.Equals(itemY) != true
            2. (object) itemX != (object) itemY
            </summary>
        </member>
        <member name="M:MS.Internal.Xml.Cache.XPathNodeInfoTable.AddInfo(MS.Internal.Xml.Cache.XPathNodeInfoAtom)">
            <summary>
            Add a previously constructed InfoAtom to the table.  If a collision occurs, then insert "info"
            as the head of a linked list.
            </summary>
        </member>
        <member name="M:MS.Internal.Xml.Cache.XPathNodeInfoTable.ToString">
            <summary>
            Return InfoAtomTable formatted as a string.
            </summary>
        </member>
    </members>
</doc>
